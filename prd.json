{
  "project": "orbiter-observability",
  "branchName": "ralph/orbiter-observability",
  "description": "Consolidated observability package replacing orbiter.log and orbiter-trace with a unified, production-grade stdlib-first, OTel-optional observability layer",
  "userStories": [
    {
      "id": "US-001",
      "title": "Create package scaffold and configuration",
      "description": "As a developer, I need the orbiter-observability package set up in the monorepo with its pyproject.toml, namespace package init, and configuration model so that all subsequent modules have a foundation.",
      "acceptanceCriteria": [
        "packages/orbiter-observability/ directory created with pyproject.toml following existing patterns (hatchling, src/orbiter/ layout)",
        "src/orbiter/observability/__init__.py created as sub-namespace under orbiter.observability",
        "ObservabilityConfig pydantic model in config.py with: log_level (str, default 'WARNING'), log_format ('text' | 'json', default 'text'), trace_enabled (bool, default False), trace_backend (enum: otlp/memory/console), trace_endpoint (str|None), service_name (str, default 'orbiter'), sample_rate (float, 0.0-1.0), metrics_enabled (bool, default False), namespace (str, default 'orbiter')",
        "configure(config: ObservabilityConfig | None = None, **kwargs) top-level function that initializes all subsystems",
        "Package added to root pyproject.toml workspace members and dev dependencies",
        "[project.optional-dependencies] includes otel = ['opentelemetry-api>=1.20', 'opentelemetry-sdk>=1.20'] and otlp = ['opentelemetry-exporter-otlp>=1.20']",
        "Base dependencies: only pydantic>=2.0 (no opentelemetry in base)",
        "uv sync succeeds with the new package",
        "Tests: config validation, configure() idempotency, kwargs override",
        "Pyright passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "This is the foundation story — all other stories depend on this scaffold existing. Follow the exact same pyproject.toml pattern as packages/orbiter-core/pyproject.toml and packages/orbiter-trace/pyproject.toml. Use hatchling with packages = ['src/orbiter'] to extend the orbiter.* namespace."
    },
    {
      "id": "US-002",
      "title": "Structured logging module",
      "description": "As a developer, I want a structured logging system that replaces orbiter.log so I get consistent, formatted log output across all orbiter packages with zero external dependencies.",
      "acceptanceCriteria": [
        "orbiter/observability/logging.py with get_logger(name) and configure_logging(level, format) functions",
        "Text formatter: compact single-line ANSI output (port from existing orbiter.log._Formatter)",
        "JSON formatter: structured {timestamp, level, logger, message, extra} output for production",
        "Format selection via ObservabilityConfig.log_format ('text' | 'json')",
        "Auto-namespace: get_logger('agent') returns logger named orbiter.agent",
        "Idempotent configure (calling twice is a no-op unless force=True)",
        "Context injection: optional context_vars dict attached to log records (agent_name, task_id, session_id)",
        "LogContext context manager that binds key-value pairs to all logs within its scope (via contextvars)",
        "Zero external dependencies — stdlib logging only",
        "Tests: both formatters, namespace auto-prefixing, idempotency, LogContext binding",
        "Pyright passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Port the _Formatter, get_logger, and configure from packages/orbiter-core/src/orbiter/log.py (87 lines). Add JSON formatter and LogContext as new functionality. Use test prefix test_obs_logging.py to avoid collision with orbiter-core's test_log.py."
    },
    {
      "id": "US-003",
      "title": "Semantic conventions",
      "description": "As a developer, I need standardized attribute names for agent, tool, LLM, and task spans/metrics so that all orbiter telemetry is consistent and queryable.",
      "acceptanceCriteria": [
        "orbiter/observability/semconv.py with all semantic convention constants",
        "GenAI conventions: gen_ai.system, gen_ai.request.model, gen_ai.usage.*, etc. (port from existing config.py)",
        "Agent conventions: orbiter.agent.{id,name,type,model,step,max_steps,run.success}",
        "Tool conventions: orbiter.tool.{name,call_id,arguments,result,error,duration,step.success}",
        "Task/session conventions: orbiter.task.id, orbiter.session.id, orbiter.user.id",
        "Span name prefixes: agent., tool., llm., task.",
        "Cost conventions (new): orbiter.cost.input_tokens, orbiter.cost.output_tokens, orbiter.cost.total_usd",
        "Tests: constants are strings, no duplicates, naming pattern validation",
        "Pyright passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Port all constants from packages/orbiter-trace/src/orbiter/trace/config.py lines 87-151. Add new cost conventions. This is a pure-data module with no logic dependencies — needed by metrics, tracing, and instrumentation stories."
    },
    {
      "id": "US-004",
      "title": "Distributed tracing with optional OTel",
      "description": "As a developer, I want a @traced decorator and span context managers that work with or without OpenTelemetry installed, so I can instrument code without requiring OTel in development.",
      "acceptanceCriteria": [
        "orbiter/observability/tracing.py with @traced decorator, span() sync context manager, aspan() async context manager",
        "When OTel is NOT installed: @traced is a no-op passthrough, span()/aspan() yield a NullSpan stub",
        "When OTel IS installed: delegates to real opentelemetry.trace spans",
        "@traced supports: sync functions, async functions, sync generators, async generators",
        "Function metadata extraction: qualname, module, lineno, parameters (port from existing decorator.py)",
        "User-code frame filtering: is_user_code(), get_user_frame() (port from existing)",
        "extract_args=True option records call arguments as span attributes",
        "Exception recording on spans (set status, record_exception)",
        "Tests: all 4 function types with and without OTel, NullSpan behavior, metadata extraction, exception recording",
        "Pyright passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Port from packages/orbiter-trace/src/orbiter/trace/decorator.py (~210 lines). Key change: add NullSpan fallback and try/except import pattern for OTel. Use HAS_OTEL = bool to gate real vs stub behavior. Port tests from test_trace_decorator.py."
    },
    {
      "id": "US-005",
      "title": "Metrics collection",
      "description": "As a developer, I want to record agent and tool metrics (counters, histograms) with a stdlib fallback when OTel is not installed.",
      "acceptanceCriteria": [
        "orbiter/observability/metrics.py with metric recording functions",
        "MetricsCollector class: in-memory metric storage when OTel is not installed",
        "Instrument factories: create_counter(name, unit, description), create_histogram(name, unit, description), create_gauge(name, unit, description)",
        "When OTel is installed: delegates to opentelemetry.metrics meter",
        "When OTel is not installed: records to in-memory MetricsCollector (dict-based)",
        "record_agent_run(duration, success, attributes, input_tokens, output_tokens) helper (port from existing)",
        "record_tool_step(duration, success, attributes) helper (port from existing)",
        "Timer context manager for measuring durations (port from existing)",
        "get_metrics_snapshot() -> dict for reading in-memory metrics (useful for tests and health checks)",
        "Attribute builders: build_agent_attributes(), build_tool_attributes() (port from existing)",
        "Tests: both OTel and stdlib paths, Timer, snapshot, attribute builders",
        "Pyright passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Port from packages/orbiter-trace/src/orbiter/trace/instrumentation.py (~240 lines). Key change: add MetricsCollector in-memory fallback when OTel not installed. Uses semconv constants from US-003. Port tests from test_trace_instrumentation.py."
    },
    {
      "id": "US-006",
      "title": "Prompt execution logger",
      "description": "As a developer, I want structured logging of LLM executions — token breakdown by role, context window usage, and duration — so I can monitor and debug agent behavior.",
      "acceptanceCriteria": [
        "orbiter/observability/prompt_logger.py with PromptLogger, TokenBreakdown, ExecutionLogEntry",
        "estimate_tokens(text, ratio) for heuristic token counting (port from existing)",
        "compute_token_breakdown(messages) with per-role counting: system, user, assistant, tool, other (port from existing)",
        "Multi-modal content handling: text items summed, images as fixed estimate, tool_use serialization cost",
        "ExecutionLogEntry dataclass with format_summary() for human-readable output",
        "PromptLogger.log_execution() computes breakdown and logs structured entry",
        "Context window percentage breakdown (used/free with per-role percentages)",
        "Tests: token estimation, breakdown computation, multi-modal, format_summary, log_execution",
        "Pyright passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Direct port from packages/orbiter-trace/src/orbiter/trace/prompt_logger.py (~242 lines). Minimal changes needed — just update imports to use orbiter.observability.logging instead of stdlib logging directly. Port tests from test_trace_prompt_logger.py."
    },
    {
      "id": "US-007",
      "title": "Trace context propagation",
      "description": "As a developer, I want W3C Baggage propagation and a span consumer plugin system so that trace context flows across service boundaries.",
      "acceptanceCriteria": [
        "orbiter/observability/propagation.py with BaggagePropagator, Carrier, DictCarrier, SpanConsumer",
        "W3C Baggage extract/inject with URL-encoding and size limits (RFC 9110) — port from existing",
        "Carrier protocol for header containers + DictCarrier implementation",
        "Async-safe baggage storage via contextvars.ContextVar",
        "set_baggage(), get_baggage(), get_baggage_value(), clear_baggage() functions",
        "SpanConsumer ABC with register_span_consumer(), dispatch_spans(), list_span_consumers(), clear_span_consumers()",
        "Tests: extract/inject round-trip, size limits, URL encoding, baggage context isolation, consumer lifecycle",
        "Pyright passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Direct port from packages/orbiter-trace/src/orbiter/trace/propagation.py (~239 lines). No OTel dependency — pure stdlib. Port tests from test_trace_propagation.py."
    },
    {
      "id": "US-008",
      "title": "Health check system",
      "description": "As an operator, I want health check endpoints so that I can monitor whether the observability pipeline is functioning and whether agents are healthy.",
      "acceptanceCriteria": [
        "orbiter/observability/health.py with HealthCheck, HealthStatus, HealthRegistry",
        "HealthStatus enum: HEALTHY, DEGRADED, UNHEALTHY",
        "HealthCheck protocol: name property and check() -> HealthResult method",
        "HealthResult dataclass: status (HealthStatus), message (str), metadata (dict), checked_at (datetime)",
        "HealthRegistry: register checks, run all checks, return aggregate status",
        "Built-in checks: MemoryUsageCheck (RSS threshold), EventLoopCheck (lag threshold)",
        "get_health_summary() -> dict returns JSON-serializable health report",
        "Aggregate status: UNHEALTHY if any check is UNHEALTHY, DEGRADED if any is DEGRADED, else HEALTHY",
        "Tests: registry lifecycle, aggregate logic, built-in checks with mocked thresholds",
        "Pyright passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "New module — no existing code to port. Use stdlib only (resource module for RSS, asyncio for event loop lag). Keep it simple: protocol-based HealthCheck, dataclass HealthResult, registry pattern."
    },
    {
      "id": "US-009",
      "title": "Alerting hooks",
      "description": "As a developer, I want to register alerting callbacks that fire when metrics exceed thresholds so that I can integrate with external alerting systems (PagerDuty, Slack, etc.).",
      "acceptanceCriteria": [
        "orbiter/observability/alerts.py with AlertRule, AlertManager, AlertSeverity",
        "AlertSeverity enum: INFO, WARNING, CRITICAL",
        "AlertRule dataclass: name, metric_name, threshold, comparator (gt/lt/gte/lte/eq), severity, cooldown_seconds (default 300)",
        "AlertCallback protocol: callable taking an Alert argument (sync or async)",
        "Alert dataclass: rule_name, metric_value, threshold, severity, timestamp, metadata",
        "AlertManager: register rules, register callbacks, evaluate(metric_name, value) checks rules and fires callbacks",
        "Cooldown enforcement: same rule does not fire again within cooldown_seconds",
        "clear_alerts() and list_rules() for management",
        "Tests: rule evaluation, threshold comparators, cooldown, callback invocation, multiple rules per metric",
        "Pyright passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": "New module — no existing code to port. Use time.monotonic() for cooldown tracking. Support both sync and async callbacks via inspect.iscoroutinefunction check."
    },
    {
      "id": "US-010",
      "title": "Cost estimation",
      "description": "As a developer, I want automatic cost tracking per LLM call so I can monitor spending across agents and models.",
      "acceptanceCriteria": [
        "orbiter/observability/cost.py with CostTracker, CostEntry, ModelPricing",
        "ModelPricing dataclass: model_pattern (regex), input_cost_per_1k (float), output_cost_per_1k (float)",
        "Built-in pricing table for common models: gpt-4o, gpt-4o-mini, claude-sonnet-4-5-20250514, claude-haiku-3-5-20241022, gemini-2.0-flash (updatable via register_pricing())",
        "CostEntry dataclass: model, input_tokens, output_tokens, input_cost, output_cost, total_cost, timestamp",
        "CostTracker: record(model, input_tokens, output_tokens) -> CostEntry, get_total() -> float, get_breakdown() -> dict[str, float] (per-model), get_entries(since: datetime | None) -> list[CostEntry]",
        "Thread-safe (uses threading.Lock)",
        "reset() to clear tracked costs",
        "Tests: pricing lookup, cost calculation, breakdown, unknown model handling (returns 0 cost with warning), thread safety",
        "Pyright passes"
      ],
      "priority": 10,
      "passes": true,
      "notes": "New module — no existing code to port. Use re.match for model_pattern matching against model name strings. Pricing values should be hardcoded constants (easy to update). Thread safety via threading.Lock around the entries list."
    },
    {
      "id": "US-011",
      "title": "SLO tracking",
      "description": "As an operator, I want to define Service Level Objectives and track compliance so I can measure reliability of agent operations.",
      "acceptanceCriteria": [
        "orbiter/observability/slo.py with SLO, SLOTracker, SLOReport",
        "SLO dataclass: name, metric_name, target (float, e.g. 0.99 for 99%), window_seconds (default 3600), comparator ('lt' for latency, 'gt' for success rate)",
        "SLOTracker: register(slo), record(metric_name, value), report(slo_name) -> SLOReport",
        "SLOReport dataclass: slo_name, target, actual, budget_remaining (float 0-1), compliant (bool), window_start, total_samples, violating_samples",
        "Sliding window: only considers samples within window_seconds of now",
        "report_all() -> list[SLOReport] for dashboard integration",
        "reset() to clear tracking data",
        "Tests: SLO compliance/violation, sliding window expiry, budget calculation, multiple SLOs",
        "Pyright passes"
      ],
      "priority": 11,
      "passes": true,
      "notes": "New module — no existing code to port. Use time.monotonic() for timestamps in the sliding window. Store samples as list of (timestamp, value) tuples. Filter expired samples on each report() call."
    },
    {
      "id": "US-012",
      "title": "Update orbiter-core to use orbiter-observability",
      "description": "As a developer, I need orbiter-core to depend on orbiter-observability instead of its inline log.py, and update all internal imports.",
      "acceptanceCriteria": [
        "orbiter-core/pyproject.toml adds orbiter-observability>=0.1.0 dependency with [tool.uv.sources] workspace entry",
        "orbiter.log module replaced with a thin re-export shim: from orbiter.observability.logging import get_logger, configure (backward compatibility)",
        "All internal imports in orbiter-core (agent.py, swarm.py, call_runner.py) updated to use orbiter.observability.logging",
        "orbiter/__init__.py exports configure and get_logger from new location",
        "All existing test_log.py tests still pass",
        "uv sync succeeds",
        "Pyright passes"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Depends on US-001 and US-002 being complete. The shim in orbiter.log should be minimal: just re-exports. Files to update: packages/orbiter-core/src/orbiter/log.py, agent.py, swarm.py, _internal/call_runner.py, __init__.py, pyproject.toml."
    },
    {
      "id": "US-013",
      "title": "Remove orbiter-trace package",
      "description": "As a developer, I need to remove the now-redundant orbiter-trace package since all its functionality is consolidated into orbiter-observability.",
      "acceptanceCriteria": [
        "packages/orbiter-trace/ directory deleted",
        "orbiter-trace removed from root pyproject.toml workspace members and dev dependencies",
        "Any packages that depended on orbiter-trace updated to depend on orbiter-observability instead",
        "All existing orbiter-trace tests ported to packages/orbiter-observability/tests/ and passing",
        "uv sync succeeds",
        "Full test suite passes (pytest packages/)",
        "Pyright passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": "Depends on US-003 through US-007 being complete (all orbiter-trace functionality ported). Test files to port: test_trace_config.py, test_trace_decorator.py, test_trace_instrumentation.py, test_trace_prompt_logger.py, test_trace_propagation.py. Rename them with test_obs_ prefix."
    },
    {
      "id": "US-014",
      "title": "Public API and __init__.py exports",
      "description": "As a developer, I want a clean public API from orbiter.observability that exposes all key functions and classes so that users have a single import point.",
      "acceptanceCriteria": [
        "orbiter/observability/__init__.py exports all public symbols with __all__",
        "Tiered imports: core symbols (get_logger, configure, traced, span) importable from orbiter.observability directly",
        "Sub-module imports work: from orbiter.observability.metrics import MetricsCollector",
        "Lazy imports for OTel-dependent code (no ImportError if opentelemetry not installed)",
        "Convenience: from orbiter.observability import get_logger, configure, traced covers 90% of use cases",
        "Tests: import smoke tests with and without OTel, __all__ completeness check",
        "Pyright passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": "Final polish story — depends on all modules (US-001 through US-011) being complete. Use lazy imports via a _lazy_import helper or __getattr__ on the module to avoid importing OTel at module load time."
    }
  ]
}
