# Ralph Progress Log
Started: Sun Feb 15 04:58:56 PM IST 2026

## Codebase Patterns
- UV workspace monorepo: 12 packages under `packages/`, root pyproject.toml has NO build-system
- Namespace packages: `orbiter-core/__init__.py` uses `pkgutil.extend_path()` so other packages add to the `orbiter` namespace
- Meta-package at `packages/orbiter/` uses `_orbiter_meta` dummy package for hatchling compatibility
- Quality checks: `uv run ruff check packages/`, `uv run ruff format --check packages/`, `uv run pyright packages/orbiter-core/`, `uv run pytest`
- Use `Sequence[Message]` (not `list[Message]`) for function params that accept subtype lists — avoids pyright invariance errors
- Use `ClassVar[dict[...]]` for mutable class attributes on dataclass-like test fixtures to avoid RUF012 lint errors
- Use `StrEnum` (not `str, Enum`) for string enums — ruff UP042 enforces this
- Test file names must be unique across all packages (pytest collects `tests/` from multiple packages into one `tests` module)
- pytest-asyncio `asyncio_mode = "auto"` configured in root pyproject.toml — no need for `@pytest.mark.asyncio`
- Import sorting: ruff enforces I001 import block sorting — use `uv run ruff check --fix` to auto-sort
- Forward-compatible params: use `Any` type with `None` default for params whose concrete types come from future packages
- Cross-package error handling: since orbiter-core can't import ModelError from orbiter-models, check error attributes (e.g., `.code`) via `getattr()` on caught exceptions
- pyright ignore comments: put `# pyright: ignore[reportMissingImports]` on the import line itself (not a separate comment line) to avoid ruff I001 import sorting issues
---

## 2026-02-15 - US-001
- What was implemented: Message builder with build_messages, validate_message_order, extract_last_assistant_tool_calls, merge_usage. Initial commit of entire Orbiter framework infrastructure (Phases 1-4 + partial Phase 5).
- Files changed: packages/ (65 files — all package infrastructure, types, config, registry, events, hooks, tool, models, agent, message_builder, output_parser, and tests)
- **Learnings for future iterations:**
  - The codebase had pre-existing code from prior interactive sessions (Phases 1-4) that was never committed — this first commit captures everything
  - `list[SubType]` is not assignable to `list[BaseType]` in pyright due to list invariance — use `Sequence[BaseType]` for read-only function params
  - `test_agent.py` had RUF012 (mutable class default) and I001 (import sorting) lint errors that needed fixing
  - All 349 tests pass across orbiter-core (222) and orbiter-models (127)
---

## 2026-02-15 - US-002
- What was implemented: Output parser was already fully implemented and committed as part of the US-001 batch commit. Verified all acceptance criteria are met.
- Files: `packages/orbiter-core/src/orbiter/_internal/output_parser.py` (~155 lines), `packages/orbiter-core/tests/test_output_parser.py` (19 tests)
- Key functions: `parse_response()`, `parse_tool_arguments()`, `parse_structured_output()`, `OutputParseError`
- All quality checks pass: ruff check, ruff format, pyright (0 errors), pytest (349 tests)
- **Learnings for future iterations:**
  - US-001's initial commit included code for multiple user stories — check if the next story's code already exists before implementing
  - The PRD's `ParsedOutput` is implemented as `AgentOutput` in the actual code — the types module defines `AgentOutput` with text, tool_calls, usage fields
---

## 2026-02-15 - US-003
- What was implemented: Agent class was already mostly implemented from prior sessions. Added missing `memory` and `context` parameters to `Agent.__init__` (typed as `Any` since orbiter-context and orbiter-memory packages are not yet implemented). Updated test to assert defaults are `None`.
- Files changed: `packages/orbiter-core/src/orbiter/agent.py`, `packages/orbiter-core/tests/test_agent.py`
- **Learnings for future iterations:**
  - Agent class already had 21 tests covering: minimal/full creation, keyword-only enforcement, model parsing, tool/handoff registration with duplicate detection, hook integration, callable instructions, describe(), __repr__
  - `memory` and `context` params use `Any` type since their implementations are in future phases (orbiter-memory Phase 9, orbiter-context Phase 8)
  - Pattern: when PRD references types from future packages, use `Any` with `None` default as a forward-compatible placeholder
---

## 2026-02-15 - US-004
- What was implemented: `Agent.run()` async method with single-turn LLM execution and retry logic. Added `code` parameter to `ModelError` for error classification.
- Files changed: `packages/orbiter-core/src/orbiter/agent.py` (added ~85 lines for run() + _is_context_length_error()), `packages/orbiter-core/tests/test_agent.py` (added 15 tests in 3 new test classes), `packages/orbiter-models/src/orbiter/models/types.py` (added `code` param to ModelError)
- Key implementation details:
  - `run(input, *, messages, provider, max_retries=3)` wires message_builder → LLM call → output_parser
  - PRE_LLM_CALL / POST_LLM_CALL hooks fire at correct points
  - Retry with exponential backoff (2^attempt seconds): 1s, 2s, 4s...
  - Context-length errors (via `ModelError.code == "context_length"` or message text) fail immediately
  - Provider typed as `Any` since orbiter-core doesn't depend on orbiter-models
- **Learnings for future iterations:**
  - orbiter-core can't import from orbiter-models directly — use `Any` type for provider parameter and catch base exceptions
  - `_is_context_length_error()` checks both `.code` attribute and error message text for robustness
  - pyright inline ignore comments on import lines don't break ruff I001 sorting (put `# pyright: ignore[...]` on the same import line, not a separate comment line)
  - All 364 tests pass (15 new: 7 run tests, 4 retry tests, 4 hook tests)
---

## 2026-02-15 - US-005
- What was implemented: Tool execution loop in `Agent.run()` — when LLM returns tool calls, agent executes them in parallel, feeds results back, and re-calls LLM until text response or max_steps.
- Files changed: `packages/orbiter-core/src/orbiter/agent.py` (refactored run() into run() + _call_llm() + _execute_tools(), ~120 new lines), `packages/orbiter-core/tests/test_agent.py` (8 new tests in TestAgentToolLoop class)
- Key implementation details:
  - `run()` now has a `for _step in range(self.max_steps)` loop around `_call_llm()`
  - `_call_llm()` extracted from old `run()` — single LLM call with retry logic and hooks
  - `_execute_tools()` uses `asyncio.TaskGroup` for parallel tool execution
  - Tool errors caught per-tool and returned as `ToolResult(error=...)`, not propagated
  - Unknown tools return `ToolResult(error="Unknown tool '...'")`
  - PRE_TOOL_CALL / POST_TOOL_CALL hooks fire for each tool
  - `parse_tool_arguments()` from output_parser converts ToolCall JSON args to ActionModel
  - Updated existing test `test_run_with_tool_calls_in_response` to account for the tool loop (provider now needs to return text on second call)
- **Learnings for future iterations:**
  - When adding tool loop, existing tests that mock a single tool-call response break because the agent now tries to execute the tool and re-call. Update mocks to return text on the follow-up call.
  - `asyncio.TaskGroup` requires Python 3.11+ — already satisfied by this project
  - The placeholder list pattern `[ToolResult(...)] * len(actions)` creates shared references — must assign by index in the async task, not append
  - All 372 tests pass (8 new tool loop tests)
---

## 2026-02-15 - US-006
- What was implemented: 8 new edge case tests in `TestAgentEdgeCases` class covering: retry during tool loop, agent with handoffs runs normally, handoffs don't appear as tools, sequential tool calls accumulate messages, max_steps=1, empty input, usage from final response, tool with no arguments.
- Files changed: `packages/orbiter-core/tests/test_agent.py` (+161 lines)
- **Learnings for future iterations:**
  - Most edge cases were already covered by earlier test classes (TestAgentToolLoop had 8 tests for the core scenarios)
  - The key gap was retry behavior mid-tool-loop and handoff interaction — these are important to test because they exercise separate code paths in the agent
  - 52 agent tests total across 9 test classes, 380 tests across the full suite
---

## 2026-02-15 - US-007
- What was implemented: Human-in-the-loop tool with `HumanInputHandler` ABC, `ConsoleHandler` (stdin-based), and `HumanInputTool` (Tool subclass with timeout support).
- Files changed: `packages/orbiter-core/src/orbiter/human.py` (~120 lines), `packages/orbiter-core/tests/test_human.py` (21 tests in 4 classes)
- Key implementation details:
  - `HumanInputHandler` ABC with `async get_input(prompt, choices)` — extensible to console, web, Slack, etc.
  - `ConsoleHandler` — reads from stdin via `asyncio.to_thread()`, validates choices, defaults to first choice on invalid input
  - `HumanInputTool` — `Tool` subclass with manually defined JSON schema (prompt required, choices optional array)
  - Timeout via `asyncio.wait_for()` — raises `ToolError` on timeout
  - Tests use `MockHandler` and `SlowHandler` fixtures, plus `monkeypatch` for `ConsoleHandler._read_line`
- **Learnings for future iterations:**
  - `HumanInputTool` manually defines its JSON schema rather than using `_generate_schema()` since it's not a FunctionTool wrapper — this is the pattern for custom Tool subclasses
  - `asyncio.wait_for()` raises `TimeoutError` (Python 3.11+) — catch that and convert to `ToolError` for consistent error handling
  - 401 tests total across full suite (21 new)
---

## 2026-02-15 - US-008
- What was implemented: Run state tracking with `RunNodeStatus` (StrEnum: INIT, RUNNING, SUCCESS, FAILED, TIMEOUT), `RunNode` (Pydantic model with lifecycle transitions: start/succeed/fail/timeout, timing, usage, metadata), and `RunState` (mutable execution tracker with message accumulation, node management, usage aggregation, terminal state detection).
- Files changed: `packages/orbiter-core/src/orbiter/_internal/state.py` (~145 lines), `packages/orbiter-core/tests/test_state.py` (29 tests in 3 classes)
- **Learnings for future iterations:**
  - Use `StrEnum` instead of `str, Enum` — ruff UP042 enforces this pattern
  - `Sequence[Message]` still needed for function params that accept `list[SubType]` — pyright invariance on `list[T]`
  - `RunNode` uses mutable Pydantic model (no `frozen=True`) since state transitions mutate fields — this is the right pattern for stateful objects vs. value objects
  - 430 tests total across full suite (29 new)
---

## 2026-02-15 - US-009
- What was implemented: Core call runner (`call_runner()`) that orchestrates Agent.run() with RunState tracking, node lifecycle management, usage accumulation, and endless loop detection via tool-call signature comparison.
- Files changed: `packages/orbiter-core/src/orbiter/_internal/call_runner.py` (~145 lines), `packages/orbiter-core/tests/test_call_runner.py` (15 tests in 6 classes)
- Key implementation details:
  - `call_runner(agent, input, *, state, messages, provider, max_retries, loop_threshold)` — wraps Agent.run() in RunState lifecycle
  - Creates RunNode per call, tracks INIT → RUNNING → SUCCESS/FAILED transitions
  - Loop detection: `_tool_call_signature()` creates deterministic string from sorted tool name:args pairs; `_check_loop()` counts consecutive matching signatures in node metadata
  - Errors from Agent.run() wrapped in `CallRunnerError`, state/node marked FAILED
  - Agent.instructions resolved via callable check + str() for pyright compatibility (agent param typed as Any)
  - Returns `RunResult` with output text, accumulated messages, total usage, step count
- **Learnings for future iterations:**
  - Since `agent` is typed as `Any` in call_runner, accessing `agent.instructions` returns `object | Any` — must use `str()` cast or explicit type narrowing, not direct assignment to `str` variable
  - Loop detection works across consecutive `call_runner()` invocations with shared state by storing tool signatures in `RunNode.metadata`
  - The call_runner delegates the actual LLM→tool→LLM loop entirely to Agent.run() — it's a thin orchestration layer for state tracking, not a replacement for Agent's internal loop
  - 445 tests total across full suite (15 new)
---

## 2026-02-15 - US-010
- What was implemented: Public `run()` async entry point and `run.sync()` blocking wrapper as the primary API for executing agents. Auto-provider resolution via orbiter.models registry when available.
- Files changed: `packages/orbiter-core/src/orbiter/runner.py` (~100 lines), `packages/orbiter-core/tests/test_runner.py` (13 tests in 5 classes)
- Key implementation details:
  - `run(agent, input, *, messages, provider, max_retries, loop_threshold) -> RunResult` — async, delegates to `call_runner()`
  - `run.sync(...)` — attached as attribute on `run` function, uses `asyncio.run()` internally
  - `_resolve_provider(agent)` — tries `orbiter.models.provider.get_provider()` with graceful fallback to `None`
  - Provider typed as `Any` since orbiter-core doesn't depend on orbiter-models
- **Learnings for future iterations:**
  - Python functions are objects — you can attach attributes like `run.sync = _sync` with `# type: ignore[attr-defined]` for pyright
  - `asyncio.run()` creates a new event loop, so `run.sync()` can't be called from within an existing async context — this is the expected behavior
  - Auto-provider resolution uses try/except to gracefully handle missing orbiter-models package
  - 458 tests total across full suite (13 new)
---

## 2026-02-15 - US-011
- What was implemented: `run.stream()` async generator attached to the `run` function, yielding `TextEvent` for text deltas and `ToolCallEvent` for tool invocations. Supports full tool execution loop with re-streaming after tool results.
- Files changed: `packages/orbiter-core/src/orbiter/runner.py` (added `_stream()` ~110 lines), `packages/orbiter-core/tests/test_runner.py` (added 10 tests in 3 new test classes + streaming helpers)
- Key implementation details:
  - `run.stream(agent, input, ...)` uses `provider.stream()` for chunk-by-chunk text delivery
  - Tool call deltas accumulated from `StreamChunk.tool_call_deltas` by index, then assembled into `ToolCall` objects
  - After tool calls: executes tools via `agent._execute_tools()`, appends results to conversation, re-streams
  - Loop continues until text-only response or `max_steps` reached
  - Error in no-provider case raises `AgentError` immediately
- **Learnings for future iterations:**
  - `_resolve_provider` passes `agent.provider_name` to `get_provider()`, which calls `parse_model_string()` again — a bare name like "nonexistent" gets parsed as `("openai", "nonexistent")` and resolves to OpenAI provider. To test no-provider scenarios, monkeypatch `_resolve_provider` to return `None`
  - Same pyright issue with `agent.instructions` returning `object | Any` — use `str()` cast pattern (instr/raw_instr) consistent with call_runner.py
  - Streaming doesn't use `call_runner()` or `Agent.run()` — it operates at a lower level, directly calling `provider.stream()` and managing the tool loop itself. This is by design for real-time event delivery
  - 468 tests total across full suite (10 new streaming tests)
---

## 2026-02-15 - US-012
- What was implemented: Handler system with `Handler[IN, OUT]` ABC (generic async generator base), `AgentHandler` (routes between agents in swarms), `SwarmMode` enum (workflow/handoff/team), handoff detection, and topology-aware stop checks.
- Files changed: `packages/orbiter-core/src/orbiter/_internal/handlers.py` (~130 lines), `packages/orbiter-core/tests/test_handlers.py` (28 tests in 7 classes)
- Key implementation details:
  - `Handler[IN, OUT]` is a generic ABC with abstract `handle(input) -> AsyncIterator[OUT]` — non-async def returning AsyncIterator avoids pyright type issues with abstract async generators
  - `AgentHandler` implements workflow (sequential, output→input chaining), handoff (follow handoff chains with max_handoffs guard), and team (run lead agent) modes
  - Handoff detection: exact match of `result.output.strip()` against agent's handoff target names, with additional check that the target exists in the swarm's agents dict
  - Stop checks are separate methods (`_check_workflow_stop`, `_check_handoff_stop`, `_check_team_stop`) for composability
  - Delegates actual agent execution to `call_runner()` from the existing call_runner module
- **Learnings for future iterations:**
  - Abstract async generator methods in ABCs: use `def handle(...) -> AsyncIterator[T]` (not `async def`) to avoid pyright issues with `yield` in abstract methods yielding `None` instead of `T`
  - Handoff cycle test: when testing A→B→A→B cycles, the mock provider must alternate responses ("b", "a", "b", "a") since each agent checks handoff targets against its own handoffs dict
  - The handler system is the bridge between the runner layer (run/call_runner) and the swarm layer (US-017+). AgentHandler will be used by Swarm to orchestrate multi-agent execution
  - 496 tests total across full suite (28 new handler tests)
---

## 2026-02-15 - US-013
- What was implemented: ToolHandler (dynamic tool loading, parallel execution via asyncio.TaskGroup, result aggregation) and GroupHandler (parallel and serial agent group execution with dependency resolution via Kahn's topological sort).
- Files changed: `packages/orbiter-core/src/orbiter/_internal/handlers.py` (added ~130 lines for ToolHandler + GroupHandler), `packages/orbiter-core/tests/test_handlers.py` (added 23 tests in 6 new test classes)
- Key implementation details:
  - `ToolHandler` — receives dict of `{tool_call_id: {"name": str, "arguments": dict}}`, resolves tools from registry, executes in parallel, yields `ToolResult` objects. Also has `register()`, `register_many()`, `aggregate()` methods
  - `GroupHandler` — `parallel=True` runs all agents concurrently (same input, TaskGroup), `parallel=False` runs serially with output→input chaining and dependency resolution
  - `_resolve_order()` implements Kahn's algorithm for topological sort with cycle detection — raises `HandlerError` on cyclic dependencies
  - Both handlers follow the `Handler[IN, OUT]` ABC pattern from US-012
- **Learnings for future iterations:**
  - When testing with `_make_provider`, response count must match total LLM calls across all agents — each `call_runner()` invocation triggers at least one `provider.complete()` call
  - Custom mock providers in tests need to return objects with `content`, `tool_calls`, and `usage` attributes matching what `parse_response()` expects — `usage=None` will fail
  - To test "missing agent" in serial mode, either override `_resolve_order()` in a subclass or manipulate the agents dict after construction (since `_resolve_order` only includes keys from `self.agents`)
  - 519 tests total across full suite (23 new handler tests)
---
