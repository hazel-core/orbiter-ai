# Ralph Progress Log
Started: Thu Feb 19 11:52:28 PM IST 2026
---

## 2026-02-20 - US-012
- Added `AgentMemory` dataclass to `orbiter-memory/src/orbiter/memory/base.py` with fields `short_term: MemoryStore` and `long_term: MemoryStore`; also imported `dataclass` and `field` from `dataclasses`
- Extended `MemoryStore` Protocol's `search()` from abstract (`...`) to a concrete default implementation that filters `self._items` by keyword, memory_type, status, and metadata fields
- Made `MemoryPersistence.attach()` idempotent: added `_attached_agent_ids: set[int]` tracking; second call for same agent object returns early; `detach()` removes agent from set via `discard()`
- Exported `AgentMemory` from `orbiter-memory/src/orbiter/memory/__init__.py` (import + `__all__` entry)
- Added `TestMemoryStoreDefaultSearch` (5 tests) and `TestAgentMemory` (4 tests) to `test_memory_base.py`
- Added `test_attach_idempotent` and `test_attach_idempotent_different_agents` to `test_memory_persistence.py::TestAttachDetach`
- Files changed:
  - packages/orbiter-memory/src/orbiter/memory/base.py
  - packages/orbiter-memory/src/orbiter/memory/persistence.py
  - packages/orbiter-memory/src/orbiter/memory/__init__.py
  - packages/orbiter-memory/tests/test_memory_base.py
  - packages/orbiter-memory/tests/test_memory_persistence.py
- All 299 orbiter-memory tests pass (6 skipped); 0 new type errors in modified source files
- **Learnings for future iterations:**
  - `MemoryStore` is a `@runtime_checkable Protocol`; concrete default methods in the Protocol body work but only apply when a class INHERITS from the Protocol (not structural subtypes)
  - To test the Protocol's default `search` from a structural subtype, call `MemoryStore.search(self, ...)` directly
  - `MemoryPersistence._attached_agent_ids` uses `id(agent)` (Python object identity); call `discard()` in `detach()` to avoid KeyError
  - `AgentMemory` uses `@dataclass` (not Pydantic) because `MemoryStore` is a Protocol (not a serializable type), and dataclass field ordering is straightforward
  - `ShortTermMemory.__slots__` is set, which means it can't be used as a keyword argument in `AgentMemory(short_term=X)` directly — but since `AgentMemory` is a `@dataclass`, positional OR keyword args both work fine
---

## 2026-02-20 - US-011
- orbiter-web/engine.py: added `import time`; removed `import contextlib` (no longer needed); added `_log.info("Workflow %s starting: ...")` at top of `execute_workflow()`; added `_log.debug("Executing node %s (type=%s)", ...)` before each node task creation; added `node_start_times` dict + `elapsed_ms` tracking per node; added `_log.info("Node %s completed in %.1fms", ...)` after task result; added `_log.error("Node %s failed: %s", ..., exc_info=True)` in exception handler; replaced all 5 `contextlib.suppress(Exception)` usages in emit() functions with `try/except + _log.warning("WebSocket send failed: %s", exc)` (fixes audit B-16)
- orbiter-web/services/agent_runtime.py: added `import logging` + `_log = logging.getLogger(__name__)`; added `_log.info("run_agent start: ...")` and `_log.error(..., exc_info=True)` on failure; added `_log.debug("run_agent tool calls: ...")` when tool_calls present; added `_log.info("stream_agent start: ...")` and `_log.error(..., exc_info=True)` on failure
- orbiter-web/services/scheduler.py: added `_log.debug("Next run for schedule %s: %s", ...)` after computing next_run
- orbiter-web/services/memory.py: added `import logging` + `_log = logging.getLogger(__name__)`; added `_log.debug("get_memory: agent=%s thread=%s type=%s", ...)` at start of get_memory()
- orbiter-web/services/sandbox.py: added `import logging` + `_log = logging.getLogger(__name__)`; added `_log.debug("execute_code: code_len=%d timeout=%ds", ...)` at start of execute_code(); added `_log.warning("execute_code: timed out after %ds", ...)` in TimeoutExpired handler
- Files changed: 5 files across orbiter-web package
- All 29 orbiter-web tests pass; 0 new type errors in modified files (pre-existing errors in orbiter-web are unrelated)
- **Learnings for future iterations:**
  - engine.py uses `contextlib.suppress(Exception)` for all 4 emit() functions + 1 inline event_callback call — all 5 replaced simultaneously
  - After removing all contextlib.suppress usages, `import contextlib` became unused and was removed
  - Track per-node start times with `node_start_times: dict[str, float]` before creating asyncio.Tasks; access in the gather loop
  - agent_runtime.py had no logging at all — needed full import + logger setup
  - scheduler.py already had good logging; only needed `logger.debug next_run` addition
---

## 2026-02-20 - US-010
- orbiter-eval/ralph/runner.py: added `import logging` + `logger`; added `logger.info` at start of `run()` with input_len/scorers count; replaced bare `except: pass` in `_analyze()` with `logger.warning("Scorer failed case=%s: %s", case_id, exc, exc_info=True)` (fixes audit C-10)
- orbiter-eval/trajectory_scorers.py: added `import logging` + `logger`; added `logger.debug` per-case score in `TrajectoryValidator.score()` and `TimeCostScorer.score()`
- orbiter-sandbox/base.py: already had logging; added `logger.info("Sandbox %s: starting/stopping", ...)` in `LocalSandbox.start()` and `stop()` (debug was on `_transition()` only)
- orbiter-sandbox/tools.py: already had logging; added `logger.warning("TerminalTool: blocked command %r", base)` before raising ToolError in `_check_command()`
- orbiter-server/app.py: added `import logging` + `logger`; added `serve(host, port)` function that calls `logger.info("Starting Orbiter Server on %s:%d", ...)` before uvicorn.run(); exported from `__init__.py`
- orbiter-train/train/verl.py: already had logging; added `logger.warning("VeRLTrainer.train: STUB — no real training performed")` in `_run_verl_training()` (flags C-3)
- orbiter-train/train/evolution.py: added `import logging` + `logger`; added `logger.info("Evolution epoch %d/%d starting/complete: ...")` per epoch + `logger.debug("Best epoch so far: ...")` after each epoch
- Files changed: 8 files across 4 packages
- All 705 tests pass (608 eval/sandbox/train + 97 server); 0 new type errors
- **Learnings for future iterations:**
  - orbiter-sandbox/base.py and tools.py already had full logging infrastructure — only needed targeted additions
  - orbiter-eval has two runner files: `ralph/runner.py` (RalphRunner iteration loop) and no top-level runner.py; the "runner.py" in US-010 refers to ralph/runner.py
  - orbiter-server has no `__main__.py` or CLI entry point; the "entry point" logging was added as a `serve()` helper function in app.py
  - orbiter-train/verl.py already had extensive logging from prior work; only needed the STUB warning
  - EvolutionPipeline epoch_idx is 0-based; log as epoch_idx+1 for human readability
---

## Codebase Patterns
- orbiter-web tests are in packages/orbiter-web/tests/ (not src/)
- subprocess.run(text=True) applies universal newline translation (\r → \n), so don't assert literal \r in captured stdout
- pyright has ~170 pre-existing errors in orbiter-web; check only modified files for new errors
- Use repr() (not json.dumps()) for embedding arbitrary strings in Python source code literals
- Route handlers that do `from module import func` inside the function body: patch at the source module (e.g., `orbiter_web.engine.execute_workflow`), not at the router module
- Use `starlette.testclient.TestClient` with a minimal FastAPI app for synchronous HTTP-level route tests; no pytest-asyncio marks needed
- `_make_get_db(*rows)` pattern: create an `@asynccontextmanager` that yields a mock db and returns rows sequentially for each `db.execute()` call
- orbiter-observability env-var config: expose `_configure_from_env()` as a callable so tests can use `monkeypatch.setenv()` + `reset_logging()` + `_configure_from_env()` to test env-var behavior without reimporting the module

---

## 2026-02-20 - US-009
- Added `import logging` and `logger = logging.getLogger(__name__)` to orbiter-a2a/server.py and client.py
- orbiter-a2a/server.py: added logger.info at run start and complete in execute_task() and _generate() stream, logger.error with exc_info=True on failure in both
- orbiter-a2a/client.py: added logger.debug in RemoteAgent.run() and RemoteAgent.describe()
- orbiter-cli/main.py: added `import logging` and logger; added logger.debug('CLI command=%s args=%r') at start of run, start_worker, task_status, task_cancel, task_list, worker_list
- orbiter-distributed/client.py: upgraded TaskHandle.result() completed path from logger.debug to logger.info (task result received)
- orbiter-distributed/worker.py: added exc_info=True to the _execute_task error log
- orbiter-distributed/broker.py: already had full logger.debug on enqueue (submit) and dequeue (claim) — no changes needed
- Files changed:
  - packages/orbiter-a2a/src/orbiter/a2a/server.py
  - packages/orbiter-a2a/src/orbiter/a2a/client.py
  - packages/orbiter-cli/src/orbiter_cli/main.py
  - packages/orbiter-distributed/src/orbiter/distributed/client.py
  - packages/orbiter-distributed/src/orbiter/distributed/worker.py
- All 373 orbiter-a2a + orbiter-distributed tests pass; 267 orbiter-cli tests pass; 0 new type errors
- **Learnings for future iterations:**
  - orbiter-distributed/broker.py, client.py, and worker.py already had extensive logging — only client.py "received" and worker.py exc_info needed updating
  - orbiter-a2a files had no logging at all — needed full import + logger setup
  - orbiter-cli commands are Typer decorated functions — logger.debug at top of each command body works fine
---

## 2026-02-20 - US-008
- Updated orbiter-context/config.py: changed make_config() log to include history_rounds: `ContextConfig created mode=%s history_rounds=%d`
- Updated orbiter-context/processor.py: changed fire() log to `Processing context with %d neurons`; updated ToolResultOffloader log to `ToolResultOffloader: offloading tool=%s size=%d bytes`
- Updated orbiter-context/token_tracker.py: added `TokenTracker: used=%d / total=%d (%.0f%%)` log after each add_step() call
- Updated orbiter-context/workspace.py: changed write() logs to `Artifact stored: id=%s size=%d bytes`; added read() log `Artifact retrieved: id=%s`
- Updated orbiter-memory/summary.py: changed check_trigger() logs from debug to info with format `Summarization triggered: threshold=%d messages=%d`; changed generate_summary() log to `Summary generated length=%d`
- Updated orbiter-memory/long_term.py: changed submit() log from debug to info: `long-term extraction triggered: items=%d types=%d`
- Files changed:
  - packages/orbiter-context/src/orbiter/context/config.py
  - packages/orbiter-context/src/orbiter/context/processor.py
  - packages/orbiter-context/src/orbiter/context/token_tracker.py
  - packages/orbiter-context/src/orbiter/context/workspace.py
  - packages/orbiter-memory/src/orbiter/memory/summary.py
  - packages/orbiter-memory/src/orbiter/memory/long_term.py
- All 731 tests pass (6 skipped); 0 new type errors in modified files
- **Learnings for future iterations:**
  - Most orbiter-context and orbiter-memory files already had `import logging` and `logger = logging.getLogger(__name__)` — only log message content/level needed updating
  - `orbiter-context/summary.py` does NOT exist — summary logic is in `orbiter-memory/summary.py`
  - The pre-existing sqlite.py type error (`len(rows)` on `Iterable[Row]`) is unrelated to logging changes; ignore for this story
  - "neurons" in processor.py context refers to the count of registered processors for the event
  - TokenTracker: used=%d is per-agent accumulated, total=%d is all-agent accumulated
---

## 2026-02-20 - US-007
- Added `import os` and `_ENV_FORMAT = '%(asctime)s %(levelname)-8s %(name)s  %(message)s'` to `logging.py`
- Added `_configure_from_env()` function that reads `ORBITER_DEBUG` and `ORBITER_LOG_LEVEL` env vars, sets root `orbiter` logger level, and adds a handler with the standard format when env vars are present
- Called `_configure_from_env()` at module import time so env vars take effect before any explicit `configure_logging()` call
- Added 12 new tests in `TestConfigureFromEnv` covering: DEBUG level, INFO/ERROR level, ORBITER_DEBUG precedence, invalid level fallback, no-env-vars case, handler format, idempotency, child logger inheritance, case-insensitive level
- Files changed:
  - packages/orbiter-observability/src/orbiter/observability/logging.py (added os import, _ENV_FORMAT, _VALID_ENV_LEVELS, _configure_from_env(), module-level call)
  - packages/orbiter-observability/tests/test_obs_logging.py (added _ENV_FORMAT and _configure_from_env imports, added TestConfigureFromEnv class)
- **Learnings for future iterations:**
  - To test env-var-driven module-level behavior without reimporting: expose the apply function as `_configure_from_env()`, call it after `reset_logging()` + `monkeypatch.setenv()` in tests
  - `_configured` global flag prevents double-handler-addition; `reset_logging()` clears it, so tests can re-trigger `_configure_from_env()` for each test case
  - `logger.getEffectiveLevel()` on a child logger returns the inherited level from the root (correct for testing propagation)
---

## 2026-02-20 - US-006
- Updated all 3 call sites that resolve callable instructions to use `asyncio.iscoroutinefunction(raw_instr)` instead of calling and checking `asyncio.iscoroutine(result)`
- Files changed:
  - packages/orbiter-core/src/orbiter/agent.py (agent.run(): changed to iscoroutinefunction pattern; updated instructions type annotation from `Callable[..., str]` to `Callable[..., Any]`)
  - packages/orbiter-core/src/orbiter/runner.py (stream() resolver: changed to iscoroutinefunction pattern)
  - packages/orbiter-core/src/orbiter/_internal/call_runner.py (call_runner result messages resolver: changed to iscoroutinefunction pattern)
  - packages/orbiter-core/tests/test_agent.py (added test_async_callable_instructions)
- **Learnings for future iterations:**
  - `asyncio.iscoroutinefunction(fn)` checks the function itself before calling it — cleaner than calling and checking `asyncio.iscoroutine(result)`; both work but the latter unnecessarily calls async functions in a fire-and-forget way
  - Agent `instructions` type annotation must be `Callable[..., Any]` (not `Callable[..., str]`) to accept async callables returning `Coroutine[Any, Any, str]`
  - There are 3 call sites for instruction resolution: agent.py `run()`, runner.py `stream()`, and _internal/call_runner.py result message building
---

## 2026-02-19 - US-002
- In `_validate_startup()` in `app.py`: added RuntimeError when `debug=False` and `secret_key == 'change-me-in-production'`; kept warning log when in debug mode
- Added inline comment to `config.py` on the `secret_key` field: `# Override via ORBITER_SECRET_KEY — MUST change in production`
- Files changed:
  - packages/orbiter-web/src/orbiter_web/app.py (_validate_startup: warning → RuntimeError in production)
  - packages/orbiter-web/src/orbiter_web/config.py (added inline comment on secret_key)
  - packages/orbiter-web/tests/test_startup.py (new file with 3 tests)
- **Learnings for future iterations:**
  - `_validate_startup()` is called from `lifespan()` at startup — mocking `settings` and `_DB_PATH` is the cleanest way to test it
  - The `or not settings.secret_key` branch was split out so empty-key stays as warning while default-key raises in production
  - `patch("orbiter_web.app.settings")` patches the settings object used inside app.py (not the one imported at test time)
---

## 2026-02-20 - US-003
- Added `hmac.compare_digest()` token validation to `trigger_webhook()` in `routes/webhooks.py`
- Added `url_token: str | None = Query(default=None)` parameter to the handler
- Token check runs after 404 check but before enabled check; returns 403 with `{"detail": "Invalid token"}` on mismatch or missing token
- Created `packages/orbiter-web/tests/test_webhooks.py` with 3 tests: missing token → 403, wrong token → 403, correct token → 200
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/webhooks.py (added `import hmac`, `url_token` param, validation block)
  - packages/orbiter-web/tests/test_webhooks.py (new file)
- **Learnings for future iterations:**
  - `can_start_run` and `execute_workflow` are imported inside the function body in `trigger_webhook` — patch at source (`orbiter_web.services.run_queue.can_start_run`, `orbiter_web.engine.execute_workflow`)
  - `starlette.testclient.TestClient` with a minimal FastAPI app handles async route handlers synchronously — no asyncio setup needed
  - `_append_request_log` makes additional `get_db()` calls that need to be included in the mock row sequence
---

## 2026-02-20 - US-004
- Removed the log line that emitted the raw password reset token (`logger.info("Password reset token for %s: %s", body.email, token)`) from `forgot_password()` in `routes/auth.py:389`
- Replaced with `logger.debug("Password reset email sent to %s", body.email)` — email only, no token
- Grepped entire orbiter-web package for other logger calls emitting tokens, session IDs, or raw credentials — no others found
- Created `packages/orbiter-web/tests/test_auth_reset.py` with 2 tests: token absent from logs, email present in debug log
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (line 388-389: remove token log, add email-only debug)
  - packages/orbiter-web/tests/test_auth_reset.py (new file)
- **Learnings for future iterations:**
  - `caplog.at_level(logging.DEBUG, logger="orbiter_web")` captures debug logs for the `orbiter_web` logger in tests
  - Use `re.compile(UUID_PATTERN).search(record.message)` to assert no UUID token appears in any log record
  - The `forgot_password` route makes 2 `get_db()` calls: SELECT user by email, then INSERT password_resets
---

## 2026-02-20 - US-005
- Rewrote `AgentService.stream_agent()` in `orbiter-web/services/agent_runtime.py` to use `orbiter_run.stream()` (from `orbiter.runner`) instead of calling `provider.stream()` directly
- The full agent tool loop now runs during streaming: LLM tool calls are executed and results fed back before re-streaming
- Added `from orbiter.runner import run as orbiter_run` and `TextEvent, Usage, UsageEvent` imports at module level
- Yields `StreamChunk` objects for backward compat: `TextEvent` → `StreamChunk(delta=...)`, final chunk has `finish_reason="stop"` + accumulated usage
- Updated `test_stream_agent` to mock `orbiter_run.stream` via `patch("orbiter_web.services.agent_runtime.orbiter_run", mock_run)`
- Added `test_stream_agent_executes_tools`: real Agent with a real tool + mock provider that first returns tool_call_deltas, then text; asserts tool was invoked
- Files changed:
  - packages/orbiter-web/src/orbiter_web/services/agent_runtime.py (stream_agent rewrite + new imports)
  - packages/orbiter-web/tests/test_agent_runtime.py (updated test_stream_agent, added test_stream_agent_executes_tools)
- **Learnings for future iterations:**
  - `orbiter.runner.run.stream` is the high-level streaming API; it handles tool loop, hooks, and event emission
  - Patch `orbiter_web.services.agent_runtime.orbiter_run` to mock `run.stream` in tests (it's imported as `orbiter_run` at module level)
  - `run.stream(detailed=True)` emits `UsageEvent` — without `detailed=True`, no usage is available
  - `StreamChunk(tool_call_deltas=[...])` chunks accumulate in `_stream()`; absence of `tc_acc` entries means no tool loop iteration
---

## 2026-02-19 - US-001
- Replaced manual `.replace()`-based escaping in `_build_runner_script()` with `repr()` serialization of the user code string
- The repr() approach handles \r, \t, \0, null bytes, \u0041, embedded triple-quotes, and any other special characters safely
- Files changed:
  - packages/orbiter-web/src/orbiter_web/services/sandbox.py (line 87: escaped_code → code_repr = repr(code); line 152: f-string uses {code_repr})
  - packages/orbiter-web/tests/test_sandbox.py (new file with 6 tests)
- **Learnings for future iterations:**
  - The old code used single-quote embedding `_user_code = '{escaped_code}'` which was vulnerable to any char that breaks out of single-quote context
  - repr() produces a valid Python literal for any string (uses b-prefix or escape sequences as needed)
  - subprocess.run(text=True) normalizes \r to \n — don't test for literal \r in captured stdout
---
