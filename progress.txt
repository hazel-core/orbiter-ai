# Ralph Progress Log
Started: Mon Feb 16 08:13:35 PM IST 2026
---

## Codebase Patterns
- Node error handling: `_get_node_error_config(node)` reads retry_count, retry_delay_ms, on_error, fallback_value, timeout_ms from `node.data`; `_execute_node_with_retry()` wraps `_execute_node` with timeout + exponential backoff + on_error strategy
- Schedules: CRUD at `/api/schedules`, background polling in `services/scheduler.py` using `croniter`; fires workflow runs with `trigger_type='schedule'`; starts/stops via app lifespan
- Sandbox execution: `execute_code(code, config)` in `services/sandbox.py` — runs Python in isolated subprocess with import allowlist, filesystem restriction, and timeout; returns SandboxResult with stdout/stderr/files
- Sandbox import restriction: don't block exec/eval/compile from builtins (breaks importlib); use explicit import allowlist + safe stdlib set instead
- Built-in tools: add to `BUILTIN_TOOLS` list in `routes/tools.py` — they get merged into list_tools endpoint automatically
- Tool schemas for playground: `_resolve_agent_tool_schemas()` in playground.py builds OpenAI-format schemas from agent's tools_json; pass to `_run_stream()` via `tools` param
- Sandbox result events: `sandbox_result` WebSocket event carries `success, stdout, stderr, error, generated_files, execution_time_ms`; frontend renders images inline via base64 data URIs
- File uploads: use `handle_upload(file, allowed_types, max_size_mb)` from `orbiter_web/upload.py`; returns `UploadResult` with path, metadata; use `cleanup_upload(path)` on processing failure
- Pagination: list endpoints return `{data: [...], pagination: {next_cursor, has_more, total}}`; use `paginate()` from `orbiter_web/pagination.py`; frontend extracts `.data` via `.then(body => body.data || body)`
- CSRF: window.fetch is monkey-patched in PageLayout to auto-include X-CSRF-Token on POST/PUT/DELETE; no need to manually add headers in page scripts
- CSRF exempt paths are in `middleware/csrf.py` `_EXEMPT_PATHS` — add new exempt routes there when needed
- orbiter-web is a Node.js (Astro 5.x) package inside a UV Python workspace — it has its own package.json, not pyproject.toml for the frontend
- Astro 5.x defaults to strict TypeScript; extend `astro/tsconfigs/strict` in tsconfig.json
- Tailwind CSS v4 must be integrated via `@tailwindcss/vite`, NOT `@astrojs/tailwind`
- Astro typecheck: run `npx astro check` from the orbiter-web directory
- `.gitignore` in orbiter-web excludes `node_modules/`, `dist/`, `.astro/`
- Fonts: Bricolage Grotesque via @fontsource imports, Junicode via woff2 in `public/fonts/`; use `font-junicode` utility class for display headings
- cn() utility at `src/utils/merge.ts` — import via `import { cn } from "../utils/merge"` for class merging in components
- All pages should use `<BaseLayout>` wrapper — it provides theme detection, global styles, and animation support
- Use `is:inline` for Astro scripts that must block rendering (e.g., theme detection to prevent flash)
- Use `data-animate="zenReveal|zenFade|zenScale"` on elements for scroll-triggered animations
- Proxy API requests in dev: configure `vite.server.proxy` in astro.config.mjs (NOT Astro-specific proxy)
- Use `uv run` prefix in npm scripts that need the Python venv (e.g., `uv run uvicorn ...`)
- PageLayout.astro is the app shell with sidebar — use `activeSection` prop to highlight current nav item (e.g., `<PageLayout activeSection="projects">`)
- Inline SVG icons: store as HTML strings in frontmatter, render with `set:html` directive — no icon library needed
- orbiter-web has BOTH package.json (Astro frontend) AND pyproject.toml (FastAPI backend) — it's a dual Node+Python package
- PageLayout accepts `breadcrumbs` (array of {label, href}), `projectName`, and `activeSection` props
- Mobile breakpoint: `< md` uses bottom tab bar + hamburger slide-out; `md+` uses sidebar; `lg+` sidebar is expandable
- FastAPI app entry point: `orbiter_web.app:app` — run with `uvicorn orbiter_web.app:app`
- Settings via dataclass in `orbiter_web/config.py` — reads ORBITER_DATABASE_URL, ORBITER_SECRET_KEY, ORBITER_DEBUG env vars
- When adding a new Python package to UV workspace: update `members`, `dependency-groups.dev`, and `tool.uv.sources` in root pyproject.toml
- Database: `get_db()` async context manager in `orbiter_web/database.py` — sets WAL mode, foreign keys, Row factory
- Migrations: sequential .sql files in `orbiter_web/migrations/`, tracked in `_migrations` table; run automatically on app startup via FastAPI lifespan
- FastAPI lifespan: use `@asynccontextmanager` that yields once (replaces deprecated `on_event("startup")`)
- Routes: use `APIRouter(prefix="/api/...", tags=["..."])` in `routes/<module>.py`, register with `app.include_router()` in app.py
- Pydantic models: use `BaseModel` for request/response schemas, `Field(min_length=...)` for validation
- Row conversion: `dict(row)` converts `aiosqlite.Row` to a plain dict for Pydantic serialization
- Placeholder auth: `_DEFAULT_USER_ID = "default-user"` until US-018 is implemented — all queries filter by user_id
- Ruff: use `datetime.UTC` not `timezone.utc`, use `[*list(...), item]` instead of `list(...) + [item]`
- Dynamic routes: `[param].astro` files in `src/pages/` — access via `Astro.params.param`; use `define:vars={{ var }}` to pass to `is:inline` scripts
- Client-side data fetching: use `<template>` + `cloneNode(true)` for card rendering from API data; better than innerHTML string building
- Modal integration: reuse `Modal.astro` component, open with `.showModal()`, `data-modal-close` handles closing automatically
- App pages use `PageLayout` (not `BaseLayout`) for sidebar + top bar + breadcrumbs
- Ruff B008: use `# noqa: B008` for FastAPI `Depends()` in function defaults — it's the standard DI pattern
- Auth redirect lives in PageLayout — all app pages are protected automatically; standalone pages (login) use BaseLayout directly
- Login page uses BaseLayout, not PageLayout, since it doesn't need sidebar/topbar chrome
- Auth middleware: `get_current_user` from `routes/auth.py` is a FastAPI `Depends()` — use in any protected route
- API keys: encrypt with `encrypt_api_key()` on write, use `api_key_set: bool` in response models — never expose encrypted or plaintext keys in API responses
- Provider test endpoint: use httpx AsyncClient for lightweight API calls; lazy-import httpx to avoid overhead on CRUD routes
- Provider keys: multiple keys per provider in `provider_keys` table; load balance strategy on `providers.load_balance_strategy`
- Key selection: POST `/api/providers/:id/keys/select` returns decrypted key based on strategy; report usage via POST `/api/providers/:id/keys/:keyId/report`
- Applications: 5 types (chatbot, chatflow, workflow, agent, text_generator); duplicate endpoint copies with "(Copy)" suffix
- Application routes at `/api/applications` — use `project_id` query param for filtering by project
- tools_json and handoffs_json are JSON arrays stored as TEXT in agents table — parse on load, stringify on save
- /api/tools returns built-in tool catalog (static, no DB) — will be augmented with user-defined tools later
- Highlight-overlay pattern for textarea: use transparent text textarea (z-10) + backdrop div with styled HTML behind it; sync scroll and resize
- Agent meta config (variables, memory, context toggles) stored as `_` prefixed keys in `hooks_json` to avoid schema changes
- Version tracking pattern: auto-create version on template save via `_create_version()` helper; use COALESCE(MAX(version_number), 0) + 1 for auto-incrementing within a template
- Shared model API helper: `_send_prompt_to_model()` returns dict with optional `error` field (doesn't raise) — safe for asyncio.gather parallel calls
- React islands: use `client:only="react"` for DOM-heavy components (e.g., ReactFlow); requires @astrojs/react integration + tsconfig jsx settings
- Canvas island lives at `src/islands/Canvas/CanvasIsland.tsx`; sync theme via MutationObserver on `data-theme` attribute
- Workflows table stores canvas state as JSON TEXT columns: `nodes_json`, `edges_json`, `viewport_json`; workflow routes at `/api/workflows`
- CanvasIsland accepts optional `workflowId` prop — loads from GET /api/workflows/:id on mount, auto-saves with 500ms debounce via PUT
- Handle types defined in `handleTypes.ts` — `getHandlesForNodeType(nodeType)` returns HandleSpec[]; all nodes use `type: "workflow"` for custom rendering via WorkflowNode.tsx
- Custom nodeTypes/edgeTypes must be defined OUTSIDE the component (stable reference) — passed to `<ReactFlow nodeTypes={...} edgeTypes={...}>`
- Validation data on nodes: use `_` prefixed data props (_missingConfig, _unreachable, _disconnectedInputs) — injected via displayNodes useMemo
- `fitView({ nodes: [{ id }], padding: 0.5, duration: 400 })` centers viewport on a specific node — useful for navigate-to-node from panels
- WebSocket auth: extract session cookie manually via `websocket.cookies.get("orbiter_session")`, validate before `websocket.accept()`; no `Depends()` for WS
- Provider streaming: OpenAI/Anthropic use SSE (`data: ` prefix), Ollama uses NDJSON; use httpx `client.stream()` + `resp.aiter_lines()`
- Vite proxy needs `ws: true` for WebSocket forwarding — `/api` proxy only forwards HTTP by default
- WebSocket chat pattern: connect on agent select, send `{content: "..."}`, receive `{type: "token"|"done"|"error", ...}`; reconnect on clear to reset server-side history
- Conversation persistence: conversations + messages tables; WebSocket creates conversation lazily on first message; _TokenCollector wraps WS to capture streamed content for DB storage
- REST API for conversations at `/api/conversations` — list (with optional agent_id filter), get, delete, and `/api/conversations/:id/messages` for message history
- FastAPI route ordering: define `/search` or other static paths BEFORE `/{id}` param routes to prevent FastAPI matching "search" as an id
- Ruff B008: only `Depends()` triggers it — `Query(...)` with keyword args does NOT; don't add unnecessary noqa comments
- Confirmation dialogs: use native `<dialog>` with `.showModal()` and `backdrop:bg-dark/40` — no external modal library needed; close on backdrop click via `e.target === dialog`
- Workflow execution: `engine.py` has topological_sort (Kahn's) + execute_workflow; `routes/workflow_runs.py` has REST + WS endpoints; both share `/api/workflows` prefix
- Background asyncio tasks: store in a module-level `set()` and use `task.add_done_callback(set.discard)` to prevent GC (ruff RUF006)
- Ruff SIM105: use `contextlib.suppress(Exception)` instead of `try/except pass`
- CLI commands: use `asyncio.run()` to bridge sync argparse with async aiosqlite; call `run_migrations()` at start to ensure schema is current
- Debug execution pattern: asyncio.Queue bridges WebSocket commands to engine; _wait_for_debug_command handles side-effect commands inline while waiting for flow-control
- Variable tracking: both normal and debug execution emit `variables` dict in WebSocket events (node_completed, execution_completed); keyed by node_id
- Canvas panels: use `variablePanelOpen` state + Cmd+J shortcut for toggling; panel shows in both exec and debug modes
- Server-side handle type map in `tools.py` (`_NODE_HANDLE_MAP`) mirrors `handleTypes.ts` — keep both in sync when adding new node types
- Tool Mode on nodes: stored as `tool_mode: boolean` in node.data; exposed via `GET /api/tools/workflow-nodes`; wrench badge in WorkflowNode.tsx
- Marketplace catalog: static `MARKETPLACE_CATALOG` list in plugins.py; marketplace endpoints before /{id} routes; categories: Models, Tools, Agent Strategies, Extensions, Bundles
- Service layer: `orbiter_web/services/` directory for business logic separate from routes; AgentService bridges DB configs to live orbiter Agent objects
- orbiter-web depends on orbiter-core + orbiter-models via workspace deps in pyproject.toml + `[tool.uv.sources]`
- Rate limiting: custom in-memory `_SlidingWindow` in `middleware/rate_limit.py`; config via ORBITER_RATE_LIMIT_AUTH/GENERAL/AGENT env vars in settings
- RBAC: `require_role("admin")` from auth.py is a FastAPI dependency factory — use `Depends(require_role("admin"))` to restrict endpoints; hierarchy: viewer < developer < admin
- Agent runtime: `get_provider("provider:model", api_key=..., base_url=...)` creates ModelProvider; `Agent.run(input=..., messages=..., provider=...)` executes the tool loop
- Agent node execution: `_execute_agent_node()` in engine.py handles both DB-referenced and inline agents; inject `_user_id` into node data for provider resolution
- Upstream context: `_gather_upstream_inputs(node_id, edges, variables)` collects text from all upstream nodes — use for agent node input
- `_execute_node()` accepts optional `edges`, `variables`, `event_callback` — agent nodes use these, other node types ignore them
- Document routes are sub-routes of knowledge_bases router — same file, same APIRouter prefix `/api/knowledge-bases`
- Document processing: `services/document_processor.py` — extract_text(bytes, file_type) and chunk_text(text, size, overlap)
- DOCX extraction via stdlib (zipfile + xml.etree.ElementTree) — no external dep; PDF via pypdf with binary fallback
- KB retrieval settings: search_type, top_k, similarity_threshold, reranker_enabled stored per KB; keyword search uses LIKE + term frequency scoring
- Knowledge retrieval node in engine.py: `_execute_retrieval_node()` handles `knowledge_retrieval` nodeType; reads KB settings from DB
- Agent KB assignment: `knowledge_base_ids` column (JSON TEXT array) on agents table — stores list of KB IDs the agent can query
- Vector store config: singleton per user in `vector_store_config` table; auto-created on first GET; routes at `/api/vector-stores` (GET, PUT, POST /test)
- Agent memory: `memory_service` singleton in `services/memory.py` — `get_memory()`, `save_turn()`, `clear_memory()` using `context_memory_type` from agent config; strategies: conversation (full), sliding_window (last N), summary (LLM-summarized)
- Settings tabs: add tab button + panel div + lazy-load check in tab click handler; use `vsLoaded` / `providersLoaded` pattern for one-time fetch
- Context config fields: stored as proper columns on agents table (not in hooks_json meta); automation_level, max_tokens_per_step, max_total_tokens, memory_type, workspace_enabled
- Neuron pipelines: separate `neuron_pipelines` table, CRUD at `/api/agents/:id/pipelines`; neurons stored as JSON array in `neurons_json` column; auto-save with debounce
- Input sanitization: use `sanitize_html()` from `orbiter_web/sanitize.py` on all user-provided text fields before DB storage; apply in route handlers (not models)
- Security headers: `SecurityHeadersMiddleware` in `middleware/security.py` adds CSP, X-Content-Type-Options, X-Frame-Options; add frameable paths to `_FRAMEABLE_PATHS` set
- Time columns differ: `runs` table uses `start_time`/`end_time`; `workflow_runs` uses `started_at`/`completed_at` — always check migration SQL before writing queries
- Takeover protocol: WebSocket commands `takeover`, `inject`, `resume`, `stop`; server responds with `takeover_ack`, `takeover_event`, `takeover_stopped`; stream runs in asyncio.Task for cancellability
- Workspace settings: key-value store in `workspace_settings` table; GET/PUT at `/api/settings/workspace`; used for concurrent_run_limit and other workspace-level config
- Run queue: `run_queue` table + `services/run_queue.py`; workflow_runs.py checks `can_start_run()` before executing; engine triggers `process_queue()` on terminal states
- Audit logging: `audit_log(user_id, action, entity_type, entity_id, details, ip_address)` from `services/audit.py`; call after security-sensitive actions (login, logout, create/delete agent/workflow/deployment/provider_key)

---

## 2026-02-16 21:00 - US-016
- What was implemented: Projects CRUD REST API with 5 endpoints (list, create, get, update, delete)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/__init__.py (new — route package init)
  - packages/orbiter-web/src/orbiter_web/routes/projects.py (new — APIRouter with ProjectCreate, ProjectUpdate, ProjectResponse Pydantic models, 5 endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include projects_router)
- **Learnings for future iterations:**
  - APIRouter with prefix="/api/projects" keeps all project routes in one module, registered via app.include_router()
  - Pydantic's Field(min_length=1) provides automatic 422 validation for required string fields
  - aiosqlite.Row can be converted to dict via dict(row) for Pydantic model serialization
  - Dynamic UPDATE SET clause: build from model_dump(exclude_none=True) keys for partial updates
  - Placeholder _DEFAULT_USER_ID used until auth (US-018) is ready — easy to replace with a dependency later
  - DELETE returns 204 No Content with `status_code=204` and `-> None` return type
---

## 2026-02-16 20:16 - US-001
- What was implemented: Astro 5.x package scaffolding at packages/orbiter-web/
- Files changed:
  - packages/orbiter-web/package.json (astro@5.x, typescript, @astrojs/check)
  - packages/orbiter-web/tsconfig.json (extends astro/tsconfigs/strict)
  - packages/orbiter-web/astro.config.mjs (output: 'static')
  - packages/orbiter-web/src/pages/index.astro (placeholder page)
  - packages/orbiter-web/.gitignore (node_modules, dist, .astro)
- **Learnings for future iterations:**
  - Astro 5.x removed the `--typescript` flag from create-astro; strict is the default
  - tsconfig.json needs `"include": [".astro/types.d.ts", "**/*"], "exclude": ["dist"]` for Astro 5
  - `astro check` generates .astro/types.d.ts on first run — this is gitignored
  - npm install in orbiter-web is independent of the UV Python workspace
---

## 2026-02-16 20:20 - US-002
- What was implemented: Tailwind CSS v4 with design system color tokens
- Files changed:
  - packages/orbiter-web/package.json (added tailwindcss@4, @tailwindcss/vite)
  - packages/orbiter-web/astro.config.mjs (added @tailwindcss/vite plugin via vite.plugins)
  - packages/orbiter-web/src/styles/global.css (new — @import "tailwindcss", CSS custom properties for zen design tokens, @theme block mapping to Tailwind colors)
  - packages/orbiter-web/src/pages/index.astro (imports global.css, uses bg-paper text-dark)
- **Learnings for future iterations:**
  - Tailwind CSS v4 uses `@import "tailwindcss"` instead of `@tailwind base/components/utilities` directives
  - In Tailwind v4, `@theme {}` block defines custom design tokens that map directly to utility classes (e.g., `--color-coral` → `bg-coral`, `text-coral`)
  - CSS custom properties + @theme var() references allow theme switching via data attributes without JS runtime
  - Astro integrates Tailwind v4 via `vite.plugins` in astro.config.mjs, NOT via `@astrojs/tailwind`
---

## 2026-02-16 20:22 - US-003
- What was implemented: Font setup with Bricolage Grotesque (via @fontsource) and Junicode (variable woff2 files)
- Files changed:
  - packages/orbiter-web/package.json (added @fontsource/bricolage-grotesque)
  - packages/orbiter-web/package-lock.json (updated)
  - packages/orbiter-web/public/fonts/JunicodeVF-Roman.woff2 (new — variable font, Roman)
  - packages/orbiter-web/public/fonts/JunicodeVF-Italic.woff2 (new — variable font, Italic)
  - packages/orbiter-web/src/styles/global.css (added @fontsource imports, @font-face for Junicode, body font, font-junicode utility)
- **Learnings for future iterations:**
  - Use @fontsource for Google/open-source fonts — import individual weight CSS files (e.g., `@fontsource/bricolage-grotesque/400.css`)
  - Junicode v2.x ships as variable fonts (woff2) — use `font-weight: 100 900` in @font-face
  - Tailwind v4 @theme block supports `--font-*` custom properties that map to `font-*` utilities
  - `font-display: swap` prevents FOIT (flash of invisible text) during font loading
---

## 2026-02-16 20:25 - US-004
- What was implemented: cn() class merging utility using clsx + tailwind-merge
- Files changed:
  - packages/orbiter-web/package.json (added clsx, tailwind-merge)
  - packages/orbiter-web/package-lock.json (updated)
  - packages/orbiter-web/src/utils/merge.ts (new — exports cn() function)
- **Learnings for future iterations:**
  - cn() pattern: `twMerge(clsx(inputs))` — clsx handles conditional classes, twMerge resolves Tailwind conflicts
  - Import cn() via `import { cn } from "../utils/merge"` in Astro/TS components
  - tailwind-merge v3.x works with Tailwind v4 out of the box
---

## 2026-02-16 20:27 - US-005
- What was implemented: BaseLayout.astro with theme detection, animation support, and SEOHead component
- Files changed:
  - packages/orbiter-web/src/layouts/BaseLayout.astro (new — html/head/body shell with theme detection and IntersectionObserver)
  - packages/orbiter-web/src/components/SEOHead.astro (new — meta tags, OpenGraph, Twitter cards)
  - packages/orbiter-web/src/styles/global.css (added zenReveal, zenFade, zenScale keyframes)
  - packages/orbiter-web/src/pages/index.astro (updated to use BaseLayout)
- **Learnings for future iterations:**
  - Use `is:inline` on `<script>` tags in Astro for blocking scripts that must run before first paint (theme detection)
  - Theme detection pattern: localStorage → prefers-color-scheme → 'light' fallback, set on `document.documentElement`
  - `data-animate` attribute drives IntersectionObserver animations; value maps to keyframe name (zenReveal, zenFade, zenScale)
  - `prefers-reduced-motion: reduce` must be checked — skip animations and show elements immediately
  - SEOHead as a separate component allows pages to override title/description via props
  - BaseLayout uses `<slot />` for content projection — all pages should wrap content in `<BaseLayout>`
---

## 2026-02-16 20:30 - US-006
- What was implemented: Python FastAPI server foundation for orbiter-web
- Files changed:
  - packages/orbiter-web/pyproject.toml (new — fastapi, uvicorn, aiosqlite deps, hatchling build)
  - packages/orbiter-web/src/orbiter_web/__init__.py (new — package init with __version__)
  - packages/orbiter-web/src/orbiter_web/app.py (new — FastAPI app with GET /api/health endpoint)
  - packages/orbiter-web/src/orbiter_web/config.py (new — Settings dataclass with database_url, secret_key, debug)
  - pyproject.toml (added orbiter-web to workspace members, dev deps, uv.sources, ruff isort)
  - uv.lock (regenerated with orbiter-web + aiosqlite)
- **Learnings for future iterations:**
  - orbiter-web is a hybrid package: package.json for Astro frontend, pyproject.toml for FastAPI backend
  - When adding a workspace package: must update 3 sections in root pyproject.toml (members, dev deps, uv.sources)
  - Use `orbiter_web` (underscore) as Python package name since `orbiter-web` (hyphen) isn't valid Python
  - `hatch.build.targets.wheel.packages` must point to `["src/orbiter_web"]` for the wheel to include the code
  - Settings uses os.getenv in dataclass defaults — simple pattern, no pydantic-settings needed
---

## 2026-02-16 20:33 - US-007
- What was implemented: Dev server script using concurrently to run Astro + FastAPI together, with Vite proxy for /api/* requests
- Files changed:
  - packages/orbiter-web/astro.config.mjs (added vite.server.proxy for /api → http://127.0.0.1:8000)
  - packages/orbiter-web/package.json (added concurrently devDep, dev script uses concurrently, added dev:astro and dev:api scripts)
  - packages/orbiter-web/package-lock.json (updated with concurrently)
- **Learnings for future iterations:**
  - Astro uses Vite under the hood — configure proxies via `vite.server.proxy` in astro.config.mjs, NOT via Astro-specific config
  - Use `uv run uvicorn ...` in npm scripts to ensure the UV venv is active (avoids needing manual venv activation)
  - concurrently with `--names` and `--prefix-colors` makes dual-server output readable
  - uvicorn `--reload` watches Python files for changes; Astro has HMR built-in
---

## 2026-02-16 20:35 - US-008
- What was implemented: Reusable Button component with polymorphic rendering and three variants
- Files changed:
  - packages/orbiter-web/src/components/Button.astro (new — polymorphic button/link with primary, bordered, default variants)
- **Learnings for future iterations:**
  - Astro conditional rendering (`{href ? <a> : <button>}`) is cleaner than dynamic tag approach for polymorphic components
  - Use `[key: string]: any` in Astro Props interface to pass through arbitrary HTML attributes via `{...rest}`
  - Dark mode "just works" for Button because it uses design token colors (bg-dark/text-paper swap automatically)
  - Astro `check` reports unused variables as "hints" (not errors/warnings) — still worth cleaning up
---

## 2026-02-16 20:37 - US-009
- What was implemented: Reusable Card component with polymorphic element tag and hover lift effect
- Files changed:
  - packages/orbiter-web/src/components/Card.astro (new — polymorphic div/article/section with hover lift, border opacity increase, shadow)
- **Learnings for future iterations:**
  - Astro supports polymorphic elements by destructuring a tag prop (`as`) and using `<Tag>` in the template
  - Tailwind arbitrary opacity via bracket notation: `border-dark/[0.08]` for precise control
  - `hover:-translate-y-0.5` gives a subtle 2px lift effect; combine with `hover:shadow-lg` for depth
  - Dark mode works automatically because Card uses design token colors (bg-subtle, border-dark) that swap via CSS vars
---

## 2026-02-16 20:38 - US-010
- What was implemented: Input and Select form components with label, error state, required indicator, and design system styling
- Files changed:
  - packages/orbiter-web/src/components/Input.astro (new — text input with label, error, required, focus ring)
  - packages/orbiter-web/src/components/Select.astro (new — select dropdown with label, options, error, custom chevron)
- **Learnings for future iterations:**
  - Use `appearance-none` on `<select>` to remove browser default arrow, then add a custom SVG chevron via absolute positioning
  - Generate stable-ish IDs with `rest.id || rest.name || random` pattern to link `<label for>` to input
  - Error state uses `border-coral` + `focus:ring-coral/30`; normal state uses `border-dark/[0.08]` + `focus:ring-coral/20`
  - Dark mode works automatically via CSS custom properties (bg-paper, text-dark, border-dark swap)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 20:40 - US-011
- What was implemented: Badge and Modal components for status indicators and dialogs
- Files changed:
  - packages/orbiter-web/src/components/Badge.astro (new — rounded-full pill with coral, zen-blue, zen-green, default color variants)
  - packages/orbiter-web/src/components/Modal.astro (new — native `<dialog>` overlay with backdrop blur, slide-in animation, close button, click-outside-to-close)
- **Learnings for future iterations:**
  - Use native `<dialog>` element for modals — gives free Escape key closing, focus trapping, and `::backdrop` pseudo-element support
  - `<dialog>` must be opened via `.showModal()` in JS (not just adding `open` attribute) to get overlay/backdrop behavior
  - Use `data-modal-close` attributes with event delegation for close button + backdrop click pattern
  - `backdrop:bg-dark/40 backdrop:backdrop-blur-sm` targets the native `::backdrop` pseudo-element via Tailwind
  - Scoped `<style>` block in Astro for the `@keyframes` keeps animation definition local to the component
  - Modal uses `animate-[modalSlideIn_200ms_ease-out]` Tailwind arbitrary animation syntax for inline keyframe reference
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 20:42 - US-012
- What was implemented: Tabs component with tab navigation and coral accent active indicator, Toast component with success/error/info variants and auto-dismiss, section-divider utility class in global.css
- Files changed:
  - packages/orbiter-web/src/components/Tabs.astro (new — tab navigation with `data-tab` attributes, ARIA roles, coral underline indicator, JS for switching)
  - packages/orbiter-web/src/components/Toast.astro (new — fixed-position alert with variant icons, auto-dismiss via configurable timeout, slide-in/out animations)
  - packages/orbiter-web/src/styles/global.css (added section-divider utility class with gradient border-top line and responsive padding)
- **Learnings for future iterations:**
  - Tabs use `data-tab` and `data-tab-panel` attributes for JS switching; ARIA `role="tab/tablist/tabpanel"` for accessibility
  - Tab active indicator uses `scale-x-0/scale-x-100` with `transition-all` for smooth underline animation
  - Tabs use named slots (`<slot name={tab.id} />`) so consumers pass content as `<div slot="tabId">...</div>`
  - Toast auto-dismiss uses `setTimeout` + slide-out animation via inline `style.animation` assignment, then removes on `animationend`
  - `@keyframes` in scoped `<style>` works for initial animation, but programmatic dismiss needs to reference the keyframe by name in JS
  - section-divider uses `border-image: linear-gradient(...)` for a gradient top-border effect
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 20:46 - US-013
- What was implemented: PageLayout.astro — application shell with collapsible left sidebar navigation
- Files changed:
  - packages/orbiter-web/src/layouts/PageLayout.astro (new — extends BaseLayout, 10 nav sections with inline SVG icons, collapse toggle, localStorage persistence, Cmd+B shortcut)
- **Learnings for future iterations:**
  - SVG icons as inline HTML strings in frontmatter + `set:html` directive avoids needing an icon library dependency
  - `sidebar-label` CSS class used as a JS hook to toggle label visibility; `hidden lg:block` for responsive default, `lg:hidden` added dynamically when collapsed
  - Sidebar collapse state toggled via classList manipulation (`lg:w-60` ↔ `lg:w-16`) rather than CSS custom properties — simpler for Tailwind
  - `data-collapsed` attribute on sidebar tracks state for JS; `localStorage` persists across page loads
  - Cmd+B / Ctrl+B keyboard shortcut dispatches click on toggle button — keeps logic centralized
  - On `< lg` screens, sidebar is always collapsed to icon-only (w-16); labels are `hidden lg:block` by default
  - `getIcon()` helper function must be in Astro frontmatter (between `---` fences), not in template — Astro doesn't support function definitions in template expressions
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 20:50 - US-014
- What was implemented: Top bar with project name, Cmd+K search trigger, theme toggle, and user menu; Breadcrumbs component; mobile bottom tab bar (< md) with 5 key sections; mobile hamburger slide-out menu with full navigation
- Files changed:
  - packages/orbiter-web/src/components/Breadcrumbs.astro (new — accepts items array of {label, href}, renders with chevron separators, last item is plain text)
  - packages/orbiter-web/src/layouts/PageLayout.astro (major update — added top bar header, mobile bottom tab bar, mobile slide-out menu overlay, theme toggle, search Cmd+K shortcut, breadcrumbs prop)
- **Learnings for future iterations:**
  - Desktop sidebar is `hidden md:flex` — hidden on mobile, where bottom tab bar + hamburger menu take over
  - Mobile bottom tab bar shows 5 key sections (projects, agents, workflows, playground, settings) — filtered from full navSections array
  - Mobile slide-out menu uses translateX(-100%) → translateX(0) animation with a backdrop overlay; `void panel.offsetWidth` triggers reflow before animation
  - Theme toggle syncs with BaseLayout's `data-theme` attribute on `<html>` and `localStorage.setItem("theme", ...)` — consistent with BaseLayout's blocking theme detection script
  - Breadcrumbs conditional rendering in Astro JSX needs Fragment wrapper (`<>...</>`) when rendering multiple sibling elements inside `&&`
  - Main content has `pb-16 md:pb-0` to prevent the mobile bottom tab bar from overlapping scrollable content
  - PageLayout now accepts `breadcrumbs` and `projectName` props for flexible usage by consumer pages
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 20:53 - US-015
- What was implemented: SQLite database foundation with aiosqlite connection management, migration system, and initial migrations
- Files changed:
  - packages/orbiter-web/src/orbiter_web/database.py (new — get_db async context manager, run_migrations with _migrations tracking table)
  - packages/orbiter-web/src/orbiter_web/migrations/001_create_users.sql (new — users table with id, email, password_hash, created_at)
  - packages/orbiter-web/src/orbiter_web/migrations/002_create_projects.sql (new — projects table with FK to users, index on user_id)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — added lifespan handler to run migrations on startup)
- **Learnings for future iterations:**
  - aiosqlite.Row row_factory lets you access columns by name — set it in get_db for all queries
  - Use PRAGMA journal_mode=WAL and foreign_keys=ON at connection time for concurrency and referential integrity
  - executescript() runs multiple SQL statements (needed for migration files with multiple statements like CREATE TABLE + CREATE INDEX)
  - Migration files are sorted by filename, so use zero-padded numbering (001_, 002_)
  - FastAPI lifespan context manager replaces deprecated on_event("startup") — use `@asynccontextmanager` that yields once
  - Database URL parsing: config stores SQLAlchemy-style URL (sqlite+aiosqlite:///path), but aiosqlite just needs the file path
---

## 2026-02-16 21:00 - US-017
- What was implemented: Projects UI pages — list page at /projects with card grid, empty state, and create dialog; detail page at /projects/:id with rename and delete actions (with confirmation modal)
- Files changed:
  - packages/orbiter-web/src/pages/projects/index.astro (new — projects list with card grid, empty state, create modal, fetches from /api/projects)
  - packages/orbiter-web/src/pages/projects/[id].astro (new — project detail with metadata, rename modal, delete confirmation modal)
- **Learnings for future iterations:**
  - Use `<template>` elements for client-side card rendering — cloneNode(true) is cleaner than string concatenation
  - `is:inline` scripts in Astro can use `define:vars={{ var: value }}` to pass server-side values to client JS (used for projectId in [id].astro)
  - Dynamic routes in Astro: `[id].astro` extracts `Astro.params.id` — works for SSR/SSG modes
  - Modal.astro's `data-modal-close` event delegation works out of the box for new modals — just pass the modal id
  - `line-clamp-2` Tailwind utility is great for truncating card descriptions to 2 lines
  - Breadcrumb text can be updated client-side by finding spans with "Loading..." text and replacing
  - Fetch API calls to `/api/projects` are proxied via Vite during dev (configured in astro.config.mjs)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 21:10 - US-018
- What was implemented: Authentication backend — login, logout, me endpoints with bcrypt password hashing, HTTP-only session cookies, and protected route middleware
- Files changed:
  - packages/orbiter-web/pyproject.toml (added bcrypt>=4.0 dependency)
  - packages/orbiter-web/src/orbiter_web/config.py (added session_expiry_hours setting)
  - packages/orbiter-web/src/orbiter_web/migrations/003_create_sessions.sql (new — sessions table with user FK and expiry)
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (new — login/logout/me endpoints, get_current_user dependency)
  - packages/orbiter-web/src/orbiter_web/app.py (registered auth_router)
- **Learnings for future iterations:**
  - bcrypt 5.x provides `hashpw`/`checkpw` directly — no need for passlib wrapper
  - FastAPI `Cookie(None)` parameter extracts named cookie from request; cookie name matches the parameter name
  - `get_current_user` as a FastAPI `Depends()` dependency — reuse across any protected route
  - Ruff B008 flags `Depends()` in function defaults — use `# noqa: B008` for standard FastAPI dependency injection pattern
  - Session expiry checked in SQL: `WHERE s.expires_at > datetime('now')` — no Python datetime comparison needed
  - `response.set_cookie(httponly=True, samesite="lax")` for secure session cookies
  - `_hash_password` and `_verify_password` helpers keep bcrypt encoding details in one place
---

## 2026-02-16 21:15 - US-019
- What was implemented: Login page at /login with email/password form; client-side auth redirect for protected pages; Settings page at /settings with Profile, Appearance, API Keys, and Workspace sections
- Files changed:
  - packages/orbiter-web/src/pages/login.astro (new — standalone login form using BaseLayout, calls POST /api/auth/login, redirects to /projects on success)
  - packages/orbiter-web/src/pages/settings.astro (new — tabbed settings page with Profile (user info + logout), Appearance (light/dark/system theme), API Keys (placeholder), Workspace (default provider + concurrent run limit))
  - packages/orbiter-web/src/layouts/PageLayout.astro (added auth check script — fetches /api/auth/me, redirects to /login on 401)
- **Learnings for future iterations:**
  - Login page uses BaseLayout (not PageLayout) since it's a standalone page without sidebar navigation
  - Auth redirect is in PageLayout so ALL app pages get protection automatically — no per-page auth code needed
  - `fetch("/api/auth/me", { credentials: "same-origin" })` is the client-side auth check pattern — include credentials for cookies
  - Settings tab switching uses `data-settings-tab` attributes + `classList` manipulation — same pattern as Tabs.astro but simpler inline
  - Theme "system" option removes localStorage key and applies `prefers-color-scheme` media query result
  - Workspace settings (default_provider, concurrent_limit) stored in localStorage for now — will migrate to server-side when provider API exists
  - Login form checks `GET /api/auth/me` on load — if already authenticated, redirects to /projects immediately
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 21:30 - US-020
- What was implemented: Provider database schema with encrypted API key storage using Fernet symmetric encryption
- Files changed:
  - packages/orbiter-web/pyproject.toml (added cryptography>=42.0 dependency)
  - packages/orbiter-web/src/orbiter_web/migrations/004_create_providers.sql (new — providers table with CHECK constraint on provider_type, FK to users, index on user_id)
  - packages/orbiter-web/src/orbiter_web/crypto.py (new — Fernet encrypt/decrypt helpers using SHA-256 key derivation from app secret_key)
  - uv.lock (updated with cryptography dependency)
- **Learnings for future iterations:**
  - Fernet requires a 32-byte URL-safe base64-encoded key — derive from secret_key using `hashlib.sha256().digest()` then `base64.urlsafe_b64encode()`
  - SQLite CHECK constraints enforce enum-like values: `CHECK (provider_type IN ('openai', 'anthropic', ...))`
  - `encrypt_api_key()` / `decrypt_api_key()` in `orbiter_web/crypto.py` — use for any sensitive field storage
  - cryptography package was already transitively installed; adding explicit dependency ensures it's always available
---

## 2026-02-16 22:00 - US-021
- What was implemented: Provider CRUD REST API with 6 endpoints (list, create, get, update, delete, test connection)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/providers.py (new — APIRouter with ProviderCreate, ProviderUpdate, ProviderResponse, TestResult Pydantic models, 6 endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include providers_router)
  - packages/orbiter-web/pyproject.toml (added httpx>=0.27 dependency for provider connection testing)
  - uv.lock (updated with httpx)
- **Learnings for future iterations:**
  - API keys are encrypted at rest using crypto.py helpers — response model uses `api_key_set: bool` instead of exposing encrypted/plain key
  - `_row_to_response()` pops `encrypted_api_key` from the dict and replaces with `api_key_set` bool — keeps key out of API responses
  - Provider update accepts `api_key` in the body but maps it to `encrypted_api_key` column before building the SET clause
  - Test endpoint uses httpx for async HTTP calls — each provider type has a different lightweight test URL (models listing, tags, etc.)
  - Vertex requires base_url (service account auth), Ollama defaults to localhost:11434, custom providers also need base_url
  - httpx lazy-imported inside the test function to avoid import overhead for CRUD-only usage
  - All provider routes use `get_current_user` dependency for authentication — no more `_DEFAULT_USER_ID`
---

## 2026-02-16 22:30 - US-022
- What was implemented: Settings > Models page UI — replaced placeholder "API Keys" tab with full "Models" tab featuring provider management
- Files changed:
  - packages/orbiter-web/src/pages/settings.astro (major update — added Models tab with provider card list, add/edit/delete modals, test connection button, provider type icons, status indicators)
- **Learnings for future iterations:**
  - Replaced the "API Keys" placeholder tab with "Models" tab — panel ID changed from `panel-api-keys` to `panel-models`
  - Provider cards use `<template>` + `cloneNode(true)` pattern (consistent with projects page)
  - Providers are lazy-loaded: `fetchProviders()` only called when Models tab is first clicked (`providersLoaded` flag)
  - Provider type icons are stored as HTML strings in a JS object and injected via `innerHTML` — same pattern as sidebar icons
  - Status badge shows green dot ("Connected") when `api_key_set: true`, gray dot ("No Key") when false
  - Test connection result auto-hides after 8 seconds via `setTimeout`
  - Edit modal pre-fills all fields from provider data; API key field is blank with placeholder "Leave blank to keep current key"
  - Delete confirmation modal uses a `deleteTargetId` closure variable to track which provider to delete
  - Three modals (add, edit, delete) all use the existing Modal.astro component and `data-modal-close` pattern
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 23:00 - US-023
- What was implemented: Multi-key load balancing backend — provider_keys table, CRUD endpoints, load balancing strategies, auto-failover with cooldown
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/005_create_provider_keys.sql (new — provider_keys table with status, stats, cooldown; ALTER TABLE adds load_balance_strategy to providers)
  - packages/orbiter-web/src/orbiter_web/routes/provider_keys.py (new — APIRouter with key CRUD, strategy get/put, key selection with load balancing, usage reporting for failover)
  - packages/orbiter-web/src/orbiter_web/routes/providers.py (updated — added load_balance_strategy to ProviderResponse)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered provider_keys_router)
- **Learnings for future iterations:**
  - SQLite ALTER TABLE only supports ADD COLUMN (no DROP, RENAME, or modify constraints) — put ALTER in same migration as related CREATE TABLE
  - Load balancing key selection filters by status: active keys + rate_limited keys with expired cooldown
  - Round robin strategy: select key with lowest total_requests (natural rotation)
  - LRU strategy: select key with oldest last_used (NULL sorts first, so never-used keys get picked first)
  - Usage reporting endpoint (`POST /keys/:id/report`) updates stats and status: success resets errors, rate_limited sets cooldown, 5+ consecutive errors marks key as invalid
  - `datetime('now', '+' || ? || ' seconds')` for SQLite cooldown calculation
  - Provider keys router shares the `/api/providers` prefix with providers router — FastAPI handles sub-routes correctly
  - `_verify_provider_ownership()` helper avoids repeating the ownership check in every endpoint
---

## 2026-02-16 23:30 - US-024
- What was implemented: Multi-key management UI — expandable keys section on each provider card with key CRUD, health indicators, per-key stats, cooldown timers, and load balancing strategy selector
- Files changed:
  - packages/orbiter-web/src/pages/settings.astro (major update — added key row template, delete key modal, expandable keys section in provider card template with strategy selector + inline add form, JS for key CRUD/rendering/cooldown timers)
- **Learnings for future iterations:**
  - Keys section uses a toggle pattern: "Keys" button shows/hides `.provider-keys-section` inside each provider card
  - Key row template (`key-row-template`) is separate from provider card template — nested templates work with cloneNode(true)
  - Cooldown timers use `setInterval` keyed by key ID in a `cooldownIntervals` object — must clear all on re-render to prevent leaks
  - Strategy update is fire-and-forget (no UI feedback) since it's a lightweight PUT
  - Key stats use compact formatting: `formatTokens()` for 1.2K/1.5M, `formatRelativeTime()` for "5m ago" style
  - Delete key uses same modal pattern as delete provider but with separate state variables (deleteKeyTargetId, deleteKeyProviderId, deleteKeyCardEl)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 24:00 - US-025
- What was implemented: Model catalog backend — migration for models table, REST API with list/create/discover endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/006_create_models.sql (new — models table with provider FK, unique constraint on provider_id+model_name, indexes)
  - packages/orbiter-web/src/orbiter_web/routes/models.py (new — APIRouter with GET /api/models (filter by provider_id, provider_type, capability, search), POST /api/models (manual entry), POST /api/providers/:id/discover (auto-discovery from provider API))
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered models_router)
- **Learnings for future iterations:**
  - Models router uses `/api` prefix (not `/api/models`) to support both `/api/models` and `/api/providers/:id/discover` under one router
  - capabilities stored as JSON string in SQLite, parsed to list in `_row_to_response()`
  - is_custom stored as INTEGER (0/1) in SQLite, converted to bool in response
  - Discover endpoint tries provider-level `encrypted_api_key` first, falls back to `provider_keys` table for active keys
  - Upsert pattern: check existence by (provider_id, model_name) unique constraint, UPDATE if exists else INSERT
  - Provider-specific model listing: OpenAI/Anthropic use `/v1/models` (data array), Gemini uses `/v1beta/models` (models array with "models/" prefix), Ollama uses `/api/tags`
  - httpx lazy-imported inside `_fetch_models_from_provider` (same pattern as provider test endpoint)
  - JOIN with providers table in queries to include provider_name and provider_type in model responses
---

## 2026-02-17 03:10 - US-026
- What was implemented: Model catalog page UI at /models — card grid of all models with provider icons, capability tags, context window, pricing; filters (search, provider dropdown, capability, context window range); per-provider Fetch buttons for model discovery; "Fetch All" button; manual model entry form modal
- Files changed:
  - packages/orbiter-web/src/pages/models.astro (new — full models catalog page with card grid, filters, discover bar, add custom model modal)
- **Learnings for future iterations:**
  - Models page follows same patterns as projects page: `<template>` + `cloneNode(true)` for card rendering, `is:inline` script
  - Provider icons use colored letter badges (O/A/G/V/L/C) with provider-specific bg/text colors
  - Capability tags use per-capability colors: zen-blue for chat, zen-green for embedding, coral for vision, purple for reasoning, amber for code
  - Filter bar uses debounced `onFilterChange` (150ms) to avoid re-rendering on every keystroke
  - Provider bar is populated from `/api/providers` — each provider gets a "Fetch" button that triggers POST `/api/providers/:id/discover`
  - "Fetch All" button iterates over all providers and calls discover in parallel, then refreshes the model list
  - Manual model entry uses checkboxes for capabilities (multi-select) — `formData.getAll("capabilities")` collects all checked values
  - Discover button shows inline success/error feedback with auto-reset after 3-4 seconds
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 03:45 - US-027
- What was implemented: Model comparison view with checkbox selection (2-3 models), floating compare bar, side-by-side comparison modal with difference highlighting; default model dropdown in workspace settings (localStorage) and project detail page (server-side via PUT /api/projects/:id)
- Files changed:
  - packages/orbiter-web/src/pages/models.astro (major update — added compare checkboxes on model cards, floating compare bar, comparison modal with table layout, difference highlighting, max 3 selection with card ring highlight)
  - packages/orbiter-web/src/pages/settings.astro (updated — added "Default Model" dropdown to workspace tab, fetches from /api/models, saved to localStorage as `orbiter_default_model`)
  - packages/orbiter-web/src/pages/projects/[id].astro (updated — replaced static "Default Model" text with dynamic select dropdown populated from /api/models, "Save" button calls PUT /api/projects/:id with default_model)
- **Learnings for future iterations:**
  - Comparison checkbox state must be synced during renderModels() since the grid is rebuilt on filter changes — track selectedForCompare by model ID separately from DOM
  - Max selection enforcement: disable unchecked checkboxes when 3 are already selected, re-enable when one is deselected
  - `data-model-card-id` attribute on card div enables ring highlight for selected cards without re-rendering
  - Difference highlighting in comparison table: collect formatted values, check if all same, apply `bg-coral/5` highlight when values differ
  - Projects table already has `default_model` and `default_provider` columns — no migration needed
  - ProjectUpdate Pydantic model already accepts `default_model` — no backend changes needed
  - Workspace default model uses localStorage (`orbiter_default_model`), project default model uses server-side storage via the projects API
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 04:30 - US-028
- What was implemented: Application schema (migration) and REST API with 7 endpoints (list, create, get, update, delete, duplicate)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/007_create_applications.sql (new — applications table with type CHECK constraint, FK to projects and users, indexes)
  - packages/orbiter-web/src/orbiter_web/routes/applications.py (new — APIRouter with ApplicationCreate, ApplicationUpdate, ApplicationResponse, 7 endpoints including duplicate)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered applications_router)
- **Learnings for future iterations:**
  - Applications route follows same pattern as providers: `get_current_user` dependency, `_verify_ownership` helper for 404 checks
  - Duplicate endpoint copies name with "(Copy)" suffix, type, project_id, config_json — resets status to "draft" (default)
  - `config_json` stored as TEXT (not JSON type) in SQLite — no JSON validation at DB level, just Pydantic string field
  - GET /api/applications supports optional `project_id` query param via `Query(None)` — builds different SQL based on presence
  - Applications have both `project_id` FK (to projects) and `user_id` FK (to users) — ownership check is on user_id
---

## 2026-02-17 05:00 - US-029
- What was implemented: New Application dialog on the project detail page — modal with five type cards (Chatbot, Chatflow, Workflow, Agent, Text Generator), each with icon, description, and use case examples; two-step flow (select type → enter name → create)
- Files changed:
  - packages/orbiter-web/src/pages/projects/[id].astro (updated — added "New Application" button in actions row, New Application modal with 5 type cards grid, name input step, create logic calling POST /api/applications, navigation to builder on success)
- **Learnings for future iterations:**
  - Two-step dialog pattern: show type cards first, then slide to name input — avoids cluttering the type selection with a form
  - Type card selection hides the grid and shows a badge + "Change" link for the selected type — gives a clear undo path
  - Each type has a unique accent color (coral, zen-blue, zen-green, purple-500, amber-500) matching the capability tag colors used on models page
  - `sm:col-span-2` on the last card (Text Generator) makes it full-width in the 2-column grid — cleaner layout with odd number of items
  - Dialog reset function must clear both selectedAppType state and visual selection classes — call on both modal close and "Change" click
  - Enter key on name input delegates to create button click — keeps submit logic centralized
  - After successful creation, navigates to `/applications/{id}` — builder pages will be implemented in later stories
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 05:30 - US-030
- What was implemented: Application list page at /applications with grid/list view toggle, type badges (colored per type), status badges, search filter, type filter, duplicate action on each card, click-to-navigate to builder
- Files changed:
  - packages/orbiter-web/src/pages/applications.astro (new — full applications listing with grid/list views, filters, duplicate modal, type/status badges)
- **Learnings for future iterations:**
  - Grid/list view toggle persisted in localStorage (`orbiter_apps_view`) — set initial view before first render to avoid flash
  - Applications don't have their own sidebar nav entry — they are accessed globally or from project detail pages
  - Project names enriched via a second `/api/projects` fetch after loading apps — creates a projectMap lookup by ID
  - Duplicate button on cards needs `position: relative; z-index: 10` to sit above the full-card `<a>` link overlay
  - Type colors reuse the same scheme from US-029 New Application dialog: coral (chatbot), zen-blue (chatflow), zen-green (workflow), purple (agent), amber (text_generator)
  - `<template>` elements work for both grid cards and list rows — use separate templates for different layouts rather than trying to reuse one
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 06:00 - US-031
- What was implemented: Agent schema (migration) and REST API with 5 endpoints (list, create, get, update, delete)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/008_create_agents.sql (new — agents table with all AgentConfig fields, FK to projects and users, indexes)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (new — APIRouter with AgentCreate, AgentUpdate, AgentResponse Pydantic models, 5 CRUD endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered agents_router)
- **Learnings for future iterations:**
  - Agents route follows identical pattern to applications: `get_current_user` dependency, `_verify_ownership` helper, `_row_to_dict` converter
  - AgentConfig fields stored as JSON TEXT columns: output_type_json, tools_json, handoffs_json, hooks_json — no DB-level JSON validation
  - temperature is REAL (float), max_tokens and max_steps are INTEGER — all nullable for optional config
  - Agent belongs to both a project (project_id FK) and a user (user_id FK) — same ownership pattern as applications
---

## 2026-02-17 06:30 - US-032
- What was implemented: Agent builder page at /agents/:id/edit with tabbed form (Basic + Model tabs)
- Files changed:
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (new — agent builder with tab switching, Basic tab for name/description/instructions, Model tab for provider/model selectors + temperature slider + max_tokens)
- **Learnings for future iterations:**
  - Agent builder uses dynamic route `[id]/edit.astro` — Astro supports nested dynamic segments
  - Provider selector populated from `/api/providers`, model selector from `/api/models?provider_id=X` — cascading dropdowns pattern
  - Agent stores `model_provider` as provider_type string (e.g., "openai"), not provider ID — need `findProviderIdByName()` to resolve on load
  - Model preview shows `providerName:modelName` format string below the selectors
  - Temperature slider uses native `<input type="range">` with `accent-coral` and live numeric display via `input` event
  - Ctrl/Cmd+S keyboard shortcut for save — `e.preventDefault()` blocks browser's default save dialog
  - Tab switching: toggle `hidden` class on panels, swap `border-coral`/`text-dark` on active tab button
  - Save sends only changed fields; PUT /api/agents/:id handles partial updates via `model_dump(exclude_none=True)`
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 07:00 - US-033
- What was implemented: Agent builder Tools and Handoffs tabs — Tools tab with assigned tool list, drag-to-reorder, add tool modal (fetches from /api/tools), remove button; Handoffs tab with assigned handoff list, add handoff modal (fetches project agents from /api/agents), remove button; both saved via PUT /api/agents/:id as tools_json and handoffs_json
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/tools.py (new — /api/tools endpoint returning built-in tool catalog with 10 tools across 5 categories)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered tools_router)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — added Tools and Handoffs tab buttons, tab panels with tool/handoff lists, tool selector modal, handoff agent selector modal, drag-to-reorder for tools, save includes tools_json and handoffs_json)
- **Learnings for future iterations:**
  - Tools tab stores assigned tools as array of {id, name, description, category} objects in tools_json — parsed on load, serialized on save
  - Handoffs tab stores handoff targets as array of {id, name, description} objects in handoffs_json — same pattern
  - Drag-to-reorder uses native HTML5 drag and drop: `draggable="true"`, dragstart/dragover/drop events, splice to move items in the array, then re-render
  - Tool selector modal filters out already-assigned tools from the available tools list
  - Handoff selector modal filters out the current agent (self) and already-assigned handoffs
  - /api/tools returns a static built-in tool catalog (no DB table yet) — will be augmented with user-defined tools later
  - Category icons (retrieval, filesystem, execution, data, utility) stored as SVG HTML strings in a JS object, keyed by category name
  - Modal.astro can be reused for both tool and handoff selectors — just pass different id and title
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 07:45 - US-034
- What was implemented: Agent builder Hooks and Advanced tabs — Hooks tab with 5 HookPoint values (before_model_call, after_model_call, before_tool_call, after_tool_call, on_error) each with function name/path input; Advanced tab with max_steps slider (1-100), output_type JSON Schema textarea with on-blur validation, Memory toggle, Context Engine toggle
- Files changed:
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — added Hooks and Advanced tab buttons + panels, hook input fields, max_steps slider, output_type textarea with JSON validation, toggle switches, save includes all new fields)
- **Learnings for future iterations:**
  - Hook points are stored as a flat object in hooks_json: `{"before_model_call": "module.func", ...}` — keys are hook point names, values are function references
  - Toggle state (memory, context) stored as meta flags (`_memory_enabled`, `_context_enabled`) inside hooks_json to avoid schema changes — these are not hook points but config flags
  - Toggle switch pattern: `role="switch"` + `aria-checked` + coral bg when on; `.toggle-dot` uses `translate-x-5` for the slide animation
  - JSON validation on blur: `JSON.parse()` in try/catch, show `border-coral` + error message on failure; validate again before save and switch to Advanced tab if invalid
  - Max steps slider uses same pattern as temperature: `input` event updates a `<span>` with current value, `accent-coral` for the range thumb
  - Output type textarea pretty-prints stored JSON on load with `JSON.stringify(JSON.parse(...), null, 2)` for readability
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 08:20 - US-035
- What was implemented: Enhanced system prompt editor on agent builder Basic tab — replaces plain textarea with highlight-overlay editor that colorizes `{{variable_name}}` patterns, a right-side variables panel showing detected variables with type selector (string/number/boolean) and default value input, and a token counter estimating input tokens
- Files changed:
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — instructions section replaced with highlight-overlay editor, variables panel, token counter; JS added for highlighting, variable extraction, token estimation, scroll sync, resize observer; variable config stored/loaded via hooks_json `_variables` meta flag; scoped CSS for `.prompt-variable` styling)
- **Learnings for future iterations:**
  - Highlight-overlay pattern: transparent-text textarea on z-10 + backdrop div with styled HTML behind it; caret-dark ensures cursor visible while text is transparent
  - Sync backdrop scroll with textarea via `scrollTop`/`scrollLeft` on `scroll` event; use `ResizeObserver` to keep backdrop height in sync with textarea resize
  - `{{variable}}` detection via regex `\{\{(\w+)\}\}/g` — deduplicate names with a seen-set
  - Token estimation: rough ~4 chars/token for English text (Math.ceil(text.length / 4))
  - Variable config (type + defaultValue) stored as `_variables` object inside `hooks_json` meta flags — avoids new DB migration
  - Variables panel uses `lg:w-64 flex-shrink-0` alongside `flex-1 min-w-0` for the editor — responsive side-by-side on lg+, stacked below on mobile
  - Debounce variable panel rendering (200ms) to avoid excessive DOM rebuilds on fast typing; highlighting + token counter update immediately
  - Scoped `<style>` block in Astro for `.prompt-variable` keeps highlighting styles local to the editor page
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 09:00 - US-036
- What was implemented: Prompt template library with save/load/delete, test prompt against models, and import/export as JSON
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/009_create_prompt_templates.sql (new — prompt_templates table with name, content, variables_json, user_id, timestamps)
  - packages/orbiter-web/src/orbiter_web/routes/prompt_templates.py (new — CRUD endpoints + test prompt endpoint that sends to provider APIs)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered prompt_templates_router)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — added Save/Load/Test/Import/Export buttons above instructions editor, save template modal, load template modal with search+delete, test result panel below editor, import via file input, export as JSON download)
- **Learnings for future iterations:**
  - Template buttons row uses compact `text-[11px]` sizing with subtle bg to stay visually secondary to the main editor
  - Test prompt endpoint reuses provider key resolution pattern from provider test (try provider-level key, fall back to provider_keys table)
  - Test prompt fills `{{variable}}` with default values from detectedVariables, falling back to `[name]` placeholder
  - Import/Export uses FileReader + Blob/URL.createObjectURL for client-side file I/O — no server round-trip needed
  - Load template modal includes inline delete buttons (trash icon) with confirm() dialog — no separate delete modal needed for lightweight items
  - Test result panel sits between editor and variables panel, using `max-h-64 overflow-y-auto` for long outputs
  - Provider-specific API call patterns: OpenAI uses /v1/chat/completions, Anthropic uses /v1/messages with x-api-key header, Gemini uses generateContent with key param, Ollama uses /api/generate
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 10:00 - US-037
- What was implemented: Prompt model comparison and version history — multi-model comparison (send same prompt to 2-3 models in parallel, side-by-side output display with per-model metrics), prompt version history (every template save creates a version), side-by-side diff view between any two versions, restore previous version button
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/010_create_prompt_versions.sql (new — prompt_versions table with template FK, version_number, content, variables_json)
  - packages/orbiter-web/src/orbiter_web/routes/prompt_templates.py (major update — added VersionResponse, CompareRequest/Response Pydantic models, _create_version helper, _send_prompt_to_model shared helper, version CRUD endpoints: list/get/restore, POST /compare endpoint with asyncio.gather for parallel model calls; template create/update auto-creates versions; delete cascades to versions)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — added Compare and History buttons next to Test button, model comparison selector modal with 3 provider/model slots, comparison result grid panel, version history modal with checkbox-based diff selection, side-by-side diff view with change highlighting, restore version button, currentTemplateId tracking)
- **Learnings for future iterations:**
  - Refactored _send_prompt_to_model as a shared helper (returns dict with error field on failure instead of raising) — reused by both /test and /compare endpoints
  - asyncio.gather runs parallel API calls for comparison — each model gets its own httpx.AsyncClient
  - Version history diff uses simple line-by-line comparison: same lines plain, different lines highlighted with bg-coral/10 (removed) and bg-zen-green/10 (added)
  - Diff view requires exactly 2 checkboxes selected — when a 3rd is checked, the first selection is automatically unchecked (FIFO rotation)
  - currentTemplateId is set when saving or loading a template — tracked as a JS closure variable for version history API calls
  - Compare result grid uses CSS `grid-template-columns: repeat(N, minmax(0, 1fr))` dynamically set based on the number of models (2 or 3)
  - Restore creates a new version (recording the restore action) and updates the template content — ensures no version history is lost
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 11:10 - US-038
- What was implemented: Role-based agent persona section — collapsible persona panel in agent builder Basic tab with Role, Goal, and Backstory fields; 5 persona templates (Researcher, Writer, Coder, Reviewer, Planner); preview button showing full system prompt with persona injected; persona fields stored in DB via new migration
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/011_add_agent_persona.sql (new — ALTER TABLE adds persona_role, persona_goal, persona_backstory to agents)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (updated — added persona_role, persona_goal, persona_backstory to AgentCreate, AgentUpdate, AgentResponse models and INSERT query)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (major update — added collapsible persona section with toggle, template dropdown, role/goal/backstory fields, preview modal, load/save integration)
- **Learnings for future iterations:**
  - Persona fields stored as top-level DB columns (not inside hooks_json) since they are primary agent config, not meta flags
  - Collapsible section pattern: button toggles `hidden` on content div + rotates chevron via `style.transform`
  - `personaBadge` shows "Set" pill when any persona field has content — gives visual indicator when section is collapsed
  - Persona template dropdown pre-fills all 3 fields at once; selecting "Custom..." doesn't clear fields (user can manually edit after template)
  - Preview builds full prompt with `## Persona` section (Role, Goal, Backstory) prepended before `## Instructions`
  - Auto-expand persona section on load if agent has any persona data (persona_role/goal/backstory non-empty)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 12:00 - US-039
- What was implemented: AI-assisted agent builder backend — POST /api/agents/ai-generate endpoint that accepts a natural language description and generates agent configuration(s) using a configured LLM provider
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (major update — added AIGenerateRequest, GeneratedAgentConfig, AIGenerateResponse Pydantic models, _SYSTEM_PROMPT for agent generation, _call_model_for_generation helper with multi-provider support, _parse_generated_config JSON parser with markdown fence stripping and tool validation, POST /ai-generate endpoint with auto-provider discovery and per-type default models)
- **Learnings for future iterations:**
  - AI-generate endpoint placed BEFORE `/{agent_id}` catch-all routes in FastAPI — order matters for path parameter matching; "ai-generate" would be captured as an agent_id otherwise
  - `_call_model_for_generation` follows same pattern as `_send_prompt_to_model` in prompt_templates.py but uses system+user messages (not single user message) for structured output
  - Anthropic API uses separate `system` field (not in messages array) — different from OpenAI's system message format
  - Gemini and Ollama don't support system messages natively — concatenate system + user prompt as single user content
  - `_parse_generated_config` handles three JSON formats: `{"agents": [...]}`, `[...]`, and `{...}` (single agent) — covers common LLM output variations
  - Markdown code fence stripping: check for ``` prefix and strip to first newline (handles ```json), then strip trailing ```
  - Tool validation: filter suggested_tools against known BUILTIN_TOOLS IDs — prevents hallucinated tool names from passing through
  - Auto-provider discovery: query providers with encrypted_api_key or active provider_keys; per-type default models (gpt-4o for openai, claude-sonnet-4-5-20250514 for anthropic, etc.)
  - `model` field in request uses "provider_id:model_name" format for explicit selection, or just model_name for auto-provider resolution
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 13:00 - US-040
- What was implemented: AI-assisted agent builder UI — "AI Builder" button on project detail page, multi-step modal with natural language description input, loading state, review panel with editable fields (name, role, instructions, tools as removable pills, model), confirm button that creates agent via POST /api/agents
- Files changed:
  - packages/orbiter-web/src/pages/projects/[id].astro (major update — added AI Builder button, ai-builder-modal with 3 steps: describe, loading, review; JS for generate/review/create flow)
- **Learnings for future iterations:**
  - AI Builder added as a "bordered" variant button next to "New Application" on project detail page — keeps it visible but secondary
  - Multi-step modal pattern: hide/show step divs (ai-step-describe, ai-step-loading, ai-step-review) within a single Modal component
  - AI-generate API returns `{agents: [...]}` — take first agent for single-agent generation flow
  - Tool pills rendered as removable badges with `&times;` close button; tools stored as simple string array, mapped to `{id, name}` objects on creation
  - Enter key in textarea submits (Shift+Enter for newline) — same pattern as chat inputs
  - After agent creation, navigates to `/agents/:id/edit` so user can further customize
  - generatedTools tracked as a JS array alongside the DOM — re-render on every change (add/remove)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 14:00 - US-041
- What was implemented: Xyflow React island setup — React 19 + @xyflow/react installed, @astrojs/react integration added, CanvasIsland.tsx component with ReactFlowProvider and dark mode sync, workflow canvas page
- Files changed:
  - packages/orbiter-web/package.json (added react@19, react-dom@19, @xyflow/react, @astrojs/react)
  - packages/orbiter-web/package-lock.json (updated)
  - packages/orbiter-web/astro.config.mjs (added @astrojs/react integration)
  - packages/orbiter-web/tsconfig.json (added jsx: react-jsx, jsxImportSource: react)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (new — ReactFlowProvider wrapper, CanvasFlow with dark mode sync via MutationObserver on data-theme)
  - packages/orbiter-web/src/pages/workflows/canvas.astro (new — workflow canvas page using PageLayout + CanvasIsland with client:only="react")
- **Learnings for future iterations:**
  - React islands in Astro: use `client:only="react"` for components that need browser-only APIs (ReactFlow uses DOM extensively)
  - @astrojs/react integration: add to `integrations` array in astro.config.mjs, and set `jsx: "react-jsx"` + `jsxImportSource: "react"` in tsconfig.json
  - ReactFlow `colorMode` prop accepts "light", "dark", or "system" — sync with app theme via MutationObserver on `document.documentElement.dataset.theme`
  - Canvas needs full-height container: use `!overflow-hidden flex flex-col` on PageLayout's class + `flex-1 min-h-0` wrapper div
  - ReactFlow CSS must be imported in the component: `import "@xyflow/react/dist/style.css"`
  - `useThemeColorMode()` custom hook: watches `data-theme` attribute mutations to keep ReactFlow colorMode in sync with the app's theme toggle
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 14:30 - US-042
- What was implemented: Canvas pan, zoom, grid, and minimap — added MiniMap component (pannable + zoomable), dot-pattern Background, snap-to-grid with configurable 20px grid size
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — added MiniMap, BackgroundVariant.Dots, snapToGrid/snapGrid props, GRID_SIZE constant)
- **Learnings for future iterations:**
  - ReactFlow pan (click-drag) and zoom (mouse wheel) work out of the box — no additional props needed
  - `BackgroundVariant.Dots` with matching `gap={GRID_SIZE}` aligns dot pattern with snap grid
  - MiniMap accepts `pannable` and `zoomable` props for interactive navigation; `position="bottom-right"` places it via ReactFlow's built-in positioning
  - `snapGrid` type is `[number, number]` tuple — explicit type annotation needed for TypeScript
  - Background `size` prop controls dot radius (1.5 is a subtle, non-intrusive dot size)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 15:00 - US-043
- What was implemented: Canvas toolbar and keyboard shortcuts — replaced built-in `<Controls />` with custom `<Panel>` toolbar at top-center with zoom in/out, fit view, lock/unlock toggle, undo/redo buttons; implemented undo/redo history stack with ref-based past/future arrays (max 50 entries); keyboard shortcuts for Delete (remove selected), Cmd+Z (undo), Cmd+Shift+Z (redo), Cmd+A (select all); tooltips on all buttons showing keyboard shortcut hints with Mac/Windows detection
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (major rewrite — added Panel-based toolbar, useUndoRedo hook, ToolbarButton component, SVG icons, keyboard shortcut handler, lock/unlock state, platform-aware shortcut labels)
- **Learnings for future iterations:**
  - ReactFlow `<Panel position="top-center">` positions custom UI inside the flow viewport — use `className="nodrag nopan"` on interactive elements to prevent canvas drag/pan
  - Undo/redo uses ref-based history stacks (useRef) instead of state to avoid re-render loops; a `skipRecord` flag prevents recording when restoring state
  - `structuredClone()` for deep-copying nodes/edges in history snapshots — handles nested objects correctly
  - Record history before structural changes only (add/remove), not on position changes (drag) — check `change.type` in onNodesChange/onEdgesChange
  - Lock toggle disables `nodesDraggable`, `nodesConnectable`, `elementsSelectable`, `panOnDrag`, `zoomOnScroll`, `zoomOnPinch`, `zoomOnDoubleClick` all at once
  - `useReactFlow()` provides `zoomIn()`, `zoomOut()`, `fitView()` with optional `duration` param for smooth animation
  - Platform detection for shortcut labels: `navigator.userAgent` test for Mac → use ⌘ symbol, otherwise "Ctrl+"
  - Keyboard shortcuts must check `e.target.tagName` to avoid intercepting when user is typing in input/textarea
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 23:05 - US-044
- What was implemented: Canvas state persistence — workflows table, CRUD API, load/save in CanvasIsland
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/012_create_workflows.sql (new — workflows table with nodes_json, edges_json, viewport_json columns)
  - packages/orbiter-web/src/orbiter_web/routes/workflows.py (new — CRUD API: list, create, get, update, delete)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered workflows_router)
  - packages/orbiter-web/src/pages/workflows/[id].astro (new — dynamic route passing workflowId to CanvasIsland)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — added workflowId prop, useAutoSave hook, load on mount, debounced save, viewport tracking)
- **Learnings for future iterations:**
  - Canvas state stored as JSON TEXT columns: nodes_json, edges_json, viewport_json — parse on load, stringify on save
  - Workflow CRUD follows same pattern as applications route (APIRouter, Pydantic models, _verify_ownership helper)
  - CanvasIsland accepts optional workflowId prop — without it, works as standalone canvas (backwards compatible)
  - Use `useAutoSave` hook pattern: debounced save with `savingRef` to prevent concurrent saves
  - Track viewport via `onMoveEnd` callback from ReactFlow — stores {x, y, zoom} in ref
  - When loading saved viewport, use `setViewport()` from `useReactFlow()` and disable `fitView` prop
  - `loaded` state gate prevents auto-save from firing during initial load (avoids saving empty state)
  - React.MutableRefObject is deprecated in newer React types — use React.RefObject instead
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 23:30 - US-045
- What was implemented: Node sidebar with 9 categorized node types — collapsible left panel inside the canvas with drag-to-add support, search filter, per-category color accents, and distinct SVG icons for each of the 28 node types
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/NodeSidebar.tsx (new — sidebar component with NODE_CATEGORIES catalog, category expand/collapse, drag start handler, search filter)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — added NodeSidebar import, sidebar collapse state, onDragOver/onDrop handlers, screenToFlowPosition for accurate node placement)
- **Learnings for future iterations:**
  - NodeSidebar uses absolute positioning inside ReactFlow container (not a Panel) — gives more control over full-height layout
  - `className="nodrag nopan nowheel"` on sidebar root prevents ReactFlow from capturing drag/pan/scroll events on the sidebar
  - Drag-and-drop from sidebar to canvas: set `application/reactflow-type` and `application/reactflow-label` in dataTransfer, read in onDrop handler
  - `screenToFlowPosition()` from useReactFlow converts screen coordinates to flow coordinates — essential for accurate node drop placement
  - Category colors use CSS hex with alpha suffix for hover bg (e.g., `${color}18`) and icon bg (e.g., `${color}20`)
  - NODE_CATEGORIES exported for reuse (e.g., color lookup in CanvasIsland drop handler)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 23:40 - US-046
- What was implemented: Node drag-and-drop and search — enhanced sidebar search to also match category names (not just node type labels). All other acceptance criteria (drag from sidebar, drop at position, search input, real-time filtering) were already implemented in US-045.
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/NodeSidebar.tsx (updated — filteredCategories now matches against cat.label in addition to node type t.label; if category matches, all its types are shown)
- **Learnings for future iterations:**
  - Category-level search match: if search term matches the category label, show ALL types in that category (don't filter individual types)
  - This is a one-line logic change: check `cat.label.toLowerCase().includes(q)` before filtering individual types
  - US-045 already implemented most of US-046's acceptance criteria (drag-to-add, search input, real-time filtering) — always check existing code before starting
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 04:45 - US-047
- What was implemented: Node configuration panel shell — right-side slide-in panel that opens when a node is clicked on the canvas, with editable node name, category/type display, node ID, and placeholder for type-specific config fields
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx (new — slide-in panel with name editing, type info display, auto-save debounce, Escape/X close)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — added selectedNodeId state, onNodeClick/onPaneClick handlers, handleNodeDataUpdate callback, NodeConfigPanel integration, panel-aware delete)
- **Learnings for future iterations:**
  - NodeConfigPanel uses absolute positioning inside ReactFlow (same as NodeSidebar) with `className="nodrag nopan nowheel"` to prevent canvas interaction
  - Slide-in animation via inline `<style>` tag with `@keyframes slideInRight` — works in React islands
  - Config panel debounce (500ms) is separate from auto-save debounce — panel debounces calling onNodeUpdate, which then triggers the existing useAutoSave via nodes state change
  - When deleting nodes, must check if the deleted node is the one shown in the config panel and close it
  - `getNodeTypeInfo()` looks up NODE_CATEGORIES to display category color, icon, and label for any node type
  - Panel closes on: X button click, Escape key, clicking empty canvas (onPaneClick)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 - US-048
- What was implemented: LLM Call and Agent node configuration panels in the workflow canvas — LlmCallConfig component with provider/model cascading dropdowns, prompt textarea with {{variable}} preview, temperature slider, max_tokens input, response format selector; AgentNodeConfig component with agent selector from /api/agents, "Create Inline" option with simplified inline agent form (name, provider, model, instructions, tool checkboxes); integrated into NodeConfigPanel via renderTypeConfig dispatcher
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/LlmCallConfig.tsx (new — LLM Call node config with provider/model selectors, prompt, temperature, max_tokens, response_format)
  - packages/orbiter-web/src/islands/Canvas/AgentNodeConfig.tsx (new — Agent node config with existing agent selector or inline agent form)
  - packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx (updated — added renderTypeConfig dispatcher, scheduleDataUpdate callback, imports for LlmCallConfig and AgentNodeConfig)
- **Learnings for future iterations:**
  - Type-specific configs rendered via a `renderTypeConfig()` dispatcher function that pattern-matches on `node.data.nodeType`
  - Config components receive `data` (extracted from node.data) and `onChange` (merges updates back) — keeps them decoupled from ReactFlow internals
  - `scheduleDataUpdate` is separate from `scheduleUpdate` (name-only) — both share the same `debounceRef` to avoid racing updates
  - Agent config uses a mode switch: `inline: false` shows agent dropdown, `inline: true` shows simplified inline form — "Create Inline" is a special option value `__create_inline__`
  - Provider→Model cascading: fetch models when provider changes via `useEffect` on selectedProvider; disable model dropdown when no provider selected
  - Prompt {{variable}} preview uses regex replace to inject styled spans, rendered via `dangerouslySetInnerHTML` in a preview div below the textarea
  - Both `agent_node` and `sub_agent` types share the same AgentNodeConfig component (via `AGENT_TYPES` Set)
  - Non-configured node types still show the gear icon placeholder with "coming soon" message
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 - US-049
- What was implemented: Conditional, Code, and HTTP Request node configuration panels for the workflow canvas
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/ConditionalConfig.tsx (new — condition expression editor with monospace textarea, true/false labeled output handle editors with colored T/F badges, handle guide info box)
  - packages/orbiter-web/src/islands/Canvas/CodeNodeConfig.tsx (new — Python/JavaScript language toggle, syntax-highlighted code editor with line numbers using highlight overlay pattern, Tab key indentation, entry function input, timeout setting)
  - packages/orbiter-web/src/islands/Canvas/HttpRequestConfig.tsx (new — method dropdown with colored method names, URL input, collapsible key-value headers editor with add/remove, body textarea for POST/PUT, auth selector with bearer/basic/api_key modes, timeout)
  - packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx (updated — added imports and renderTypeConfig dispatcher cases for conditional, code_python, code_javascript, http_request node types)
- **Learnings for future iterations:**
  - Node config components follow a consistent pattern: `data` prop (typed interface), `onChange` callback that merges updates; same shared style constants (labelStyle, inputStyle, selectStyle, focusHandlers)
  - `CODE_TYPES` Set pattern (like `AGENT_TYPES`) groups `code_python` and `code_javascript` into a single config component with `initialLanguage` prop
  - Syntax highlighting in code editor uses the same highlight-overlay pattern from the agent prompt editor (transparent textarea on top, styled HTML below)
  - Python/JS keyword highlighting via regex replacement chain: comments → strings → numbers → keywords; order matters to avoid double-highlighting
  - Tab key handling in textarea: `e.preventDefault()` + string splice + `requestAnimationFrame` to restore cursor position after React re-render
  - HTTP method colors (GET=green, POST=blue, PUT=amber, DELETE=red) follow REST API convention colors
  - Headers key-value editor uses indexed array manipulation — updateHeader/removeHeader take the array index
  - Auth type selector clears all auth fields on type change to avoid stale data leaking between auth modes
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 05:00 - US-050
- What was implemented: Knowledge Retrieval node configuration panel — select knowledge base dropdown (fetches from /api/knowledge-bases), top-k slider (1-20), similarity threshold slider (0.0-1.0), inline validation errors, required field asterisks, info box with dynamic parameter display
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/KnowledgeRetrievalConfig.tsx (new — KnowledgeRetrievalConfig component with KB dropdown, top-k and similarity sliders, validation, info box)
  - packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx (updated — added import and renderTypeConfig case for knowledge_retrieval node type)
- **Learnings for future iterations:**
  - Knowledge Retrieval config follows same pattern as other node configs: data prop + onChange callback, shared style constants
  - Knowledge base dropdown gracefully handles missing /api/knowledge-bases endpoint — shows "No knowledge bases available" with helpful hint
  - Validation uses `touched` state to avoid showing errors before user interaction — set on first dropdown change
  - Error state uses separate `errorSelectStyle` with `borderColor: coral` override on the select style object
  - Sliders use `accent-color` CSS property (via inline style `accentColor`) for the coral theme — works in modern browsers
  - Info box at the bottom shows dynamic parameter values (top-k count and threshold) to help users understand their config
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 - US-051
- What was implemented: Edge connections with typed, color-coded handles for workflow canvas nodes
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/handleTypes.ts (new — HandleDataType, HANDLE_COLORS, HandleSpec, getHandlesForNodeType with per-node-type handle maps)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (new — custom React Flow node with color-coded input/output handles and labels)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — registered workflow nodeType, typed BezierEdge, handle color lookup, migration for saved workflows)
- **Learnings for future iterations:**
  - Custom node types in React Flow: define outside component, register via `nodeTypes` prop on `<ReactFlow>`; same for `edgeTypes`
  - BezierEdge from @xyflow/react can be wrapped to inject custom stroke color via style prop
  - Handle positioning: use percentage `top` values on the Handle `style` prop; distribute evenly from 45%-90% for multi-handle nodes
  - When loading saved workflows, migrate `type: "default"` nodes to `type: "workflow"` and add edge color data to avoid breaking older saves
  - Handle type definitions are static per nodeType — no need to store in DB; computed at render time from `getHandlesForNodeType()`
  - Conditional nodes have special handles: `output-true` and `output-false` with labels "True"/"False"
- Edge type validation: `areTypesCompatible()` in handleTypes.ts — "any" matches everything, otherwise types must match exactly
- Custom SVG edges: use `getBezierPath()` + `<path>` elements (not `<BezierEdge>`) when needing hover labels or animation overlays
- CSS injection pattern: `document.createElement('style')` with ID guard at module level for React island CSS that can't go through Astro's build
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 23:36 - US-052
- What was implemented: Edge type validation, animated edges, hover labels, and conditional branch colors
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/handleTypes.ts (added `areTypesCompatible()` function and `BRANCH_COLORS` constant)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (replaced BezierEdge with custom SVG edge: type-aware `isValidConnection`, animated dashed overlay, hover label with data type, CSS keyframe injection)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (added `getHandleColor()` helper for branch-colored conditional handles)
- **Learnings for future iterations:**
  - `getBezierPath()` from @xyflow/react returns `[edgePath, labelX, labelY]` — use for custom SVG edge rendering with hover labels
  - ReactFlow `isValidConnection` callback receives `Edge | Connection` — use it to prevent incompatible handle type connections
  - For edge hover detection, layer a transparent wide stroke (16px) path behind the visible edge
  - CSS keyframe animations can be injected via `document.createElement('style')` at module load time with an ID guard to prevent duplicates
  - Conditional node handles use `BRANCH_COLORS` (green/red) distinct from data-type colors — check `h.label` for "True"/"False" to select
  - `foreignObject` in SVG allows React-rendered HTML labels on edges; use `pointerEvents: "none"` to prevent blocking mouse events
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 - US-053
- What was implemented: Completed workflow REST API — added `version` column migration, export endpoint (POST /:id/export with Content-Disposition), and import endpoint (POST /import with JSON validation)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/013_add_workflow_version.sql (new — ALTER TABLE adds version column)
  - packages/orbiter-web/src/orbiter_web/routes/workflows.py (added WorkflowImport model, version field to WorkflowResponse, export/import endpoints, moved /import before /{workflow_id} routes)
- **Learnings for future iterations:**
  - FastAPI route order matters: static paths like `/import` must be defined before parameterized paths like `/{workflow_id}` to avoid capture
  - Export endpoint uses JSONResponse with Content-Disposition header for downloadable JSON
  - Import endpoint validates JSON fields (nodes_json, edges_json, viewport_json) with json.loads before insertion
  - The existing CRUD (list, create, get, update, delete) was already in place from earlier canvas work — only export/import and version column were missing
---

## 2026-02-16 - US-054
- What was implemented: Workflow auto-save with 2s debounce, save status indicator (Saved/Saving.../Unsaved changes), manual save via Cmd+S shortcut and toolbar Save button, editable workflow metadata header (name + description)
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — useAutoSave hook with SaveStatus tracking + saveNow(), save button + status indicator in toolbar, Cmd+S keyboard shortcut, metadata header with inline editing, saveMetadata debounced callback)
- **Learnings for future iterations:**
  - SaveStatus type tracks three states: "saved", "saving", "unsaved" — set "unsaved" on scheduleSave, "saving" on fetch start, "saved"/"unsaved" based on response
  - `saveNow()` flushes pending debounce timer and calls save immediately — used by Cmd+S and toolbar button
  - Metadata header sits above ReactFlow in a flex column layout — must wrap ReactFlow in a `flex: 1; min-height: 0` div to prevent overflow
  - Metadata editing uses click-to-toggle between display and input mode; saves with 800ms debounce separate from canvas auto-save
  - Save status color coding: green for saved, muted for saving, coral for unsaved — matches zen design tokens
  - Changed auto-save debounce from 500ms to 2000ms per acceptance criteria
---

## 2026-02-16 - US-055
- What was implemented: Workflow list page at /workflows with card grid, status badges, node counts, last run timestamps; export button on each workflow card (list page) and in canvas toolbar (detail page); import button with file picker, schema validation, and project selector modal; duplicate workflow action via POST /api/workflows/:id/duplicate endpoint
- Files changed:
  - packages/orbiter-web/src/pages/workflows/index.astro (new — workflow list page with grid/list views, search, status filter, import modal, duplicate modal, export action)
  - packages/orbiter-web/src/orbiter_web/routes/workflows.py (added POST /:id/duplicate endpoint with "(Copy)" suffix)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (added export icon + export button in toolbar, exportWorkflow callback)
- **Learnings for future iterations:**
  - Workflow list follows same patterns as applications.astro: `<template>` + `cloneNode(true)`, view toggle persisted in localStorage, project name enrichment via second fetch
  - Node count parsed client-side from `nodes_json` via `JSON.parse()` — no need for a separate DB column
  - Export on list page uses POST /api/workflows/:id/export (returns JSON), then constructs Blob + download link client-side
  - Import flow: file picker → FileReader → validate JSON has nodes_json/edges_json → show preview → select project → POST /api/workflows/import
  - Duplicate endpoint follows applications pattern: copy all fields except id/timestamps, append "(Copy)" to name
  - Canvas toolbar export button added alongside save — uses same icons object pattern
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-16 - US-056
- What was implemented: Relationships mode for workflow canvas — Shift+click a node to highlight its data flow graph with upstream (zen-blue) and downstream (zen-green) tinting, coral accent on the selected root node, and 20% opacity fade on unrelated nodes/edges
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (added relationships-mode CSS, relationshipNodeId state, computeRelationships BFS helper, displayNodes/displayEdges memos with className injection, Shift+click handler, pane click exits mode)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (added _relTint data prop, tint-aware border and box-shadow rendering for root/upstream/downstream nodes)
- **Learnings for future iterations:**
  - ReactFlow applies `className` from node/edge data to the wrapper DOM elements — use `.react-flow__node.rel-highlighted` CSS to override parent opacity
  - BFS traversal on edges needs two passes: one following edges backward (target→source) for upstream, one forward (source→target) for downstream
  - `useMemo` for displayNodes/displayEdges avoids re-computing on every render; depends on `[nodes, relationships, relationshipNodeId]`
  - Shift+click detection via `_event.shiftKey` in onNodeClick — toggling same node exits relationships mode
  - CSS `opacity` transitions on `.react-flow__node` and `.react-flow__edge` give smooth fade effect when entering/exiting relationships mode
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 00:00 - US-057
- What was implemented: Canvas real-time validation — validation engine (missing config, disconnected inputs, cycle detection, unreachable nodes), visual decorations on WorkflowNode (yellow warning badge, red dots on disconnected handles, dashed border for unreachable), validation summary panel with click-to-navigate, toolbar toggle button with issue count badge
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/validation.ts (new — validateWorkflow(), cycle detection via DFS, reachability from triggers via BFS, disconnected input detection, missing config checks)
  - packages/orbiter-web/src/islands/Canvas/ValidationPanel.tsx (new — collapsible bottom-left panel with issue list, severity icons, click-to-navigate via fitView)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (updated — added _missingConfig, _unreachable, _disconnectedInputs data props; yellow "!" badge top-right, red dot + glow on disconnected handles, dashed border for unreachable)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — imported validation + panel, 1s debounced validation via useEffect, injected validation decorations into displayNodes/displayEdges, cycle-edge CSS class, validation toolbar button with count badge, navigateToNode callback)
- **Learnings for future iterations:**
  - Validation data injected into node.data via `_` prefixed props (_missingConfig, _unreachable, _disconnectedInputs) — same pattern as _relTint for relationships mode
  - Cycle detection uses DFS with white/gray/black coloring — gray → gray back edge means cycle; trace path edges for full cycle marking
  - Unreachable nodes determined by BFS forward from trigger types (chat_input, webhook, schedule, manual) — nodes not reached get dashed border
  - `fitView({ nodes: [{ id }], padding: 0.5, duration: 400 })` centers viewport on a specific node — used for click-to-navigate from validation panel
  - Validation result stored as React state and injected into displayNodes/displayEdges useMemo — no extra renders needed
  - CSS class `.cycle-edge` with `stroke: #ef4444 !important` overrides edge color for cycle edges
  - Validation panel uses absolute positioning inside ReactFlow (like NodeSidebar) with `className="nodrag nopan nowheel"`
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 01:00 - US-058
- What was implemented: Chat WebSocket endpoint at ws://api/playground/{agent_id}/chat with streaming token delivery for OpenAI, Anthropic, Gemini, and Ollama providers
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (new — WebSocket endpoint with auth via session cookie, agent loading, provider/key resolution, per-provider streaming functions)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered playground_router)
- **Learnings for future iterations:**
  - WebSocket auth: FastAPI WebSocket doesn't use `Depends()` — manually extract session cookie via `websocket.cookies.get("orbiter_session")` and validate before `websocket.accept()`
  - Close with custom codes (4001 for auth, 4004 for not found) before accept to cleanly reject unauthorized connections
  - httpx streaming: use `client.stream("POST", url, json=body)` + `resp.aiter_lines()` for SSE parsing from provider APIs
  - Ruff SIM117: combine nested `async with` statements into single `async with A as a, B as b:` form
  - OpenAI SSE: lines prefixed with `data: `, terminal `data: [DONE]`; chunks have `choices[0].delta.content`
  - Anthropic SSE: `content_block_delta` events with `delta.text`, `message_start` for input tokens, `message_delta` for output tokens
  - Gemini SSE: use `?alt=sse` query param for SSE mode; chunks have `candidates[0].content.parts[].text` and `usageMetadata`
  - Ollama streaming: NDJSON (not SSE) — parse each line as JSON, content in `message.content`, final chunk has `done: true` with eval counts
  - Conversation history maintained in-memory per WebSocket connection; future stories (US-061) will persist to DB
  - Provider lookup: agent stores `model_provider` as type string (e.g., "openai"), need `_find_provider_by_type()` to resolve to provider_id
---

## 2026-02-17 - US-059
- What was implemented: Full-screen chat playground interface at /playground — agent selector dropdown, streaming chat via WebSocket, message bubbles with user (right-aligned, bg-subtle) and agent (left-aligned with avatar), token-by-token display, auto-resize textarea, clear conversation button, connection status feedback
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (new — full chat playground page with agent selector, message rendering, WebSocket management, auto-resize input)
  - packages/orbiter-web/astro.config.mjs (added ws: true to Vite proxy config for WebSocket support)
- **Learnings for future iterations:**
  - Vite proxy needs `ws: true` to forward WebSocket connections — without it, only HTTP /api requests are proxied
  - WebSocket URL construction: use `location.protocol === "https:" ? "wss:" : "ws:"` + `location.host` for protocol-agnostic URLs
  - Streaming chat pattern: start agent message bubble on send, append tokens to it, finalize on "done" message; track state with `isStreaming` flag
  - Auto-resize textarea: set `height: auto` first, then `height = Math.min(scrollHeight, maxHeight)` on every input event
  - `is:inline` script with `define:vars` for passing icon HTML from frontmatter to JS (botIconHtml, userIconHtml)
  - Clear conversation reconnects WebSocket to reset server-side in-memory conversation history
  - Disable input + send button during streaming to prevent overlapping requests
  - Token usage displayed as small metadata below agent messages when provided by the "done" WebSocket event
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-060
- What was implemented: Chat message features — markdown rendering in agent responses (via `marked` library), copy message button on hover for all messages, scroll-to-bottom button when user scrolls up, improved auto-scroll behavior
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (rewritten — switched from `is:inline` to module `<script>` for `marked` import, added markdown rendering on stream finish, copy buttons with clipboard API, scroll-to-bottom button, improved scroll tracking)
  - packages/orbiter-web/src/styles/global.css (added `.chat-prose` styles for markdown — headings, code blocks, lists, tables, blockquotes, links, hr)
  - packages/orbiter-web/package.json (added `marked` dependency)
- **Learnings for future iterations:**
  - Markdown rendered only on stream finish (not during streaming) for performance — `textContent` during streaming, `innerHTML` with `marked.parse()` on finishStream
  - Switched from `is:inline define:vars` to module `<script>` to enable npm imports — icons are now inline HTML strings in the script instead of passed via `define:vars`
  - `.chat-prose` class resets whitespace-pre-wrap and applies prose-like styles; Tailwind v4 doesn't include `@tailwindcss/typography`, so custom prose styles needed
  - Copy button uses `navigator.clipboard.writeText()` with check icon feedback; positioned absolute within `group` container for hover reveal
  - Scroll-to-bottom button: track `userScrolledUp` boolean, show button when not near bottom (80px threshold), reset on send/clear
  - Messages area wrapped in `relative flex-1` container with `absolute inset-0` inner div to properly contain overflow — fixes scroll area sizing
  - `marked` library is ~7KB gzipped, lightweight enough for playground use; configured with `breaks: true` and `gfm: true`
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 00:30 - US-061
- What was implemented: Conversation persistence — messages saved to DB after each exchange, conversations can be loaded to restore full chat history
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/014_create_conversations.sql (new — conversations + messages tables with indexes)
  - packages/orbiter-web/src/orbiter_web/routes/conversations.py (new — REST API for listing, getting, deleting conversations and listing messages)
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (updated — persistence helpers, _TokenCollector wrapper, save messages during chat)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — register conversations_router)
  - packages/orbiter-web/src/pages/playground.astro (updated — handle conversation_created/loaded events, restoreMessages, addRestoredAgentMessage)
- **Learnings for future iterations:**
  - _TokenCollector pattern: wraps WebSocket to intercept send_json calls and collect streamed tokens without modifying all 4 provider streaming functions
  - Conversation is created lazily on first real message (not on WebSocket connect) to avoid empty conversations
  - System prompt is saved as first message in conversation to ensure full history reconstruction
  - `load_conversation` is sent as a special message type after WebSocket open, before regular chat messages
  - `conversation_loaded` response includes full messages array for client-side rendering
  - ruff format reformats `async with` statements to use parenthesized context managers
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 00:30 - US-062
- What was implemented: Collapsible trace panel shell in the playground page
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (added trace panel HTML, toggle logic, Cmd+I shortcut, expandable trace entries)
- **Learnings for future iterations:**
  - Trace panel uses flex layout alongside chat column — `flex flex-1 min-h-0` wrapper with `min-w-0` on chat column for proper flex shrinking
  - Panel toggle: `hidden` class + state variable; button highlights with `text-coral` when panel is open
  - Cmd+I / Ctrl+I shortcut: listen on `document`, use `e.metaKey || e.ctrlKey` for cross-platform
  - TraceEntry interface stores id, timestamp, usage, and contentPreview (truncated to 120 chars)
  - Chevron expand/collapse pattern: swap innerHTML between CHEVRON_RIGHT and CHEVRON_DOWN SVGs
  - Trace entries are cleared when chat is cleared (via `clearTraceEntries()` in `clearMessages()`)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 00:31 - US-063
- What was implemented: Tool call, model call, and reasoning trace display in playground trace panel
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (enhanced all 4 streaming functions to send tool_call, reasoning events + enriched done event with model, finish_reason, latency_ms)
  - packages/orbiter-web/src/pages/playground.astro (revamped trace panel: collapsible model call section, tool calls with JSON args, reasoning section, finish reason badges, error display, latency tracking)
- **Learnings for future iterations:**
  - OpenAI tool call deltas accumulate across chunks — index-keyed dict pattern for reassembly
  - Anthropic content_block_start/stop lifecycle: tool_use blocks emit name on start, input_json_delta chunks accumulate, emit tool_call on block_stop
  - Anthropic thinking blocks: content_block_start type=thinking, thinking_delta deltas, emit reasoning event on block_stop
  - Gemini function calls arrive as `functionCall` parts within candidates
  - `stream_options: {"include_usage": true}` needed for OpenAI to send usage in streaming mode
  - `time.monotonic()` for latency — more reliable than `time.time()` for short durations
  - `makeCollapsibleSection()` helper creates reusable expand/collapse sections with icon + title + chevron toggle
  - Finish reason badge styles mapped via FINISH_REASON_STYLES dict — covers stop/end_turn/tool_calls/length/content_filter/SAFETY across providers
  - pendingToolCalls + pendingReasoning pattern: accumulate trace data from WS events between messages, consume on `done` event
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 01:00 - US-064
- What was implemented: Token usage and cost estimation in trace panel — per-message cost estimates, cumulative conversation token/cost summary, and /api/costs/pricing endpoint
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/costs.py (new — GET /api/costs/pricing returns model pricing data from models+providers tables)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered costs_router)
  - packages/orbiter-web/src/pages/playground.astro (enhanced — added pricing fetch, calcCost() helper, cumulative summary bar in trace panel header, per-message cost display in trace entries and below chat messages)
- **Learnings for future iterations:**
  - Pricing lookup matches model_name from the `done` WebSocket event against models table pricing_input/pricing_output ($/1K tokens)
  - Cost formatting: use 4 decimal places for <$0.01, 2 decimal places otherwise
  - Cumulative summary in trace panel header uses a grid layout for clean alignment (Total Tokens, In/Out, Est. Cost)
  - Cost badge shown in trace entry header alongside finish_reason badge — small rounded pill with tabular-nums
  - `resetCumulativeSummary()` called from `clearTraceEntries()` ensures totals reset when conversation is cleared
  - `loadPricing()` is non-critical — wrapped in try/catch with empty fallback so missing pricing degrades gracefully
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-065
- What was implemented: Multi-model comparison mode for the playground
  - Compare mode toggle button in playground header
  - Model picker bar with add/remove chip UI (2–4 models from /api/models)
  - New WebSocket endpoint `/api/playground/compare/chat` that accepts multiple model configs and streams responses in parallel via asyncio.gather, each tagged with `model_index`
  - Side-by-side response columns with per-column streaming, markdown rendering, and user/agent message bubbles
  - Per-model metrics footer: latency (ms), token counts (in/out), cost estimate
  - Thumbs up/down rating buttons per response column
  - JSON export button that downloads full comparison history with ratings
  - `_IndexedCollector` class wraps WebSocket to prefix all messages with `model_index`
  - `_stream_for_model()` helper dispatches to existing provider streaming functions
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (added compare endpoint + helpers)
  - packages/orbiter-web/src/pages/playground.astro (added compare mode UI + ~350 lines of JS)
- **Learnings for future iterations:**
  - Compare mode uses a separate WebSocket (`/api/playground/compare/chat`) rather than the agent-specific one — no agent required, models are passed directly in the message
  - `asyncio.gather(*tasks, return_exceptions=True)` streams all models in parallel through a single WebSocket; each message tagged with `model_index`
  - Astro frontmatter variables are NOT available inside `<script>` tags — need to re-declare SVG strings in the script section
  - Compare columns use `data-*` attributes for DOM queries (e.g., `data-response-area="0"`, `data-col-footer="1"`) — fast and clean for dynamic column management
  - Rating state stored in `compareHistory` array — persists across multiple prompt rounds within the same session
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-066
- What was implemented: Voice input (SpeechRecognition) and text-to-speech (SpeechSynthesis) for playground chat
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (added mic button, TTS toggle, voice/TTS JS logic ~130 lines)
  - packages/orbiter-web/src/styles/global.css (added pulseDot animation keyframes)
- **Learnings for future iterations:**
  - Web Speech API types (SpeechRecognition, SpeechRecognitionEvent, SpeechRecognitionErrorEvent) are not in Astro's default TS lib — use `any` types for event params
  - Access SpeechRecognition via `(window as any).SpeechRecognition || (window as any).webkitSpeechRecognition` for cross-browser support
  - interimResults=true shows live transcription as user speaks; final results fire on recognition.onend
  - TTS: strip markdown before speaking — regex chain handles code blocks, links, bold/italic, headers
  - speechSynthesis.cancel() before speaking prevents overlapping utterances
  - Mic button enable/disable must be synced with WS open/close events (same as messageInput and sendBtn)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-067
- What was implemented: Thread schema and REST API with migration and 6 endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/015_create_threads.sql (new — threads + thread_messages tables)
  - packages/orbiter-web/src/orbiter_web/routes/threads.py (new — ThreadCreate, ThreadResponse, ThreadMessageResponse models, 6 endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include threads_router)
- **Learnings for future iterations:**
  - Threads are separate from conversations — threads table has `first_message_preview`, `message_count`, `total_tokens`, `total_cost` metadata columns
  - Thread messages use `thread_messages` table (separate from conversations' `messages` table) — CASCADE delete on thread removal
  - Search endpoint (`/search`) must be defined BEFORE `/{thread_id}` route to avoid FastAPI matching "search" as a thread_id parameter
  - `Query(min_length=1)` and `Query(default=50, ge=1, le=200)` don't trigger ruff B008 (function call in default arg) — only `Depends()` does; don't add unnecessary `# noqa: B008` comments
  - Pagination pattern: use `limit` + `offset` query params with sensible defaults (50/0) and validation constraints
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 01:05 - US-068
- What was implemented: Thread sidebar UI for the playground page — toggleable left sidebar listing conversation threads, thread search, create/delete threads, thread metadata bar, delete confirmation dialog
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (updated — added thread sidebar HTML, thread toggle button, metadata bar, delete dialog, and ~270 lines of thread management JavaScript)
- **Learnings for future iterations:**
  - Thread sidebar integrates with existing thread REST API (GET /api/threads, POST /api/threads, DELETE /api/threads/:id, GET /api/threads/:id/messages, GET /api/threads/search)
  - Thread sidebar is toggled via "Threads" button in top bar — hidden by default, loads threads when opened
  - Thread list re-renders on agent change (when sidebar is open) and uses debounced search input (300ms)
  - Delete confirmation uses native `<dialog>` element with `.showModal()` — consistent with HTML5 dialog pattern, no external modal library needed
  - `formatRelativeTime()` handles UTC dates from server by appending "Z" to the date string
  - Thread items show hover-visible delete button using Tailwind group-hover pattern (`opacity-0 group-hover:opacity-100`)
  - When switching to a thread, messages are loaded via REST API and rendered using existing `addUserMessage`/`addRestoredAgentMessage` helpers
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 01:15 - US-069
- What was implemented: Workflow execution engine backend with topological sort DAG runner, REST endpoints, and WebSocket streaming
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/016_create_workflow_runs.sql (new — workflow_runs + workflow_run_logs tables)
  - packages/orbiter-web/src/orbiter_web/engine.py (new — topological_sort, execute_workflow, cancel_run, _execute_node stub)
  - packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py (new — POST /:id/run, DELETE /:id/runs/:runId, WS /:id/runs/:runId/stream)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered workflow_runs_router)
- **Learnings for future iterations:**
  - Workflow execution uses Kahn's algorithm for topological sort, grouping nodes into layers for parallel execution within each layer
  - Engine uses `asyncio.Event` for cooperative cancellation — checked between layers
  - Background tasks from `asyncio.create_task` must be stored in a set to prevent garbage collection (ruff RUF006)
  - WebSocket endpoint has two modes: if run is "pending" it starts execution with a callback, if already "running" it falls back to DB polling (0.3s interval)
  - Node execution is stubbed (`_execute_node`) — returns simulated output; real implementations will be added in future stories
  - `contextlib.suppress(Exception)` is preferred over `try/except pass` (ruff SIM105)
  - `workflow_runs_router` registered before `workflows_router` in app.py since both share `/api/workflows` prefix — more specific paths matched first
---

## 2026-02-17 01:15 - US-070
- What was implemented: Workflow execution visualization — real-time canvas feedback during workflow runs
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (execution state hook, WebSocket connection, toolbar play/stop buttons, execution status bar, edge animation, CSS pulse animation)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (execution status badges: green checkmark overlay for completed, red X for failed, coral pulsing border for running nodes)
- **Learnings for future iterations:**
  - `useWorkflowExecution` hook manages full lifecycle: POST to start run → WebSocket for live events → cancel via DELETE
  - Execution node statuses are injected via `_execStatus` data prop (same pattern as `_relTint`, `_missingConfig` etc.)
  - Edge animation between completed→running nodes uses the existing `animated` data prop on TypedBezierEdge
  - CSS `exec-running` class with `execPulse` keyframe animation is applied via `className` on the ReactFlow node wrapper (not inline styles)
  - Execution status bar uses ReactFlow `<Panel position="bottom-center">` — same pattern as toolbar and validation panel
  - WebSocket URL constructed from `window.location.protocol` + `window.location.host` to support both http/https
  - Elapsed timer uses `setInterval` with 1s tick — cleaned up on unmount and on run completion
  - Missing config badge is hidden during execution to avoid overlap with execution status badges
---

## 2026-02-17 - US-071
- What was implemented: Node inspection backend — per-node execution data storage and retrieval API
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/017_add_node_execution_fields.sql (new — adds input_json, logs_text, token_usage_json to workflow_run_logs)
  - packages/orbiter-web/src/orbiter_web/engine.py (updated — _execute_node captures type-specific logs/token_usage; engine stores input_json, logs_text, token_usage_json in DB)
  - packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py (updated — new GET /{workflow_id}/runs/{run_id}/nodes/{node_id} endpoint)
  - prd.json (updated — US-071 passes: true)
- **Learnings for future iterations:**
  - workflow_run_logs table serves as the node_executions table — extended with ALTER TABLE rather than creating a new table
  - _execute_node returns optional `logs` and `token_usage` keys — engine pops these before storing output_json, stores them in separate columns
  - Node input is captured from node.data at execution start (input_json column)
  - JSON fields (input_json, output_json, token_usage_json) are parsed in the API response for convenience
  - LLM nodes store prompt+response in logs_text; Code nodes store stdout/stderr; API nodes store request/response
---

## 2026-02-17 01:30 - US-072
- What was implemented: Node inspection UI — clicking a node after workflow execution opens a tabbed inspection panel showing Input, Output, Logs, and Timing data
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/NodeInspectionPanel.tsx (new — tabbed panel with Input, Output, Logs, Timing tabs; fetches from GET /api/workflows/:id/runs/:runId/nodes/:nodeId)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — imports NodeInspectionPanel, adds inspectedNodeId state, shows inspection panel when clicking executed nodes, hasExecutionData flag)
  - prd.json (updated — US-072 passes: true)
- **Learnings for future iterations:**
  - Post-execution node clicks use `exec.nodeStatuses[node.id]` to determine if a node has execution data — only executed nodes open the inspection panel
  - `hasExecutionData` flag = `exec.runId !== null && !isRunning` — ensures panel only shows after execution completes
  - Inspection panel is 340px wide (slightly wider than config panel's 300px) to accommodate JSON blocks
  - JsonBlock component includes copy-to-clipboard button and uses pre+monospace for formatted JSON display
  - Tabs use the node's category color for the active tab underline indicator
  - InputTab/OutputTab/LogsTab/TimingTab handle null data gracefully with italic placeholder text
  - For LLM nodes, LogsTab shows prompt and response separately extracted from input_json/output_json
  - inspectedNodeId and selectedNodeId are mutually exclusive — clicking an executed node sets inspected and clears selected, and vice versa
---

## 2026-02-17 - US-073
- What was implemented: Step-through debug execution backend — debug mode pauses before each node, accepts WebSocket commands for stepping
- Files changed:
  - packages/orbiter-web/src/orbiter_web/engine.py (added execute_workflow_debug, register_debug_session, unregister_debug_session, send_debug_command, _wait_for_debug_command)
  - packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py (added POST /{workflow_id}/debug endpoint, WebSocket /{workflow_id}/runs/{run_id}/debug endpoint)
  - prd.json (updated — US-073 passes: true)
- **Learnings for future iterations:**
  - Debug mode flattens topological layers into a sequential execution order — nodes execute one at a time instead of parallel within layers
  - Command queue pattern: asyncio.Queue bridges WebSocket commands to the engine loop; _wait_for_debug_command processes side-effect commands (set_breakpoint, set_variable) inline while waiting for flow-control commands (continue, skip, stop)
  - Debug WebSocket runs two concurrent loops: _send_events (engine→client) and _receive_commands (client→engine); uses asyncio.wait(FIRST_COMPLETED) to cancel the other when either finishes
  - Variables dict tracks per-node output (keyed by node_id) — sent with debug_paused and node_completed events for client-side inspection
  - Breakpoints stored as a set[str] of node_ids — toggled via set_breakpoint command (currently pauses at every node; UI story US-074 will add selective breakpoint-only pausing)
  - POST /debug creates the run record and registers the command queue, but doesn't start execution — the WebSocket connection triggers execution start
  - On client disconnect, a "stop" command is sent to the engine to cleanly abort the debug run
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-074
- What was implemented: Step-through debug UI — complete frontend for debug mode workflow execution
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (added useDebugExecution hook, DebugVariablePanel component, debug CSS animations, debug icon, debug toolbar button, debug control bar with Continue/Skip/Stop, wired debug state into displayNodes/displayEdges, Alt+click breakpoint toggle)
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (added _debugPaused and _hasBreakpoint data props, purple pulsing border for paused node, red dot breakpoint indicator, paused badge)
  - prd.json (updated — US-074 passes: true)
- **Learnings for future iterations:**
  - Debug state is separate from execution state (useDebugExecution vs useWorkflowExecution) — they share similar patterns but debug adds paused state, variables, breakpoints
  - Debug paused nodes use purple (#a855f7) visual treatment to distinguish from coral running state
  - Breakpoint indicator: red dot at top-left corner of node (position: absolute, left: -6, top: -6)
  - Variable panel uses click-to-edit pattern: click value → input field appears, Enter commits, Escape cancels
  - Variables are keyed by node_id — map to node labels via nodeLabels lookup for display
  - Alt+click toggles breakpoints on nodes during debug mode (Shift+click already used for relationships mode)
  - Debug control bar replaces normal execution status bar via conditional Panel rendering at bottom-center
  - Copy-to-clipboard button on each variable value for quick debugging
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-075
- What was implemented: Single-node execution — right-click context menu on canvas nodes with "Run This Node" option, mock input panel (editable JSON), backend endpoint for isolated node execution, inspection panel integration for results
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/engine.py` — added `execute_single_node()` function
  - `packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py` — added POST `/api/workflows/:id/nodes/:nodeId/run` endpoint
  - `packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx` — added context menu state/handler, `onNodeContextMenu`, `executeSingleNode` callback, `NodeContextMenu` component, `MockInputPanel` component, updated inspection panel to show single-node run results
- **Learnings for future iterations:**
  - ReactFlow supports `onNodeContextMenu` prop for right-click handling on nodes — same signature as `onNodeClick`
  - Context menu must be `position: fixed` (not absolute) since it uses clientX/clientY coordinates from the mouse event
  - Single-node runs create a full `workflow_runs` + `workflow_run_logs` record pair, so the existing inspection panel can fetch data via the same GET endpoint
  - The `singleRunResult` state tracks the run_id separately from the full-workflow exec state — the inspection panel picks whichever run_id matches the inspected node
  - Mock input panel pre-populates with the node's current data (minus `_` prefixed internal props) for convenience
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 - US-076
- What was implemented: Variable inspect panel — comprehensive bottom-of-canvas collapsible panel for viewing workflow variables, with table view (name, value, type, source node), filtering, real-time WebSocket updates, node navigation, and clipboard copy
- Files changed:
  - `packages/orbiter-web/src/islands/Canvas/VariableInspectPanel.tsx` — new component with table view, node/type filters, edit-in-debug-mode, copy-to-clipboard, type badges, and navigate-to-node buttons
  - `packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx` — replaced old inline DebugVariablePanel with new VariableInspectPanel, added `variablePanelOpen` state, Cmd+J keyboard shortcut, toolbar button, variables tracking in ExecutionState, and Panel rendering for both exec and debug modes
  - `packages/orbiter-web/src/orbiter_web/engine.py` — added `variables` dict tracking to normal (non-debug) execution path, emit variables in node_completed and execution_completed events
- **Learnings for future iterations:**
  - Normal execution (execute_workflow) didn't previously emit variables — only debug execution did. Added a parallel `variables` dict to match the debug execution pattern.
  - The variable panel works across both normal execution and debug mode — in debug mode, editing is enabled; in normal mode, it's read-only
  - `navigator.platform` is deprecated — use `navigator.userAgent.includes("Mac")` instead for platform detection
  - React Flow `<Panel position="bottom-center">` can stack multiple panels — use `marginBottom` to space them relative to status/debug bars
  - Type detection uses typeof + Array.isArray for determining variable types (string, number, boolean, array, object, null)
  - Manual browser verification needed (no browser testing tool available)
---

## 2026-02-17 02:05 - US-077
- What was implemented: Run history schema and REST API
  - Migration 018: added trigger_type, input_json, step_count, total_tokens, total_cost columns to workflow_runs
  - GET /api/workflows/:id/runs — paginated list with filters (status, trigger_type, start_date, end_date)
  - GET /api/workflows/:id/runs/:runId — full run detail with all node_executions (JSON fields auto-parsed)
  - Engine updated: _compute_run_aggregates() calculates step_count and total_tokens from workflow_run_logs on run completion
  - Both execute_workflow and execute_workflow_debug now populate aggregate fields at finalization
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/018_extend_workflow_runs.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py (added 2 GET endpoints + Query import)
  - packages/orbiter-web/src/orbiter_web/engine.py (added _compute_run_aggregates, extended _update_run_status)
- **Learnings for future iterations:**
  - Run-level aggregates (step_count, total_tokens, total_cost) are computed from workflow_run_logs at finalization time via _compute_run_aggregates()
  - token_usage_json in workflow_run_logs contains {prompt_tokens, completion_tokens, total_tokens} — aggregate total_tokens across all nodes
  - Route ordering: GET /{workflow_id}/runs must be defined BEFORE any /{workflow_id}/runs/{run_id} routes to avoid path conflicts in FastAPI
  - The Query import from fastapi is used for list endpoints with pagination params (limit, offset, ge/le constraints)
---

## 2026-02-17 - US-078
- What was implemented: Run history UI and replay panel for workflow canvas
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/RunHistoryPanel.tsx (new — complete run history panel with list, detail, comparison, replay)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (updated — integrated RunHistoryPanel, added history icon, Cmd+H shortcut, history node coloring, past run overlay indicator)
- **Learnings for future iterations:**
  - RunHistoryPanel uses the existing GET /api/workflows/:id/runs endpoint with filters (status, trigger_type, date range)
  - Run detail uses GET /api/workflows/:id/runs/:runId which includes node_executions array
  - History node coloring: store historyNodeStatuses state and fall back to it in displayNodes when no active exec/debug
  - Comparison mode: select two runs, fetch both details, side-by-side diff grouped by node_id, highlight differences
  - Replay: for "same inputs" calls startRun(); "modified inputs" opens a JSON editor modal
  - History overlay: a blue bottom-center panel indicates when viewing a past run, with dismiss button
  - Cmd+H keyboard shortcut toggles history panel visibility
---

## 2026-02-17 - US-079
- Implemented tools schema and REST API
- Created `019_create_tools.sql` migration: tools table with id, name, description, category (search/code/file/data/communication/custom), schema_json, code, tool_type (function/http/schema/mcp), usage_count, project_id, user_id, created_at
- Rewrote `routes/tools.py` from static built-in catalog to full DB-backed CRUD
- Endpoints: GET /api/tools (with category + project_id filters), POST /api/tools, GET /api/tools/:id, PUT /api/tools/:id, DELETE /api/tools/:id
- Files changed: `orbiter_web/migrations/019_create_tools.sql`, `orbiter_web/routes/tools.py`
- **Learnings for future iterations:**
  - The old tools.py was a static built-in catalog — now replaced with DB-backed CRUD following the same patterns as agents.py
  - Agent edit page and AgentNodeConfig.tsx both fetch /api/tools — they'll now get user-defined tools (empty initially); built-in tools were just placeholders
  - CHECK constraints in SQLite enforce category and tool_type enums at the DB level
---

## 2026-02-17 02:20 - US-080
- What was implemented: Tools page UI with grid/list view toggle, search, category filter, tool detail page with JSON schema viewer, parameter descriptions, and "Add to Agent" modal
- Files changed:
  - packages/orbiter-web/src/pages/tools/index.astro (new — tools listing page)
  - packages/orbiter-web/src/pages/tools/[id].astro (new — tool detail page)
  - prd.json (updated — US-080 passes: true)
- **Learnings for future iterations:**
  - Tools pages use directory-based routing: `tools/index.astro` for listing, `tools/[id].astro` for detail
  - Category metadata (icons, colors) stored as JS object in inline script — shared across index and detail pages
  - `define:vars={{ id }}` passes Astro.params.id into inline scripts for dynamic route pages
  - Schema parameter extraction: check both `schema.properties` and `schema.parameters.properties` for JSON Schema compat
  - "Add to Agent" pattern: fetch agents, parse `tools_json` array, push tool ID, PUT back to agent endpoint
  - Grid/list view toggle state persisted in localStorage (`tools-view` key)
---

## 2026-02-17 - US-081
- What was implemented: Custom tool creation backend with AST-based parameter extraction and schema generation
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/tools.py (added POST /api/tools/custom, PUT /api/tools/custom/:id, POST /api/tools/custom/:id/test, POST /api/tools/schema endpoints)
  - prd.json (updated — US-081 passes: true)
- **Learnings for future iterations:**
  - Custom tool routes must be defined BEFORE `/{tool_id}` param routes to prevent "custom" matching as a tool_id (FastAPI route ordering)
  - AST-based parameter extraction: use `ast.parse()` + `ast.walk()` to find functions, `ast.get_docstring()` for docs, `func_node.args` for parameters
  - Default value alignment in AST: defaults are right-aligned — last N defaults match last N args; compute `default_index = arg_index - (num_args - num_defaults)`
  - Google-style docstring parsing: look for "Args:" section, parse "param_name: description" or "param_name (type): description" patterns
  - Tool execution sandbox: build restricted namespace removing dangerous builtins (exec, eval, compile, __import__, open), provide no-op @tool decorator
  - `__builtins__` type varies between modules (dict in __main__, module elsewhere) — handle both with isinstance check
  - Schema generation endpoint (`POST /api/tools/schema`) is useful for live preview without saving to DB
---

## 2026-02-17 02:30 - US-082
- What was implemented: Custom tool creation UI at /tools/new
  - Full page with monospace code editor (dark theme, line numbers, tab key support)
  - Pre-filled Python template with `from orbiter.tool import tool` + `@tool` decorator pattern
  - Auto-analysis: debounced (1s) schema extraction via POST /api/tools/schema
  - Parameter table auto-populated from function signature analysis
  - JSON Schema preview panel with syntax highlighting
  - Test Tool button: saves tool first, then POSTs to /api/tools/custom/{id}/test with typed inputs
  - Test result panel showing success/error with traceback
  - Save button: creates via POST /api/tools/custom, updates via PUT /api/tools/custom/{id}
  - Project selector dropdown (loads from GET /api/projects)
  - "Create Tool" button added to tools index page header
- Files changed:
  - packages/orbiter-web/src/pages/tools/new.astro (created, ~560 lines)
  - packages/orbiter-web/src/pages/tools/index.astro (added Button import, plus icon, Create Tool link)
- **Learnings for future iterations:**
  - The backend already had all needed endpoints (POST /api/tools/schema, POST /api/tools/custom, PUT /api/tools/custom/{id}, POST /api/tools/custom/{id}/test) — always check routes/ before building API endpoints
  - Custom tool creation requires project_id — tools are scoped to projects
  - Use `is:inline` scripts for page-specific JS in Astro; IIFE pattern prevents global scope pollution
  - Line number sync: use translateY on scroll event for the line numbers div, synced to textarea.scrollTop
  - Tab key in textarea: must preventDefault and insert spaces manually
  - Manual browser verification needed (no dev-browser skill configured)
---

## 2026-02-17 08:10 - US-083
- What was implemented: Visual tool schema editor — a form-based UI to define tools by building their JSON schema visually, no code required
- Files changed:
  - `packages/orbiter-web/src/pages/tools/schema-editor.astro` (new — full schema editor page)
  - `packages/orbiter-web/src/orbiter_web/routes/tools.py` (added `POST /api/tools/schema/save` endpoint + VisualSchemaCreate model)
  - `packages/orbiter-web/src/pages/tools/index.astro` (added "Schema Editor" button)
- Features implemented:
  - Schema editor form: tool name, description, project selector, tool type (schema/HTTP)
  - Parameters list: add/remove with dynamic cards
  - Per parameter: name, type selector (string/integer/number/boolean/array/object), description, required toggle, default value
  - Nested object support: expandable sub-parameter forms when type=object
  - Enum support: comma-separated allowed values for string parameters
  - Live JSON schema preview panel with syntax highlighting
  - HTTP tool configuration: method dropdown, URL template, header key-value pairs, body template
  - OpenAPI import: paste JSON or URL to auto-generate tool definitions (resolves $ref, extracts params from requestBody)
  - POST /api/tools/schema/save to persist visually-built schemas
- **Learnings for future iterations:**
  - Astro interprets `{param}` in HTML as JS expressions — escape with `{"{"}<span>param</span>{"}"}` to render literal curly braces
  - `<template>` + `cloneNode(true)` pattern works well for dynamic form elements (parameter cards, header rows, nested params)
  - OpenAPI $ref resolution: walk `#/components/schemas/Name` path segments to resolve references
  - The existing `POST /api/tools` generic endpoint already handles `tool_type: "schema"`, but a dedicated `/schema/save` is cleaner for visual editor payloads
  - Manual browser verification needed (no dev-browser skill configured)
---

## 2026-02-17 - US-084
- What was implemented: Tool Mode toggle on workflow nodes — users can expose any node as an agent-callable tool
- Files changed:
  - packages/orbiter-web/src/islands/Canvas/WorkflowNode.tsx (added `tool_mode` to data interface, wrench icon badge)
  - packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx (added Tool Mode toggle switch between Node ID and config divider)
  - packages/orbiter-web/src/orbiter_web/routes/tools.py (added `GET /api/tools/workflow-nodes` endpoint, WorkflowNodeToolResponse model, _schema_from_node helper, server-side handle type map)
- **Learnings for future iterations:**
  - Tool Mode stored as `tool_mode: boolean` in node.data — no DB schema change needed since nodes_json is flexible JSON
  - Server-side handle type map (_NODE_HANDLE_MAP) mirrors handleTypes.ts — keep in sync when adding new node types
  - Toggle switch pattern: 36×20px button with absolutely-positioned circle, animate `left` for smooth sliding
  - Wrench badge positioned top-left, offset downward when breakpoint is present to avoid overlap
  - Workflow-node tools have composite IDs: `wfn_{workflow_id}_{node_id}` to ensure uniqueness
  - Manual browser verification needed (no dev-browser skill configured)
---

## 2026-02-17 - US-085
- What was implemented: Plugin manifest and isolation backend — plugins table migration, full REST API for plugin install/uninstall/list/load-from-directory, subprocess isolation for plugin validation
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/020_create_plugins.sql (new — plugins table with type/status CHECK constraints, indexes)
  - packages/orbiter-web/src/orbiter_web/routes/plugins.py (new — APIRouter with PluginManifest, install, uninstall, load-directory, status update endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include plugins_router)
- **Learnings for future iterations:**
  - Plugin manifest format: plugin.json with name, version, type, permissions, entry_point fields
  - Subprocess isolation: use asyncio.create_subprocess_exec with timeout for plugin validation — run `python entry_point --validate`
  - Duplicate check pattern: SELECT before INSERT with name+version+user_id to prevent reinstalling same plugin
  - Load-from-directory reads plugin.json from the directory and delegates to install_plugin — reuses validation logic
  - Status endpoint uses query param for status value (PUT /api/plugins/:id/status?status=enabled)
---

## 2026-02-17 08:25 - US-086
- What was implemented: Plugin marketplace UI — marketplace grid page at /plugins, plugin detail page at /plugins/[id], marketplace API endpoints, bundle type support
- Files changed:
  - packages/orbiter-web/src/pages/plugins/index.astro (new — marketplace grid with search, category filter, plugin cards showing name/author/description/installs/rating/category badge)
  - packages/orbiter-web/src/pages/plugins/[id].astro (new — plugin detail page with full description, screenshots placeholder, changelog, permissions required, one-click install button)
  - packages/orbiter-web/src/orbiter_web/routes/plugins.py (updated — added MARKETPLACE_CATALOG static catalog, GET /api/plugins/marketplace and GET /api/plugins/marketplace/:id endpoints, added 'bundle' to VALID_PLUGIN_TYPES)
  - packages/orbiter-web/src/orbiter_web/migrations/020_create_plugins.sql (updated — added 'bundle' to type CHECK constraint)
  - packages/orbiter-web/src/orbiter_web/migrations/021_add_plugin_bundle_type.sql (new — migration to add 'bundle' type for existing databases by recreating table)
- **Learnings for future iterations:**
  - Marketplace endpoints must be defined BEFORE /{plugin_id} routes in FastAPI (route ordering pattern) to prevent "marketplace" being matched as a plugin_id
  - Static marketplace catalog in MARKETPLACE_CATALOG constant — will be replaced with remote registry later
  - Plugin categories (Models, Tools, Agent Strategies, Extensions, Bundles) differ from DB types (model, tool, strategy, extension, bundle) — frontend uses human-readable category names
  - SQLite doesn't support ALTER TABLE to change CHECK constraints — must recreate table via INSERT INTO new, DROP old, ALTER RENAME
  - When moving a page from pages/foo.astro to pages/foo/index.astro (to support sub-routes like /foo/[id]), update import paths from `../` to `../../`
  - Install button calls POST /api/plugins/install with manifest from marketplace data — handles 409 (already installed) gracefully
---

## 2026-02-17 - US-087
- What was implemented: Plugin management UI with Installed tab on the plugins page
- Features:
  - Tab bar switching between "Marketplace" and "Installed" tabs
  - Installed plugins list with type icon, name, version, status dot (green=active, gray=disabled, red=error, blue=installed)
  - Enable/disable toggle per plugin (calls PUT /api/plugins/:id/status)
  - Uninstall button with confirmation modal (calls DELETE /api/plugins/:id)
  - "Load from Directory" button (visible on Installed tab) with modal for entering directory path
  - Installed count badge on tab
  - Search filtering works on both tabs
  - Category filter hidden on Installed tab (not needed)
  - Toast notifications for success/error feedback
  - "Browse Marketplace" button in empty installed state
- Files changed:
  - packages/orbiter-web/src/pages/plugins/index.astro (rewrote to add Installed tab alongside Marketplace tab)
- **Learnings for future iterations:**
  - Plugin type (model/tool/strategy/extension/bundle) maps to display category (Models/Tools/Agent Strategies/Extensions/Bundles) via `typeToCategoryMap`
  - Toggle switch pattern: use `translate-x-0.5` for off, `translate-x-5.5` for on; bg-zen-green for enabled, bg-dark/20 for disabled
  - Modal integration: import Modal.astro, use `.showModal()` to open, `data-modal-close` handles closing; works with multiple modals on same page
  - Tab bar pattern: use `span:last-child` for the active indicator line, toggle `opacity-0` for inactive
  - `fetchInstalled()` updates the badge count regardless of active tab, so badge is always current
---

## 2026-02-17 - US-088
- What was implemented: Agent hierarchy graph view page at `/agents/graph` using Xyflow ReactFlow
- Files changed:
  - packages/orbiter-web/src/islands/AgentGraph/AgentGraphIsland.tsx (new — React island with dagre auto-layout, custom AgentNode, custom AgentEdge, click-to-navigate)
  - packages/orbiter-web/src/pages/agents/graph.astro (new — Astro page wrapper with PageLayout)
  - packages/orbiter-web/package.json (added @dagrejs/dagre dependency)
- **Learnings for future iterations:**
  - `useNodesState<Node>([])` and `useEdgesState<Edge>([])` need explicit type params to avoid `never[]` inference in Astro strict mode
  - @dagrejs/dagre v2 includes TypeScript types in `dist/dagre.d.ts`
  - ReactFlow `client:only="react"` islands follow same pattern as CanvasIsland — wrap inner component with ReactFlowProvider
  - Handoffs stored as `{id, name, description}` in `handoffs_json` — id references the target agent
  - Delegation connections can be inferred from `_delegates_to` array in `hooks_json`
  - Custom edge types: use `getBezierPath` + foreignObject for labels; strokeDasharray for dashed edges
---

## 2026-02-17 - US-089
- What was implemented: Supervisor pattern backend — agent_relationships table + sub-agent delegation API
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/022_create_agent_relationships.sql (new — agent_relationships table with supervisor_id, sub_agent_id, relationship_type, routing_rule_json)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (updated — added SubAgentAdd/SubAgentRelationshipResponse models, _get_sub_agents/_build_sub_agent_tools/_build_sub_agent_prompt_section helpers, POST/GET/DELETE sub-agent endpoints, GET effective-config endpoint)
- **Learnings for future iterations:**
  - agent_relationships table uses UNIQUE(supervisor_id, sub_agent_id) to prevent duplicate delegation pairs
  - Sub-agent routes are nested under the agents router: `/api/agents/:id/sub-agents` — no separate router needed
  - Sub-agent tools are auto-generated with `type: "sub_agent"` and `delegate_to_{name}` naming convention
  - `effective-config` endpoint merges agent's own tools_json with generated sub-agent tool entries and appends sub-agent descriptions to instructions
  - Routing rules stored as JSON text, parsed on-demand — flexible schema for future expansion
---

## 2026-02-17 - US-090
- What was implemented: Supervisor wizard UI at /agents/new/supervisor — 3-step wizard for creating supervisor agents with sub-agent delegation
- Files changed:
  - packages/orbiter-web/src/pages/agents/new/supervisor.astro (new — 922 lines)
- Features implemented:
  - Step 1: Select existing agent or create new agent as supervisor
  - Step 2: Browse/search available agents, toggle selection for sub-agents, live selected list with remove
  - Visual hierarchy preview: supervisor node (coral) with connection lines to sub-agent nodes (blue)
  - Step 3: Review configuration with routing rules (optional text per sub-agent), final hierarchy preview
  - Create button: creates agent if new, adds sub-agent relationships via POST /api/agents/:id/sub-agents, updates hooks_json._delegates_to for graph view
  - Test in Playground button: opens playground with supervisor agent pre-selected
  - Step indicators with completion state (coral active, green completed)
  - Toast notifications for success/error/warning feedback
- **Learnings for future iterations:**
  - Multi-step wizard pattern: use step-panel divs with hidden class, step indicators with 3 states (pending/active/completed)
  - Supervisor sub-agent relationships stored in `agent_relationships` table, hooks_json._delegates_to tracks delegates for graph view
  - Delegation shows in playground as tool calls (delegate_to_<agent_name>), no special trace UI needed
  - agents/new/ directory is for wizard-style creation flows (vs [id]/edit.astro for editing)
  - CSS hierarchy preview: vertical lines + horizontal connector + branch items, no SVG/ReactFlow needed for simple tree viz
---

## 2026-02-17 - US-091
- What was implemented: Crew schema (migration 023) and full REST API for crew-based agent orchestration
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/023_create_crews.sql (new — crews + crew_tasks tables)
  - packages/orbiter-web/src/orbiter_web/routes/crews.py (new — full CRUD for crews and crew_tasks, plus POST /run execution)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — register crews_router)
- **Learnings for future iterations:**
  - Crew process_type is constrained via CHECK constraint in SQLite: `CHECK (process_type IN ('sequential', 'parallel'))`
  - Crew tasks use task_order for sequencing and dependencies_json for dependency tracking
  - Run endpoint: sequential mode chains outputs as context to subsequent tasks; parallel runs all at once via asyncio.gather
  - Pydantic Field(pattern=...) validates enum-like strings on the API layer
  - Import ordering: ruff I001 enforces strict alphabetical ordering for imports — crews comes before costs
---

## 2026-02-17 03:30 - US-154
- What was implemented: CLI command `python -m orbiter_web.cli create-user` for user registration
- Files changed:
  - packages/orbiter-web/src/orbiter_web/cli.py (new — argparse CLI with create-user subcommand)
  - packages/orbiter-web/src/orbiter_web/migrations/024_add_is_admin.sql (new — adds is_admin column)
- **Learnings for future iterations:**
  - CLI uses `asyncio.run()` to bridge sync argparse entry point with async aiosqlite database operations
  - Reuses bcrypt hashing same as auth.py (`bcrypt.hashpw` + `bcrypt.gensalt`)
  - Migration uses `ALTER TABLE ... ADD COLUMN` with `NOT NULL DEFAULT 0` — SQLite supports this form
  - CLI calls `run_migrations()` before inserting to ensure schema is up to date
  - `python -m orbiter_web.cli` works because of `if __name__ == "__main__": main()` guard
---

## 2026-02-17 - US-092
- What was implemented: Crew builder UI at /crews/new — full page for creating crews with agent task assignment
- Features:
  - Crew name, description, and project selector
  - Process type selector: sequential (tasks chain outputs) vs parallel (tasks run simultaneously)
  - Agent selector dropdown populated from /api/agents
  - Per-task expandable cards with task description, expected output format, and dependency selection
  - Drag-and-drop reorder for sequential mode (drag handles hidden in parallel mode)
  - Delegation toggle: allow agents to create sub-tasks for other crew members (stored in config_json)
  - Order badges, task count, empty state
  - Save flow: creates crew via POST /api/crews, then adds tasks via POST /api/crews/:id/tasks
  - Toast notifications for validation and success/error feedback
- Files changed:
  - packages/orbiter-web/src/pages/crews/new.astro (new — 630 lines)
- **Learnings for future iterations:**
  - Crew pages live under `src/pages/crews/` directory — new.astro for creation
  - Crew builder uses same patterns as supervisor wizard: PageLayout wrapper, inline SVG icons, IIFE script, toast notifications
  - Drag-and-drop with native HTML5 API: `draggable="true"`, dragstart/dragover/drop/dragend events; reorder by splice+insert
  - Dependencies UI: chip-toggle buttons for earlier tasks, stored as JSON array of task indices
  - Delegation stored as `{delegation_enabled: true/false}` in crew's config_json field
  - Process type radio buttons use `peer` + `peer-checked:` Tailwind pattern for styled card selectors
  - Sequential mode shows drag handles and dependency selectors; parallel mode hides both
  - Manual browser verification needed (no dev-browser skill configured)
---

## 2026-02-17 03:50 - US-155
- What was implemented: AgentService class that bridges database agent configs to live Orbiter Agent objects
- Files changed:
  - packages/orbiter-web/pyproject.toml (added orbiter-core, orbiter-models deps + uv.sources)
  - packages/orbiter-web/src/orbiter_web/services/__init__.py (new — service layer init)
  - packages/orbiter-web/src/orbiter_web/services/agent_runtime.py (new — AgentRuntimeError, AgentService with build_agent/run_agent/stream_agent, helpers for loading agent row, resolving provider + API key, resolving tools)
  - packages/orbiter-web/tests/__init__.py (new — test package init)
  - packages/orbiter-web/tests/test_agent_runtime.py (new — 14 unit tests with mocked DB and mocked model provider)
- **Learnings for future iterations:**
  - orbiter-web needs `[tool.uv.sources]` entries in its pyproject.toml for workspace deps (orbiter-core, orbiter-models)
  - Agent.run() requires a `provider` kwarg — pass an `orbiter.models.ModelProvider` instance
  - `get_provider("openai:gpt-4o", api_key=..., base_url=...)` is the factory for creating ModelProvider instances
  - FunctionTool can have its `.parameters` dict overridden after construction to use DB-stored schemas
  - For testing async DB code, mock `get_db()` context manager + cursor.fetchone/fetchall
  - Provider key lookup: check `providers.encrypted_api_key` first, fall back to `provider_keys` table
  - `build_messages()` from `orbiter._internal.message_builder` handles system prompt + message list assembly
---

## 2026-02-17 - US-093
- What was implemented: Crew execution view — detail page at /crews/[id] with run trigger, execution timeline, WebSocket streaming, and run history
- Features:
  - Crew detail page at /crews/[id] with crew header, process type badge, and Run button
  - Input section for optional crew context/instructions
  - Task list display showing crew task definitions
  - Horizontal execution timeline with animated nodes (pending → running → completed/failed)
  - Connector lines between timeline nodes that activate as tasks complete
  - Per-task output panels showing agent name, status badge, duration, and output/error
  - Live updates via WebSocket connection to /api/crews/{crew_id}/runs/{run_id}/stream
  - Timer showing elapsed execution time
  - Run history section with paginated previous executions
  - Sequential mode: output chaining (each task gets previous outputs as context)
  - Parallel mode: all tasks run simultaneously via asyncio.gather
- Backend additions:
  - Migration 025: crew_runs + crew_run_tasks tables for persistent run tracking
  - POST /api/crews/{id}/run creates a crew_run record and fires async execution
  - GET /api/crews/{id}/runs — paginated run history
  - GET /api/crews/{id}/runs/{run_id} — detailed run with task results
  - WebSocket /api/crews/{id}/runs/{run_id}/stream — real-time execution events
  - Poll-based fallback for already-running executions (_poll_crew_run)
  - Event types: execution_started, task_started, task_completed, execution_completed
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/crews.py (enhanced — persistent runs, WebSocket streaming, duration tracking, background tasks)
  - packages/orbiter-web/src/orbiter_web/migrations/025_create_crew_runs.sql (new — crew_runs + crew_run_tasks tables)
  - packages/orbiter-web/src/pages/crews/[id].astro (new — 506 lines, crew detail/execution page)
  - packages/orbiter-web/src/pages/crews/new.astro (updated — redirect to crew detail page after creation)
- **Learnings for future iterations:**
  - WebSocket auth: extract session cookie via `websocket.cookies.get("orbiter_session")`, validate before `websocket.accept()`
  - Event queue pattern: asyncio.Queue bridges background execution task to WebSocket send loop
  - For already-completed runs: send cached task results from DB immediately, then close WebSocket
  - For pending runs: attach event_callback to _execute_crew_run; for already-running: poll DB every 1 second
  - Background tasks: store in module-level `set()` with `task.add_done_callback(set.discard)` to prevent GC (ruff RUF006)
  - Timeline animation: CSS `pulse-ring` keyframe with box-shadow for running state dot
  - `run_task_id` separate from `task_id` — run tasks have their own UUIDs for per-run tracking
  - Manual browser verification needed (no dev-browser skill configured)
---

## 2026-02-17 - US-094
- What was implemented: Planner/Executor/Verifier backend — autonomous task decomposition with plan/execute/verify cycle
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/026_create_agent_plans.sql` — new migration adding `autonomous_mode` to agents, `agent_plans` and `agent_plan_steps` tables
  - `packages/orbiter-web/src/orbiter_web/services/planner.py` — PEV orchestration service: plan CRUD, step tracking, prompt builders (planner/executor/verifier)
  - `packages/orbiter-web/src/orbiter_web/routes/plans.py` — REST API for plans lifecycle: create, generate with steps, list versions, active plan, next-step, execute, verify, prompt endpoints
  - `packages/orbiter-web/src/orbiter_web/routes/agents.py` — added `autonomous_mode` bool to AgentCreate, AgentUpdate, AgentResponse; int/bool conversion for SQLite
  - `packages/orbiter-web/src/orbiter_web/app.py` — registered plans_router
- **Learnings for future iterations:**
  - SQLite stores booleans as integers — convert with `int()` on write and `bool()` on read in `_row_to_dict`
  - Plan versioning pattern: when creating a new active plan, mark previous active plan as `superseded` and increment version number
  - Step dependency resolution: get all steps, build completed set, find first pending step where all deps are in completed set
  - Routes sharing prefix (`/api/agents`) must be in separate routers registered independently — no conflict since FastAPI merges them
  - `from __future__ import annotations` enables forward references in type hints but Pydantic models used as FastAPI params still need to be defined before use (or use `model_rebuild()`)
  - WebSocket manager: `orbiter_web.websocket` exports `manager` singleton and `get_ws_user()` for auth; use `manager.broadcast_to_user(user_id, channel, msg)` for server-initiated pushes
---

## 2026-02-17 - US-156
- What was implemented: Multiplexed WebSocket manager with channel-based routing at `ws://api/ws`
- Files changed:
  - packages/orbiter-web/src/orbiter_web/websocket.py (new — WebSocketManager, _Connection, get_ws_user, heartbeat, message dispatcher)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — import and register ws_router)
- **Learnings for future iterations:**
  - WebSocket auth: validate `orbiter_session` cookie via `get_ws_user()` *before* `websocket.accept()` — reject with code 4001 if invalid
  - Channel envelope format: `{channel, type, payload}` — all messages must conform
  - Valid channels: chat, execution, logs, sandbox, notifications, system
  - Server heartbeat sends ping every 30s on system channel; client should respond with `{type: "pong"}`
  - `manager.broadcast_to_user(user_id, channel, message)` pushes to all connections for a user subscribed to that channel
  - Subscribe/unsubscribe via `{type: "subscribe", channel: "..."}` messages
  - `get_ws_user()` is a reusable auth helper — existing `_get_user_from_cookie()` duplicated across crews.py, playground.py, workflow_runs.py can eventually be replaced
---

## 2026-02-17 - US-157
- What was implemented: Client-side WebSocket singleton library (OrbiterSocket) that mirrors the server-side WebSocketManager from US-156
- Files changed:
  - packages/orbiter-web/src/utils/websocket.ts (new — OrbiterSocket class with singleton, channel subscriptions, reconnection, heartbeat, message queue)
- **Learnings for future iterations:**
  - OrbiterSocket is a singleton — use `OrbiterSocket.getInstance()` or the exported `orbiterSocket` convenience alias
  - `subscribe(channel, callback)` auto-connects on first call; returns an unsubscribe function
  - Messages queued while disconnected are flushed on reconnect; subscribe messages are re-sent too
  - Reconnection uses exponential backoff: 1s → 2s → 4s → 8s → 16s → 30s max
  - Heartbeat: server sends `{channel: "system", type: "ping", payload: {}}`, client responds with `{type: "pong"}`
  - `onConnectionChange(callback)` fires immediately with current state, returns unsubscribe fn
  - `close()` stops reconnection; to reconnect after close, a new subscribe() call will reconnect
  - `resetInstance()` available for tests — tears down singleton completely
---

## 2026-02-17 04:10 - US-158
- What was implemented: Replaced hardcoded `_DEFAULT_USER_ID = "default-user"` in projects route with proper `Depends(get_current_user)` authentication
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/projects.py (updated — removed _DEFAULT_USER_ID, added Depends(get_current_user) to all 5 endpoints, imported get_current_user from auth module)
- **Learnings for future iterations:**
  - All endpoints using `_DEFAULT_USER_ID` need the same conversion: add `user: dict[str, Any] = Depends(get_current_user),  # noqa: B008` parameter and replace `_DEFAULT_USER_ID` with `user["id"]`
  - No migration needed since the `projects` table already has `user_id TEXT NOT NULL REFERENCES users(id)` — the column was correct, just the route was bypassing auth
  - The `# noqa: B008` comment is required on `Depends()` default parameters to suppress ruff's B008 rule
---

## 2026-02-17 - US-159
- What was implemented: CORS middleware configuration for FastAPI
- Files changed:
  - packages/orbiter-web/src/orbiter_web/config.py (added `cors_origins` field + `__post_init__` to parse ORBITER_CORS_ORIGINS env var)
  - packages/orbiter-web/src/orbiter_web/app.py (added CORSMiddleware import + conditional middleware registration)
- **Learnings for future iterations:**
  - CORS middleware is only added when `ORBITER_CORS_ORIGINS` is set (comma-separated list) — defaults to empty/same-origin for security
  - `__post_init__` on a `@dataclass` is a clean way to compute derived fields from env vars
  - CORSMiddleware must be added before route registration for correct middleware ordering
  - Credentials=true is needed for cookie-based session auth (orbiter_session cookie)
---

## 2026-02-17 - US-095
- What was implemented: Autonomous mode UI — plan display panel with step list, modification capabilities, verification results, and plan history
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/plans.py (added step CRUD endpoints: POST add step, PUT update step, DELETE remove step, PUT reorder steps)
  - packages/orbiter-web/src/islands/PlanPanel/PlanPanelIsland.tsx (new — React island with full plan management UI)
  - packages/orbiter-web/src/pages/agents/[id]/plan.astro (new — Astro page for agent plan view)
- **Learnings for future iterations:**
  - PlanPanel is a React island at `src/islands/PlanPanel/PlanPanelIsland.tsx` — follows same patterns as Canvas panels (inline styles, zen design tokens)
  - Plan API lives at `/api/agents/{agentId}/plans` — supports full CRUD on steps (add/update/delete/reorder) plus plan versioning
  - Plan step modification endpoints only allow changes to `pending` steps — running/completed/failed steps are immutable
  - React island accepts `agentId` prop and polls `/api/agents/{agentId}/plans/active` every 3s for live updates
  - Plan page at `/agents/[id]/plan.astro` uses same loading/error pattern as edit page — fetch agent first, then render island
  - Step reorder endpoint takes ordered list of step IDs and assigns sequential step_numbers
---

## 2026-02-17 - US-096
- What was implemented: Workflow-embedded agent nodes — agent_node and sub_agent types now execute real Orbiter Agents instead of stubs
- Files changed:
  - packages/orbiter-web/src/orbiter_web/engine.py (major — replaced stub `_execute_node` with real agent execution via AgentService; added `_execute_agent_node`, `_gather_upstream_inputs`, upstream context passing, streaming token events)
  - packages/orbiter-web/src/islands/Canvas/CanvasIsland.tsx (added `agentTokens` to ExecutionState, `agent_token` WebSocket event handler for streaming)
- **Learnings for future iterations:**
  - Agent node execution pattern: `_execute_agent_node()` supports both DB-referenced agents (via `agent_id`) and inline agents (via `inline_*` config fields)
  - Upstream context: `_gather_upstream_inputs()` collects text from all upstream nodes via edges and variables dict — joined with newlines
  - Runtime context injection: `_user_id` and `_workflow_id` are injected into agent node data before execution so AgentService can resolve providers
  - Streaming: when `event_callback` is available, agent nodes emit `agent_token` events via `svc.stream_agent()` for real-time visibility; falls back to `run_agent()` on failure
  - `_execute_node()` now accepts optional `edges`, `variables`, and `event_callback` params — all callers (execute_workflow, execute_workflow_debug, execute_single_node) updated
  - Supervisor/nested agents: supported through DB agent relationships (agent_sub_agents table) — AgentService resolves delegation tools automatically
  - Frontend `agentTokens: Record<string, string>` accumulates streamed text per node_id, reset on new run
  - Existing infrastructure was well-designed: handle types, AgentNodeConfig UI, NodeConfigPanel, and AgentService were already complete — only the engine stub needed real implementation
---

## 2026-02-17 - US-160
- What was implemented: CSRF protection middleware for all state-changing endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/middleware/__init__.py (new — middleware package init)
  - packages/orbiter-web/src/orbiter_web/middleware/csrf.py (new — CSRFMiddleware: validates X-CSRF-Token header on POST/PUT/DELETE/PATCH)
  - packages/orbiter-web/src/orbiter_web/migrations/027_add_csrf_token.sql (new — adds csrf_token column to sessions, backfills existing)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registers CSRFMiddleware)
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (updated — generates CSRF token on login via secrets.token_urlsafe(32), added GET /api/auth/csrf endpoint)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — monkey-patches window.fetch to auto-include X-CSRF-Token on unsafe same-origin requests, exposes getCsrfToken()/clearCsrfToken() globally)
  - packages/orbiter-web/src/pages/settings.astro (updated — clears CSRF token on logout)
  - packages/orbiter-web/src/utils/csrf.ts (new — ES module getCsrfToken/clearCsrfToken for React islands)
- **Learnings for future iterations:**
  - CSRF middleware must be added AFTER CORSMiddleware in app.add_middleware() calls because Starlette middleware order is reversed (last added = first executed); CORS preflight must pass before CSRF check
  - Login endpoint must be exempt from CSRF check since the user doesn't have a token yet
  - Monkey-patching window.fetch in PageLayout is the cleanest way to add CSRF to all existing inline scripts without touching every page
  - The patched fetch returns a Promise (from getCsrfToken().then(...)) instead of synchronously — this is compatible with all existing .then() chains but could break code expecting synchronous fetch behavior
  - Existing sessions without csrf_token are backfilled by migration using hex(randomblob(24))
  - React islands can import getCsrfToken from utils/csrf.ts, but their fetch calls also go through the patched window.fetch so it's optional
---

## 2026-02-17 04:37 - US-097
- What was implemented: Knowledge base schema (migration 028) and REST API with 5 CRUD endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/028_create_knowledge_bases.sql (new — knowledge_bases table with indexes)
  - packages/orbiter-web/src/orbiter_web/routes/knowledge_bases.py (new — APIRouter with KnowledgeBaseCreate, KnowledgeBaseUpdate, KnowledgeBaseResponse models, 5 endpoints with project_id filter)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include knowledge_bases_router)
- **Learnings for future iterations:**
  - Knowledge bases table follows the same CRUD pattern as projects — use projects.py as the template
  - knowledge_bases has both user_id (ownership) and optional project_id (scoping) — filter by both when project_id is provided
  - Next migration number is 029
---

## 2026-02-17 04:41 - US-098
- What was implemented: Knowledge base management UI with two pages
  - `/knowledge` index page: KB list grid, create modal (name, description, embedding model selector, chunk size, chunk overlap), delete with confirmation dialog
  - `/knowledge/[id]` detail page: stats cards (documents, chunks, index size), configuration display, document list placeholder, delete with confirmation
- Files changed:
  - packages/orbiter-web/src/pages/knowledge/index.astro (new — KB list page with create/delete modals)
  - packages/orbiter-web/src/pages/knowledge/[id].astro (new — KB detail page with stats and config)
- **Learnings for future iterations:**
  - PageLayout already has "knowledge" in its nav sections — just use `activeSection="knowledge"` and the nav item lights up
  - Follow the projects page pattern: loading state → empty state → grid with template cloning
  - Delete buttons on cards: use `data-action="delete"` with event delegation on the grid container, `e.stopPropagation()` to prevent card link navigation
  - `define:vars={{ kbId: id }}` passes Astro params into `is:inline` scripts — same pattern as projects/[id].astro
---

## 2026-02-17 - US-161
- What was implemented: In-memory sliding window rate limiting middleware with three tiers
  - Auth endpoints (POST /api/auth/login): 5/min per IP
  - Agent execution endpoints (workflow /run, /debug): 10/min per user (configurable via ORBITER_RATE_LIMIT_AGENT)
  - General API: 60/min per user/session
  - X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset headers on all API responses
  - 429 response with Retry-After header when limit exceeded
- Files changed:
  - packages/orbiter-web/src/orbiter_web/middleware/rate_limit.py (new — RateLimitMiddleware with _SlidingWindow counter)
  - packages/orbiter-web/src/orbiter_web/config.py (added rate_limit_auth, rate_limit_general, rate_limit_agent settings)
  - packages/orbiter-web/src/orbiter_web/app.py (added RateLimitMiddleware import and registration)
- **Learnings for future iterations:**
  - Middleware ordering in Starlette: last added = outermost. RateLimitMiddleware added after CSRFMiddleware so it runs first (before CSRF check)
  - Custom in-memory sliding window avoids extra dependency (slowapi/redis) — sufficient for single-process SQLite deployments
  - User identification: prefer session cookie over IP for authenticated users; fall back to IP for unauthenticated
  - Agent execution paths identified by prefix (/api/workflows/) + suffix (/run, /debug)
  - Config: use `int(os.getenv(...))` pattern consistent with session_expiry_hours
---

## 2026-02-17 - US-099
- What was implemented: Document processing backend with text extraction, chunking, and three REST endpoints
  - Migration 029: `documents` table (id, kb_id, filename, file_type, file_size, chunk_count, metadata_json, status, created_at) and `document_chunks` table (id, document_id, kb_id, chunk_index, content, char_count, metadata_json, created_at)
  - `services/document_processor.py`: extract_text() for TXT, MD, CSV, HTML, PDF (pypdf with fallback), DOCX (zipfile+xml); chunk_text() with configurable size/overlap and smart boundary detection
  - POST `/api/knowledge-bases/:id/documents` — file upload, text extraction, chunking, DB storage, KB counter update
  - GET `/api/knowledge-bases/:id/documents` — list all documents for a KB
  - DELETE `/api/knowledge-bases/:id/documents/:docId` — remove document + chunks (FK cascade), update KB counters
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/029_create_documents.sql (new)
  - packages/orbiter-web/src/orbiter_web/services/document_processor.py (new)
  - packages/orbiter-web/src/orbiter_web/routes/knowledge_bases.py (extended with document endpoints)
- **Learnings for future iterations:**
  - Document routes are sub-routes of knowledge_bases router (same APIRouter, `/api/knowledge-bases/{kb_id}/documents/...`)
  - DOCX extraction uses stdlib zipfile + xml.etree — no external library needed
  - PDF extraction: try pypdf first, fall back to regex-based text extraction from binary
  - KB counters (doc_count, chunk_count) are updated transactionally on upload and delete
  - `_verify_kb_access()` helper validates KB ownership before any document operation
  - FastAPI UploadFile for file uploads — content read with `await file.read()`
---

## 2026-02-17 - US-100
- What was implemented: Document upload UI on the knowledge base detail page with:
  - Drag-and-drop zone with visual feedback (border highlight on dragover) + file picker button
  - Upload progress bar per file: uploading -> processing -> chunking -> complete (color transitions)
  - Chunking preview: shows first 2-3 chunks after processing (inline during upload + modal for existing docs)
  - Per-document settings: custom chunk size override, metadata tags input (expandable settings panel per file)
  - Bulk upload: multiple files at once via file picker or drag-and-drop
  - Document list: filename, type icon (color-coded per file type), chunk count, file size, upload date, status badge
  - Delete document button with confirmation modal
  - New backend endpoint: GET /api/knowledge-bases/:kb_id/documents/:doc_id/chunks for chunk preview
- Files changed:
  - packages/orbiter-web/src/pages/knowledge/[id].astro (major rewrite — upload zone, progress, doc list, modals)
  - packages/orbiter-web/src/orbiter_web/routes/knowledge_bases.py (added list_document_chunks endpoint)
- **Learnings for future iterations:**
  - The [id].astro page uses `is:inline` script with `define:vars={{ kbId: id, typeIcons }}` to pass Astro variables to client-side JS
  - Drag-and-drop uses `dragover`/`dragleave`/`drop` events with `e.preventDefault()` — must prevent default on dragover for drop to work
  - FormData append for file upload — CSRF is auto-included by PageLayout's fetch monkey-patch
  - Sequential file upload via promise chain (`Promise.resolve().then(...)`) for ordered progress display
  - Document chunks endpoint uses `limit` query param for preview — keeps responses small
---

## 2026-02-17 - US-101
- What was implemented: Knowledge retrieval backend — retrieval settings per KB, search endpoint, workflow retrieval node, agent KB assignment
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/030_add_retrieval_settings.sql (new — adds search_type, top_k, similarity_threshold, reranker_enabled to knowledge_bases; knowledge_base_ids to agents)
  - packages/orbiter-web/src/orbiter_web/routes/knowledge_bases.py (updated — SearchRequest/SearchResult models, retrieval settings in KB CRUD models, POST /{kb_id}/search endpoint with keyword scoring)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (updated — knowledge_base_ids field in AgentCreate, AgentUpdate, AgentResponse, create INSERT)
  - packages/orbiter-web/src/orbiter_web/engine.py (updated — _execute_retrieval_node() for knowledge_retrieval nodeType, integrated into _execute_node dispatch)
- **Learnings for future iterations:**
  - KB retrieval uses keyword search (LIKE + term frequency scoring) as a fallback until vector embeddings are implemented
  - `_keyword_score()` in knowledge_bases.py is reusable — computes fraction of query terms present in content
  - Retrieval settings (search_type, top_k, similarity_threshold, reranker_enabled) are per-KB, not global
  - Engine retrieval node reads KB settings from DB directly, no need for AgentService
  - Agent knowledge_base_ids is stored as JSON TEXT array (same pattern as tools_json, handoffs_json)
---

## 2026-02-17 - US-102
- What was implemented: Knowledge retrieval config UI on KB detail page
  - Retrieval Settings section with search type toggle (keyword/semantic/hybrid), top-k slider (1-20), similarity threshold slider (0.0-1.0), reranker toggle
  - Save Changes button with PUT to /api/knowledge-bases/:id, success/error messages
  - Test Retrieval section with query input, search button, results showing chunks with relevance scores as percentage badges
  - Click-to-expand on result items shows full chunk text with source document name highlighted
- Files changed:
  - packages/orbiter-web/src/pages/knowledge/[id].astro (added ~180 lines: HTML sections + JS logic)
- **Learnings for future iterations:**
  - Retrieval settings were already in the DB schema (migration 030) and the PUT endpoint already accepts them — the frontend was the missing piece
  - Use `setSearchType()` pattern with button group styling for toggle selections (add/remove Tailwind classes)
  - Range slider for threshold uses 0-100 int range, divide by 100 for float display/API calls
  - CSRF is auto-handled by PageLayout monkey-patch — no need to add X-CSRF-Token headers manually
---

## 2026-02-17 - US-103
- What was implemented: Vector store configuration UI in Settings > Knowledge tab with full backend CRUD
- Implementation details:
  - New migration `031_create_vector_store_config.sql` — table with backend, host, port, api_key_encrypted, collection_name, is_active per user
  - New routes file `routes/vector_stores.py` — GET (auto-creates default SQLite-VSS), PUT (update config), POST /test (connectivity check)
  - Backend selector: SQLite-VSS (default), Milvus/Zilliz, Qdrant, ChromaDB, Pinecone
  - Per-backend connection fields: host, port, API key (encrypted), collection name — Pinecone hides host/port, shows only API key
  - Test Connection: SQLite-VSS always succeeds (built-in); TCP connect for Milvus/Qdrant/ChromaDB; HTTPS API check for Pinecone
  - Status indicator shows connected backend name with color-coded dot (green=built-in, blue=configured, grey=not configured)
  - Added "Knowledge" tab between Models and Workspace in settings tab bar
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/031_create_vector_store_config.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/vector_stores.py (new — ~265 lines)
  - packages/orbiter-web/src/orbiter_web/app.py (added vector_stores_router import + include)
  - packages/orbiter-web/src/pages/settings.astro (added Knowledge tab + panel-knowledge section + ~170 lines JS)
- **Learnings for future iterations:**
  - Vector store config is a singleton per user (one active config, auto-created on first GET)
  - API key encryption uses same `encrypt_api_key()` / `decrypt_api_key()` from crypto.py — return `api_key_set: bool` in responses
  - Settings tab pattern: add button in tab nav bar, add panel div, add lazy-load check in tab click handler (`if (target === "knowledge" && !vsLoaded)`)
  - Backend field visibility: use JS to show/hide connection fields based on backend selection; Pinecone needs API key but not host/port
  - Test connection for TCP backends: use `asyncio.open_connection` with `asyncio.wait_for(timeout=5.0)`
---

## 2026-02-17 - US-104
- Implemented context configuration panel for agent builder
- Context tab added between Hooks and Advanced tabs with:
  - Automation level selector (Pilot/Copilot/Navigator) with visual card buttons
  - Token budget inputs (max tokens per step, max total tokens) as number fields
  - Memory toggle with type selector (conversation, summary, sliding_window) as radio buttons
  - Workspace toggle for artifact storage
- Backend: migration 032 adds context_automation_level, context_max_tokens_per_step, context_max_total_tokens, context_memory_type, context_workspace_enabled columns to agents table
- API: updated AgentCreate, AgentUpdate, AgentResponse Pydantic models and INSERT/UPDATE SQL
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/032_add_agent_context_config.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (added 5 context fields to models, INSERT, _row_to_dict)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (added Context tab HTML + JS)
- **Learnings for future iterations:**
  - Context config is stored as proper DB columns (not in hooks_json meta flags) for clean mapping to ContextConfig
  - Automation levels: pilot (fully autonomous), copilot (suggests, user approves), navigator (plans only)
  - Boolean columns in SQLite: use int() on write, bool() on read via _row_to_dict
  - Tab addition pattern: add button in nav, add panel div, add JS variables + event handlers, wire into showAgent() and save handler
---

## 2026-02-17 - US-105
- Implemented neuron pipeline editor on agent builder Context tab
- Created `neuron_pipelines` table (migration 033) with agent_id FK, neurons_json storage
- Built full CRUD + preview API at `/api/agents/:id/pipelines` (routes/neuron_pipelines.py)
- Added neuron pipeline editor UI: ordered neuron list with 6 neuron types (System Instruction, Context State, Tool Results, Conversation History, Knowledge Retrieval, Custom Template)
- Drag-and-drop reordering via native HTML5 drag events on neuron cards
- Per-neuron config: template textarea, max tokens allocation, priority number, enable/disable toggle
- Token budget bar chart showing estimated tokens consumed per neuron with colored bars
- Collapsible preview panel showing assembled prompt from enabled neurons
- Auto-save pipeline with 800ms debounce on changes; lazy-create on first edit
- Pipelines loaded automatically when agent data is fetched
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/033_create_neuron_pipelines.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/neuron_pipelines.py (new, 265 lines)
  - packages/orbiter-web/src/orbiter_web/app.py (registered neuron_pipelines_router)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (added neuron pipeline HTML + JS, ~410 lines)
- **Learnings for future iterations:**
  - Neuron pipeline is a separate entity (not stored on agents table) — uses its own table with agent_id FK
  - Auto-save pattern: use setTimeout debounce (800ms) with POST for new / PUT for existing pipeline
  - Budget bar visualization: estimate ~4 chars per token, cap at max_tokens if set
  - loadPipelines() call must be placed in showAgent() after context fields are populated
  - Neuron type metadata (labels, colors, icons) defined as a JS object for consistent rendering across list, budget, and preview
---

## 2026-02-17 - US-106
- Implemented context state inspector panel in playground trace panel
- Added tabbed interface to trace panel: "Trace" (existing) and "Context" (new)
- Context inspector shows hierarchical tree view matching Orbiter's ContextState parent-child hierarchy
- Each node displays: task_id, key-value pairs table, token usage breakdown
- Expand/collapse on all tree nodes with chevron toggle
- Change highlighting between steps: green dots for new values, yellow for modified, red for removed (with strikethrough)
- Fork visualization: fork icon badge on nodes with fork_event, shows parent_task_id
- Merge visualization: merge icon badge + green merge info row with net token delta
- Step navigator (prev/next) to browse context state at each step
- Context snapshots auto-generated from trace entries during chat (synthesized from trace data)
- WebSocket protocol extended with `context_state` message type for real agent runtime data
- Backend REST endpoint: GET /api/context-state/conversation/:id for fetching context state
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (added ~540 lines: tabs, context inspector tree, diff engine, snapshot builder)
  - packages/orbiter-web/src/orbiter_web/routes/context_state.py (new, 56 lines)
  - packages/orbiter-web/src/orbiter_web/app.py (registered context_state_router)
- **Learnings for future iterations:**
  - Trace panel tabs: use data-tab attributes and toggle bg-subtle/text-dark vs text-muted for active/inactive state
  - Context snapshots are diffed against previous snapshot to compute entry status (new/modified/removed/unchanged)
  - Tree rendering is recursive: renderContextNode(node, depth) with depth-based indentation via marginLeft
  - The WebSocket `context_state` message type carries a full tree — frontend just calls addContextSnapshot(data.tree)
  - Until agent runtime is wired, context snapshots are synthesized from trace entries in buildContextSnapshotFromTrace()
  - clearTraceEntries() must also call clearContextSnapshots() to keep both panels in sync
---

## 2026-02-17 - US-107
- What was implemented
  - Migration 034: `checkpoints` table (id, run_id, name, step_number, state_blob, created_at) with index on run_id
  - POST `/api/runs/:runId/checkpoints` — saves execution state as a named checkpoint
  - GET `/api/runs/:runId/checkpoints` — lists checkpoints for a run (paginated, ordered by step_number desc)
  - POST `/api/runs/:runId/checkpoints/:cpId/restore` — restores from checkpoint and resets run status to pending
  - `maybe_auto_checkpoint()` helper — creates auto-checkpoints at configurable intervals (default every 5 steps)
  - `cleanup_old_checkpoints()` helper — deletes checkpoints older than N days (default 30)
  - Registered checkpoints_router in app.py
- Files changed
  - packages/orbiter-web/src/orbiter_web/migrations/034_create_checkpoints.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/checkpoints.py (new)
  - packages/orbiter-web/src/orbiter_web/app.py (added import + include_router)
- **Learnings for future iterations:**
  - Ruff I001 (import sort): always add new imports in alphabetical order among the existing import block
  - Ruff SIM105: use `contextlib.suppress(ExcType)` instead of try/except/pass — applies throughout the codebase
  - Checkpoint state_blob is stored as JSON TEXT; use json.loads with contextlib.suppress for safe deserialization
  - Run ownership check pattern: `_verify_run_ownership(db, run_id, user_id)` queries workflow_runs filtered by user_id
---

## 2026-02-17 - US-108
- What was implemented: Checkpoint management UI in RunHistoryPanel with full CRUD, diff, and auto-checkpoint settings
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/checkpoints.py (added DELETE endpoint, diff endpoint, CheckpointDiffOut model)
  - packages/orbiter-web/src/islands/Canvas/RunHistoryPanel.tsx (added Checkpoint types, state management, CheckpointRow, CheckpointDiffView, DiffKeyList components; integrated into RunDetailView with save/restore/delete/diff actions and auto-checkpoint interval setting)
- **Learnings for future iterations:**
  - Checkpoint diff compares state_blob keys as dicts — non-dict blobs get wrapped in `{"_raw": value}` for comparison
  - FastAPI route ordering: the diff endpoint `/checkpoints/diff` doesn't conflict with `/{cp_id}` param routes because diff is a subpath under checkpoints, not at the cp_id level
  - Blob size display: use `new Blob([str]).size` for accurate byte count in browser (handles UTF-8 correctly)
  - RunDetailView prop drilling: checkpoint data/callbacks are passed from the main component through RunDetailView — consider extracting to context if more sections need checkpoint data
---

## 2026-02-17 - US-109
- What was implemented: Metrics aggregation REST API with three endpoints: dashboard summary, per-agent breakdown, and timeseries data
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/metrics.py (new — APIRouter with DashboardMetrics, AgentMetrics, TimeseriesPoint models, 3 endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — import and register metrics_router)
- **Learnings for future iterations:**
  - Metrics aggregate across both `workflow_runs` and `crew_runs` tables — crew_runs don't have token/cost tracking yet
  - SQLite `strftime` can bucket by minute (%Y-%m-%dT%H:%M), hour (%Y-%m-%dT%H:00), or day (%Y-%m-%d) for timeseries
  - Latency computed via `julianday(completed_at) - julianday(started_at) * 86400000` for milliseconds
  - `range` parameter name doesn't trigger ruff A002 (builtin shadowing) in this project config — no noqa needed
  - Custom time ranges use start/end ISO-8601 timestamps, falling back to predefined offsets (1h/24h/7d/30d)
---

## 2026-02-17 - US-110
- What was implemented: Monitoring dashboard UI at /monitoring with full metrics visualization
- Files changed:
  - packages/orbiter-web/src/pages/monitoring.astro (new — complete monitoring dashboard)
- **Features implemented:**
  - Time-range selector (1h, 24h, 7d, 30d) with active state styling
  - 5 key metric cards: total runs, success rate %, avg latency, total tokens, total cost
  - 5 vanilla JS + SVG charts: runs bar chart, tokens line chart, cost line chart, latency histogram, success/failure donut
  - Per-agent breakdown table with clickable agent names (links to /workflows/:id)
  - Auto-refresh toggle (30s interval) with visual toggle switch
  - Manual refresh button with spin animation
- **Learnings for future iterations:**
  - SVG charts use `viewBox` for responsive sizing — container.clientWidth at render time determines layout
  - Donut chart uses donutSlice() helper with SVG arc path commands — handles both inner and outer radius
  - Histogram re-buckets timeseries latency data client-side into distribution bins
  - All data comes from the 3 metrics API endpoints (US-109): /api/metrics/dashboard, /api/metrics/agents, /api/metrics/timeseries
  - `fmtNumber()` helper formats large numbers with K/M suffixes for metric cards
  - Range buttons use CSS class toggling (bg-white, shadow-sm) for active state
---

## 2026-02-17 - US-111
- What was implemented: Unified runs schema (migration 035) and REST API with WebSocket streaming
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/035_create_runs.sql (new — runs table with agent_id, workflow_id, status, steps_json, total_tokens, total_cost, start_time, end_time, finish_reason, created_at)
  - packages/orbiter-web/src/orbiter_web/routes/runs.py (new — APIRouter at /api/runs with list, get, WebSocket stream endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — include runs_router)
- **Learnings for future iterations:**
  - Unified runs table tracks both agent and workflow executions — agent_id and workflow_id are both nullable foreign keys
  - `publish_run_event()` function exported from runs.py for execution engines to push real-time updates to WebSocket subscribers
  - WebSocket stream uses dual approach: subscriber queue for push events + DB polling fallback (1s interval)
  - `_run_subscribers` dict tracks active WebSocket connections per run_id; cleanup on disconnect
  - Ruff S608 (SQL injection) is not enabled in this project — no need for noqa comments on f-string SQL
  - Import sorting: `runs` goes alphabetically after `providers`, not after `projects`
---

## 2026-02-17 - US-112
- What was implemented: Runs list page at /monitoring/runs and run detail page at /monitoring/runs/[id] with step timeline, expandable steps, live WebSocket streaming for in-progress runs
- Files changed:
  - packages/orbiter-web/src/pages/monitoring/runs.astro (new — runs list with status filter, sort, pagination, auto-refresh, clickable rows)
  - packages/orbiter-web/src/pages/monitoring/runs/[id].astro (new — run detail with summary header, step timeline, expandable input/output/error, nested tool calls, live streaming via WS)
  - packages/orbiter-web/src/orbiter_web/routes/runs.py (updated — JOIN agents/workflows tables to include agent_name/workflow_name in list and detail responses)
  - packages/orbiter-web/src/pages/monitoring.astro (updated — added "View all runs" link in dashboard header)
- **Learnings for future iterations:**
  - Runs API list endpoint now uses table-prefixed columns (r.user_id, r.agent_id) for JOINs — always prefix when adding JOINs to existing queries
  - Monitoring sub-pages go in pages/monitoring/ directory (e.g., pages/monitoring/runs.astro, pages/monitoring/runs/[id].astro)
  - `define:vars={{ id }}` passes Astro frontmatter vars to `is:inline` scripts — used for dynamic route params
  - Steps in steps_json have structure: type (llm/tool/handoff), duration (ms), tokens, input, output, error, tool_calls[], model, name
  - WebSocket reconnect pattern: connect on page load if run status is running/pending, reload full data on step events
  - Client-side sort works for current page of API results — sort by cost/tokens/time-asc applied locally after fetch
---

## 2026-02-17 - US-113
- What was implemented: Cost estimation backend with model pricing catalog, budget management, and budget enforcement on workflow runs
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/036_create_model_pricing.sql (new — model_pricing table with pre-seeded pricing for 6 models)
  - packages/orbiter-web/src/orbiter_web/migrations/037_create_cost_budgets.sql (new — cost_budgets table with scope/period/alert_threshold)
  - packages/orbiter-web/src/orbiter_web/routes/costs.py (rewritten — GET/PUT /api/costs/pricing from model_pricing table, GET /api/costs/summary with aggregate data, GET/PUT /api/costs/budgets for budget CRUD, GET /api/costs/budget-check, check_budget() helper)
  - packages/orbiter-web/src/orbiter_web/engine.py (updated — budget check at start of execute_workflow: warns at threshold, pauses at 100%)
- **Learnings for future iterations:**
  - model_pricing is a global catalog (not per-user), separate from the per-user models table
  - Budget check uses both `runs` and `workflow_runs` tables to compute total spend in period
  - PUT /api/costs/budgets uses upsert pattern (unique on user_id + scope + scope_id) — simpler than separate POST/PUT
  - Budget periods: "daily" resets at midnight UTC, "monthly" resets on 1st of month
  - check_budget() checks agent-specific budget first, falls back to workspace-level — hierarchical scoping
  - Engine imports check_budget from routes.costs — this creates a dependency from engine to routes module
---

## 2026-02-17 - US-114
- What was implemented: Cost tracking UI — cost per step in run detail, model pricing settings tab, budget management page with charts, global budget warning banner
- Files changed:
  - packages/orbiter-web/src/pages/monitoring/runs/[id].astro (updated — added cost column per step in timeline)
  - packages/orbiter-web/src/pages/settings.astro (updated — new "Pricing" tab with editable model pricing table, auto-save on blur)
  - packages/orbiter-web/src/pages/monitoring/costs.astro (new — dedicated cost tracking page with summary cards, cost-by-agent horizontal bar chart, cost over time line chart, agent cost breakdown table, budget management CRUD, budget warning banner)
  - packages/orbiter-web/src/pages/monitoring.astro (updated — added "Cost tracking" link in header)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — global budget warning banner visible on all app pages when budget is warning/exceeded)
  - packages/orbiter-web/src/orbiter_web/routes/costs.py (updated — added DELETE /api/costs/budgets/:id endpoint)
- **Learnings for future iterations:**
  - Settings tab lazy-loading pattern: set a `fooLoaded` boolean, check it in the tab click handler, call `fetchFoo()` on first show
  - Budget check API at `/api/costs/budget-check` returns null when no budget set — always null-check before using
  - The costs page reuses the same SVG line chart pattern from monitoring.astro
  - PageLayout is the right place for global banners (budget warnings) since all app pages use it
  - Pricing inputs use auto-save on "change" event (blur after edit) — simpler UX than a separate save button
---

## 2026-02-17 - US-115
- What was implemented: Structured log storage backend with REST filtering and WebSocket live streaming
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/038_create_logs.sql (new — logs table with level/source CHECK constraints, indexes)
  - packages/orbiter-web/src/orbiter_web/routes/logs.py (new — POST /api/logs, GET /api/logs with level/source/agent_id/time/search filters, WS /api/logs/stream)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered logs_router)
- **Learnings for future iterations:**
  - WebSocket streaming via in-memory subscriber registry pattern: _subscribers dict tracks connected WS clients; _notify_subscribers pushes new entries to all matching user connections
  - Logs route uses both REST (Depends(get_current_user)) and WS (get_ws_user from websocket.py) auth patterns
  - SQLite CHECK constraints enforce enum values at the DB level for level and source columns
  - The WebSocket endpoint at /stream (relative to prefix /api/logs) resolves to ws://api/logs/stream
---

## 2026-02-17 - US-162
- What was implemented: Startup environment validation and secret key warning
- Added `_validate_startup()` function in `app.py` called during FastAPI lifespan
- Checks if ORBITER_SECRET_KEY equals default 'change-me-in-production' or is empty → logs WARNING
- Validates database directory exists and is writable → logs ERROR if not
- Logs startup config summary: database path, debug mode, session expiry, CORS origins (no secrets)
- Files changed: `packages/orbiter-web/src/orbiter_web/app.py`
- **Learnings for future iterations:**
  - The `logger = logging.getLogger(...)` line must come AFTER all imports to avoid ruff E402 (module-level import not at top of file)
  - `_DB_PATH` is exported from `database.py` — can be imported directly for use elsewhere
  - The lifespan function runs `_validate_startup()` before `run_migrations()` so DB path validation happens first
---

## 2026-02-17 - US-163
- What was implemented: CSP headers and input sanitization
- Added `SecurityHeadersMiddleware` in `middleware/security.py` — sets CSP, X-Content-Type-Options, X-Frame-Options on all responses
- CSP: `default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:`
- X-Content-Type-Options: nosniff
- X-Frame-Options: DENY (SAMEORIGIN for widget embed paths via `_FRAMEABLE_PATHS` set)
- Created `sanitize.py` with `sanitize_html()` — strips HTML tags and neutralizes dangerous patterns (javascript:, vbscript:, data:text/html, on*= event handlers)
- Applied sanitization to all user text fields before DB storage in: agents, projects, applications, crews, knowledge_bases, workflows, prompt_templates
- Files changed: `middleware/security.py` (new), `sanitize.py` (new), `app.py`, `routes/agents.py`, `routes/projects.py`, `routes/applications.py`, `routes/crews.py`, `routes/knowledge_bases.py`, `routes/workflows.py`, `routes/prompt_templates.py`
- **Learnings for future iterations:**
  - Middleware in FastAPI is applied in reverse order of `add_middleware()` — SecurityHeaders is added last so runs first (outermost)
  - Pure-Python sanitization via regex is sufficient for text fields — no external dep (nh3/bleach) needed
  - For update endpoints using `model_dump(exclude_none=True)`, sanitize the dict values before building the SQL SET clause
  - Ruff N806: don't use UPPER_CASE for local variables inside functions — use tuple/set literal directly in for-loop
---

## 2026-02-17 - US-164
- Implemented standardized error response format for all API errors
- Created `orbiter_web/errors.py` with:
  - `_STATUS_CODE_MAP` mapping HTTP status codes to standard error codes (VALIDATION_ERROR, UNAUTHORIZED, FORBIDDEN, RESOURCE_NOT_FOUND, CONFLICT, RATE_LIMITED, INTERNAL_ERROR, BAD_GATEWAY, SERVICE_UNAVAILABLE)
  - `_http_exception_handler` — catches all `HTTPException` and wraps into `{error: {code, message, details}}`
  - `_validation_exception_handler` — catches Pydantic `RequestValidationError` with field-level details (field path, message, type)
  - `_generic_exception_handler` — catches unhandled exceptions as INTERNAL_ERROR
  - `register_error_handlers(app)` convenience function
- Registered handlers in `app.py` after FastAPI instantiation
- All existing `HTTPException(detail=...)` calls throughout routes now automatically produce the structured format — no route changes needed
- Files changed: `errors.py` (new), `app.py`
- **Learnings for future iterations:**
  - FastAPI exception handlers replace the default response format globally — no need to modify individual route files
  - Starlette's `HTTPException` is the base class FastAPI's `HTTPException` inherits from — register handler for `starlette.exceptions.HTTPException` to catch both
  - The `request` parameter is required by FastAPI's handler signature even if unused — ruff ARG rules are not enabled in this project so no noqa needed
  - Pydantic validation error `loc` tuple starts with "body"/"query"/"path" — skip first element for user-friendly field paths
---

## 2026-02-17 - US-116
- What was implemented: Log viewer UI page at /monitoring/logs with streaming log viewer
- Files changed:
  - packages/orbiter-web/src/pages/monitoring/logs.astro (new — full log viewer page)
- **Learnings for future iterations:**
  - Log API at `/api/logs` supports: level, source, agent_id, start_time, end_time, search filtering with limit/offset pagination
  - WebSocket streaming at `/api/logs/stream` — send JSON filter objects to narrow stream
  - Severity color coding pattern: debug=gray, info=blue, warn=yellow, error=red — use `levelColors` and `levelDots` maps
  - Source badges: agent=purple, tool=cyan, model=orange, system=gray
  - Expandable metadata: use `data-toggle` attribute + hidden div pattern for accordion-style expand/collapse
  - Export pattern: create Blob + temporary anchor element + `URL.createObjectURL()` for download
  - Time range filtering: convert relative ranges (1h, 24h, 7d, 30d) to ISO timestamps client-side, pass as `start_time` param
---

## 2026-02-17 - US-117
- What was implemented: Alert rules backend with CRUD for alert rules and alerts, plus enhanced health check
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/039_create_alert_rules.sql (new — alert_rules table)
  - packages/orbiter-web/src/orbiter_web/migrations/040_create_alerts.sql (new — alerts table with CASCADE delete from rules)
  - packages/orbiter-web/src/orbiter_web/routes/alerts.py (new — full CRUD: POST/GET /rules, GET/PUT/DELETE /rules/:id, GET alerts, PUT /:id/acknowledge)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — added alerts_router, enhanced GET /api/health with per-agent and per-provider status)
- **Learnings for future iterations:**
  - Runs table uses `start_time`/`end_time` columns, NOT `started_at`/`completed_at` — check migration files before writing queries
  - `workflow_runs` table uses `started_at`/`completed_at` but `runs` table uses `start_time`/`end_time` — inconsistent naming, always verify
  - Alert rules use condition_type (error_rate, latency, cost) + condition_threshold (float) pattern — simple but extensible
  - Action types (toast, email, webhook) with action_config_json for flexible action configuration
  - Health endpoint returns per-agent status (healthy/degraded based on error_rate > 50%) and per-provider status (configured/no_keys)
  - Foreign key ON DELETE CASCADE on alerts.rule_id means deleting a rule auto-deletes its alerts
---

## 2026-02-17 12:20 - US-118
- What was implemented: Alert management UI with alert rules CRUD, triggered alerts list, and health status page
- Files changed:
  - packages/orbiter-web/src/pages/monitoring/alerts.astro (new — alert rules + triggered alerts tabs)
  - packages/orbiter-web/src/pages/monitoring/health.astro (new — per-agent and per-provider health cards)
  - packages/orbiter-web/src/pages/monitoring.astro (updated — added nav links to Alerts and Health pages)
- **Learnings for future iterations:**
  - Alert rules page uses two tabs (Alert Rules + Triggered Alerts) with shared fetch patterns
  - Condition builder: select condition_type (error_rate/latency/cost), threshold with dynamic suffix (%/ms/$)
  - Action config: conditional fields shown/hidden based on action_type (webhook URL, email address)
  - Triggered alerts use severity badges with color-coded dots (critical=red, warning=yellow, info=blue)
  - Acknowledge button calls PUT /api/alerts/:id/acknowledge then re-fetches list
  - Health page uses /api/health endpoint which returns per-agent (error_rate, avg_latency, recent_runs) and per-provider (key_count, status)
  - Agent health cards include success rate progress bars with color coding (>=90% green, >=50% yellow, <50% red)
  - Provider health shows API key count and links to /settings when no keys configured
  - Modal pattern: dialog element with .showModal(), backdrop click to close, form submission with error display
  - Delete confirmation uses separate dialog to prevent accidental deletion
---

## 2026-02-17 - US-119
- Implemented approval gate backend: new workflow node type that pauses execution until human approval
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/041_create_workflow_approvals.sql` (new) — workflow_approvals table with status, timeout, comment fields
  - `packages/orbiter-web/src/orbiter_web/routes/approvals.py` (new) — GET /api/approvals/pending, POST /api/approvals/:id/respond, engine-facing helpers (create_approval, poll_approval)
  - `packages/orbiter-web/src/orbiter_web/engine.py` — added _execute_approval_gate() and approval_gate dispatch in _execute_node(); passed run_id/user_id/cancel_event through to support approval gate polling
  - `packages/orbiter-web/src/orbiter_web/routes/tools.py` — added approval_gate to _NODE_HANDLE_MAP
  - `packages/orbiter-web/src/islands/Canvas/handleTypes.ts` — added approval_gate to NODE_HANDLE_MAP
  - `packages/orbiter-web/src/orbiter_web/app.py` — registered approvals_router
- **Learnings for future iterations:**
  - workflow_runs.status is TEXT with no CHECK constraint — safe to add new statuses like 'awaiting_approval' without migration
  - Approval gate uses async polling (2s intervals) in the engine; the gate blocks the asyncio task but yields via sleep so other tasks can proceed
  - When adding keyword-only args to _execute_node(), all 3 call sites (single node, workflow, debug) need updating
  - Notifications piggyback on the existing alerts table (rule_id set to empty string for system-generated alerts)
  - Timeout check uses SQLite datetime arithmetic: `datetime(requested_at, '+' || timeout_minutes || ' minutes')`
---

## 2026-02-17 - US-165
- Implemented cursor-based pagination utility for list endpoints
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/pagination.py` (new) — paginate() utility with PaginatedResponse envelope, base64 cursor encode/decode
  - `packages/orbiter-web/src/orbiter_web/routes/agents.py` — list_agents now uses paginate() with optional cursor/limit params
  - `packages/orbiter-web/src/orbiter_web/routes/projects.py` — list_projects now uses paginate() with optional cursor/limit params
  - `packages/orbiter-web/src/orbiter_web/routes/workflows.py` — list_workflows now uses paginate() with optional cursor/limit params
  - 13 frontend files updated to extract `.data` from new paginated response envelope
- **Learnings for future iterations:**
  - Pagination response format: `{data: [...], pagination: {next_cursor, has_more, total}}`
  - Cursor encodes `created_at|id` as base64 — uses both fields for stable ordering (created_at DESC, id DESC)
  - Frontend pattern for handling paginated response: `.then(function (body) { return body.data || body; })` provides backward compat
  - paginate() fetches limit+1 rows to detect `has_more` without a separate query
  - Total count query runs against base conditions (ignoring cursor) to give total count of all matching rows
  - When changing list endpoint response shapes, ALL frontend consumers must be updated — grep for `fetch("/api/<endpoint>")` in both .astro and .tsx files
---

## 2026-02-17 - US-166
- Implemented shared file upload infrastructure
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/upload.py` (NEW) — handle_upload(), cleanup_upload(), UploadResult dataclass, MIME/extension validation, UUID filename generation
  - `packages/orbiter-web/src/orbiter_web/config.py` — added max_upload_mb and upload_dir settings
- **Learnings for future iterations:**
  - Upload config: ORBITER_MAX_UPLOAD_MB (default 50) and ORBITER_UPLOAD_DIR (default data/uploads/) env vars
  - Use `handle_upload(file, allowed_types={"pdf","csv"}, max_size_mb=10)` for any route needing file upload
  - Use `cleanup_upload(path)` in except blocks when processing fails after upload
  - _MIME_MAP in upload.py maps extensions to valid MIME types — add new types there when needed
  - UploadResult.path is a Path object, use str() if you need string path for DB storage
---

## 2026-02-17 - US-120
- Implemented approval gate UI for workflows
- Files changed:
  - `packages/orbiter-web/src/islands/Canvas/NodeSidebar.tsx` — added approval_gate to Logic category with shield+checkmark icon
  - `packages/orbiter-web/src/islands/Canvas/ApprovalGateConfig.tsx` (NEW) — config panel with timeout_minutes, approval_message fields, and approval history log
  - `packages/orbiter-web/src/islands/Canvas/NodeConfigPanel.tsx` — added approval_gate case to renderTypeConfig
  - `packages/orbiter-web/src/orbiter_web/routes/approvals.py` — added GET /api/approvals/count (badge) and GET /api/approvals/history?node_id= (node inspection panel)
  - `packages/orbiter-web/src/layouts/PageLayout.astro` — added bell icon notification badge with pending count, approval modal dialog with approve/reject/comment, 30s polling
- **Learnings for future iterations:**
  - Backend for approval gate was already implemented (engine.py, migration 041, routes/approvals.py) — only frontend was missing
  - Approval modal uses native `<dialog>` with `.showModal()` — same pattern as confirmation dialogs elsewhere
  - Notification badge polls `/api/approvals/pending` every 30s; uses `/api/approvals/count` could be used for lighter-weight checks
  - Bell icon inserted between theme toggle and user menu in PageLayout top bar
  - ApprovalGateConfig fetches history from `/api/approvals/history?node_id=` on mount
  - Comment is required for rejection but optional for approval (enforced client-side)
---

## 2026-02-17 - US-121
- What was implemented: Real-time agent takeover for playground chat
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (refactored to support async stream cancellation and takeover protocol)
  - packages/orbiter-web/src/pages/playground.astro (added Take Over button, status badge, takeover controls bar, trace logging)
- **Learnings for future iterations:**
  - WebSocket takeover pattern: run LLM stream in asyncio.Task, listen for client commands via asyncio.Queue concurrently; cancel task on takeover
  - _TokenCollector accepts cancel_event (asyncio.Event) — checks on each send_json and raises CancelledError to abort stream cleanly
  - Refactored common streaming dispatch into _run_stream() helper to avoid duplicating provider switch logic for resume/inject paths
  - Agent status badge uses three states: idle (hidden), running (green), paused (coral) — driven by setAgentStatus() function
  - Takeover trace entries use a distinct coral-styled card (not collapsible like normal trace entries) for visual differentiation
  - Frontend inject flow: addUserMessage() + ws.send({type:"inject"}) + startAgentMessage() — mirrors sendMessage() but with inject type
  - contextlib.suppress(asyncio.CancelledError) is the clean pattern for awaiting cancelled tasks in finally blocks
---

## 2026-02-17 - US-167
- Implemented FTS5 full-text search infrastructure
- Migration 042_create_fts5_tables.sql: FTS5 virtual tables for agents (name, description, instructions), workflows (name, description), tools (name, description), thread_messages (content)
- Triggers for INSERT/UPDATE/DELETE sync on all four tables
- Initial data population from existing rows
- search_entities() in orbiter_web/search.py: async search across entity types with FTS5 MATCH, snippet highlighting, prefix matching, relevance ranking
- Files changed: migrations/042_create_fts5_tables.sql, search.py
- **Learnings for future iterations:**
  - agents table uses `instructions` column (not `system_prompt`) for the system prompt text
  - FTS5 content tables use `content='table_name'` and `content_rowid='rowid'` for external content mode
  - FTS5 delete operations use the special syntax: `INSERT INTO fts_table(fts_table, rowid, ...) VALUES ('delete', old.rowid, ...)`
  - Thread messages are in `thread_messages` table (not `messages`); join via `thread_id` to `threads` for entity-level results
  - SQLite FTS5 rank is negative (more negative = better match); ORDER BY rank ascending gives best results first
---

## 2026-02-17 - US-122
- What was implemented: Annotation schema and REST API — full CRUD, FTS5 search, CSV import, similarity matching
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/043_create_annotations.sql (new — annotations table + FTS5 + triggers)
  - packages/orbiter-web/src/orbiter_web/routes/annotations.py (new — 8 endpoints: list with search, create, get, update, delete, import CSV, match)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered annotations_router)
- **Learnings for future iterations:**
  - SequenceMatcher from difflib provides quick string similarity without external deps — suitable for annotation matching
  - CSV import pattern: use handle_upload() for file validation, then read_text + csv.DictReader for parsing; cleanup_upload after reading
  - Define static path endpoints (/import, /match) BEFORE parameterized /{id} routes to avoid FastAPI matching path as id
  - Ruff doesn't have S608 (SQL injection) enabled in this project — don't add noqa: S608 comments
  - Annotation FTS5 follows same pattern as migration 042: content table + content_rowid + insert/update/delete triggers
---

## 2026-02-17 - US-168
- What was implemented: Global search backend (Cmd+K) — GET /api/search?q=&types= endpoint
  - Cross-entity search across agents, workflows, tools, and knowledge_bases
  - Uses FTS5 infrastructure from US-167 for agents, workflows, tools
  - LIKE fallback for knowledge_bases (no FTS5 table exists for it)
  - Empty query returns recent items (ORDER BY created_at DESC LIMIT 5 per type)
  - Each result includes: id, name, type, snippet, url path
  - Max 5 results per entity type (20 total)
  - Authenticated via get_current_user dependency
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/search.py (new — global search endpoint)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered search_router)
- **Learnings for future iterations:**
  - search_entities() in search.py returns {} for empty queries — need separate logic for "recent items" fallback
  - knowledge_bases has no FTS5 virtual table — use LIKE fallback for entities without FTS5
  - search_entities() doesn't filter by user_id — the route handles user scoping for knowledge_bases but FTS results are unscoped
  - _URL_TEMPLATES pattern maps entity types to frontend URL paths — extend when adding new searchable types
---

## 2026-02-17 - US-123
- What was implemented: Annotation UI — thumbs up/down + annotate buttons on every playground agent response, full annotation management page at /annotations with list/search/create/edit/delete, bulk CSV import dialog, match threshold slider, cost savings display
- Files changed:
  - packages/orbiter-web/src/pages/playground.astro (updated — added annotation buttons to finishStream and addRestoredAgentMessage, annotation dialog, lastUserQuery tracking)
  - packages/orbiter-web/src/pages/annotations.astro (new — full annotation management page with stats, CRUD, CSV import, threshold slider)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — added "pen" icon and "Annotations" nav item)
- **Learnings for future iterations:**
  - Annotation backend was already complete from US-122 (routes/annotations.py, migration 043) — only UI needed
  - In playground.astro, `finishStream()` is the right injection point for adding buttons after streaming — `wrapper` is the parent of the bubble
  - `addRestoredAgentMessage()` handles history restoration — needs query param passed from `restoreMessages()` by tracking prev user message
  - Two separate restore paths exist: `restoreMessages()` for WebSocket conversation_loaded and thread message loading — both need prevQuery tracking
  - Annotation dialog pattern: store context in `dataset` attributes on the save button, read back in click handler
  - Stats are computed client-side from the fetched annotations list — no separate API endpoint needed
---

## 2026-02-17 - US-124
- What was implemented: Message editing and replay for conversations in the Playground
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/044_create_message_edits.sql (new — message_edits table for edit history)
  - packages/orbiter-web/src/orbiter_web/routes/conversations.py (updated — added PUT edit, DELETE message, GET edits, POST replay endpoints + MessageEditRequest/Response models)
  - packages/orbiter-web/src/orbiter_web/routes/playground.py (updated — _load_conversation_messages returns message IDs, WebSocket emits message_saved events)
  - packages/orbiter-web/src/pages/playground.astro (updated — hover menu with edit/delete/copy/replay, inline editor, edit history tooltip, replay-from-here flow)
- **Learnings for future iterations:**
  - Messages loaded via WebSocket `conversation_loaded` now include `id` field — update any code that depends on the message shape
  - WebSocket emits `message_saved` events with `{type: "message_saved", message_id: "...", role: "user"|"assistant"}` — use to track DOM↔DB message ID mapping
  - `connectWebSocket(agentId, conversationId, replayText)` supports auto-replay: loads conversation then auto-sends the message
  - `createMessageActions()` replaces `createCopyButton()` — provides hover menu with copy/edit/delete/replay actions
  - `data-role` and `data-message-id` attributes on message wrapper elements enable DOM↔API operations
  - `.msg-content` class marks the content element within a message for inline editing
  - Replay flow: call POST /replay API to truncate → reconnect WebSocket → reload conversation → auto-send last message
  - Edit history stored in `message_edits` table with CASCADE delete — automatically cleaned up when message/conversation deleted
---

## 2026-02-17 - US-169
- Implemented global search modal (Cmd+K / Ctrl+K) in PageLayout.astro
- Search dialog with autofocus input, debounced 300ms API calls to GET /api/search
- Results grouped by type (Agents, Workflows, Tools, Knowledge Bases) with type-specific icons
- Arrow key navigation + Enter to open selected result
- Escape or backdrop click closes modal
- Recent searches stored in localStorage, shown when input is empty
- HTML snippet highlights converted to `<mark>` tags with coral highlight
- Files changed: packages/orbiter-web/src/layouts/PageLayout.astro
- **Learnings for future iterations:**
  - Backend search route (`routes/search.py`) and FTS5 infrastructure were already in place from earlier stories
  - Search API returns results grouped by type key, with `snippet` containing `<b>` tags for highlights
  - Empty query to `/api/search` returns recent items per type (not actual search results)
  - Dialog element with `.showModal()` automatically handles Escape key and focus trapping
  - Use delegated event listeners on the results container for click handling (results are dynamically rendered)
---

## 2026-02-17 - US-170
- What was implemented: Notification system — migration, service, and REST API
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/045_create_notifications.sql (new — notifications table with indexes)
  - packages/orbiter-web/src/orbiter_web/services/notifications.py (new — create_notification() service with WebSocket push)
  - packages/orbiter-web/src/orbiter_web/routes/notifications.py (new — GET /api/notifications with pagination, GET /api/notifications/unread-count, PUT /api/notifications/:id/read, POST /api/notifications/read-all)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered notifications_router)
- **Learnings for future iterations:**
  - Notification service uses lazy import of `manager` from websocket.py to avoid circular imports
  - Route ordering matters: `/unread-count` and `/read-all` static paths must be defined BEFORE `/{notification_id}/read` param route
  - `paginate()` utility handles cursor-based pagination automatically — pass table, conditions, params
  - Service functions in `services/` can be imported by other modules (e.g., approval gates, alert rules) to create notifications
---

## 2026-02-17 - US-125
- What was implemented: Code interpreter sandbox backend — sandboxed Python execution environment for agents
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/services/sandbox.py` (NEW) — SandboxConfig, SandboxResult, execute_code() with subprocess isolation
  - `packages/orbiter-web/src/orbiter_web/routes/sandbox.py` (NEW) — POST /api/sandbox/execute, GET/PUT /api/sandbox/config
  - `packages/orbiter-web/src/orbiter_web/routes/tools.py` — Added BUILTIN_TOOLS with code_interpreter, merged into list_tools
  - `packages/orbiter-web/src/orbiter_web/app.py` — Registered sandbox_router
  - `packages/orbiter-web/src/orbiter_web/migrations/046_create_sandbox_configs.sql` (NEW) — sandbox_configs table
- **Learnings for future iterations:**
  - Sandbox subprocess inherits Python import system — blocking exec/eval/compile from builtins breaks importlib.exec_module() internally. Don't block these; use import restriction + filesystem restriction as the security boundary instead
  - Import restriction needs explicit "safe stdlib" set (encodings, codecs, importlib internals, etc.) because Python's import machinery itself needs these modules to load anything
  - F-strings in textwrap.dedent templates are tricky — avoid nested f-string expressions with brackets. Use string concatenation for generated error messages instead
  - Generated file collection: read file content as base64 BEFORE workspace cleanup (shutil.rmtree in finally block)
  - sys.stdlib_module_names is too permissive for sandbox (includes subprocess, socket, etc.) — maintain an explicit safe stdlib set
---

## 2026-02-17 08:30 - US-126
- What was implemented: Sandbox config and file display UI — code interpreter tool integration with playground chat
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/routes/playground.py` — Added _resolve_agent_tool_schemas() to build OpenAI tool schemas from agent's tools_json, _execute_sandbox() helper, tool schema passing to _stream_openai/_stream_anthropic, sandbox execution for code_interpreter tool calls, sandbox_result WebSocket events with generated files
  - `packages/orbiter-web/src/pages/playground.astro` — Added sandbox_result WebSocket event handler, appendSandboxResult() function rendering images inline (base64 data URIs), files as downloadable links with size info, stdout/stderr/error display
  - `packages/orbiter-web/src/pages/agents/[id]/edit.astro` — Added sandbox configuration section in Tools tab (timeout slider 1-120s, memory limit slider 64-1024MB, allowed libraries checklist), auto-shown when builtin:code_interpreter is assigned, loads/saves config via /api/sandbox/config
- **Learnings for future iterations:**
  - Playground streams directly from provider APIs (not Orbiter Agent runtime) — tool schemas must be passed manually via the `tools` param in API requests
  - OpenAI tool format: `{type: "function", function: {name, description, parameters}}`; Anthropic uses `{name, description, input_schema}` — convert between formats
  - Tool call accumulation in OpenAI streaming uses `delta.tool_calls[].index` for multi-tool responses; track `id` field for tool call IDs
  - Anthropic tool calls come via content_block_start (type: tool_use) / content_block_delta (input_json_delta) / content_block_stop — execute sandbox at content_block_stop
  - Image detection for inline rendering: check file extension against known image types (png, jpg, gif, svg, webp, bmp)
  - Base64 data URIs for inline images: `data:{mime};base64,{content}` — works for both display and download
  - Sandbox config is per-user (not per-agent) — stored in sandbox_configs table
---

## 2026-02-17 - US-171
- Implemented notification bell icon with unread count badge in top bar (PageLayout.astro)
- Created dropdown panel with notification list, type icons, time-ago display, read/unread styling
- Added click-to-navigate (routes to entity pages based on entity_type/entity_id) + mark-as-read on click
- Added "Mark all as read" button using POST /api/notifications/read-all
- Wired up WebSocket real-time updates via notifications channel (notification_created events)
- Fallback polling every 30s for unread count
- Files changed:
  - `packages/orbiter-web/src/layouts/PageLayout.astro` — Added notification bell button, dropdown panel HTML, and inline script (~200 lines)
- **Learnings for future iterations:**
  - Notification backend (US-170) provides: GET /api/notifications (paginated), GET /api/notifications/unread-count, PUT /api/notifications/:id/read, POST /api/notifications/read-all
  - WebSocket notification events arrive as `{channel: "notifications", type: "notification_created", payload: {id, notification_type, title, message, entity_type, entity_id, created_at}}`
  - Approvals bell pattern in PageLayout is the template for badge + modal/dropdown UI patterns
  - Notification dropdown uses `position: relative` on container + `absolute right-0 top-full` on dropdown for proper positioning
  - Entity type to URL mapping: agent -> /agents/:id, workflow -> /workflows/:id/canvas, project -> /projects/:id, knowledge_base -> /knowledge/:id
---

## 2026-02-17 - US-172
- What was implemented: Schedule/cron trigger backend — migration for `schedules` table, background scheduler service with asyncio polling loop using `croniter` for cron expression parsing, full CRUD REST API at `/api/schedules`, and app lifespan integration (start on startup, stop on shutdown). When a schedule fires, it creates a workflow run with `trigger_type='schedule'` and executes the workflow in the background.
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/047_create_schedules.sql` — new table with indexes
  - `packages/orbiter-web/src/orbiter_web/services/scheduler.py` — background polling loop, compute_next_run, fire_schedule
  - `packages/orbiter-web/src/orbiter_web/routes/schedules.py` — CRUD endpoints (POST, GET list, GET by id, PUT, DELETE)
  - `packages/orbiter-web/src/orbiter_web/app.py` — scheduler start/stop in lifespan, router registration
  - `packages/orbiter-web/pyproject.toml` — added `croniter>=2.0` dependency
- **Learnings for future iterations:**
  - `croniter` library handles cron parsing; use `croniter.is_valid(expr)` for validation and `croniter(expr, base).get_next(datetime)` for next fire time
  - `workflow_runs` table already has `trigger_type` column (default 'manual') from migration 018 — schedule triggers use 'schedule'
  - Scheduler polls DB every 15 seconds for enabled schedules where `next_run_at <= now`
  - Scheduler disables schedules automatically if their workflow is deleted (ON DELETE CASCADE handles the row, but if fetched before deletion the service disables it)
  - Ruff doesn't enable PLW0603 by default — don't add `# noqa: PLW0603` for global statements
---

## 2026-02-17 - US-173
- What was implemented: Per-node retry, error handling, and timeout for workflow execution engine
- Changes:
  - `_get_node_error_config()` — extracts retry_count (0-5), retry_delay_ms, on_error (fail/skip/fallback), fallback_value, timeout_ms from node.data
  - `_execute_node_with_retry()` — wraps `_execute_node` with asyncio.wait_for timeout, exponential backoff retries, and on_error strategies
  - `execute_workflow()` — uses `_execute_node_with_retry` instead of `_execute_node`; logs retry metadata in workflow_run_logs
  - `execute_workflow_debug()` — same retry wrapper applied to debug execution
  - Migration `048_add_node_retry_fields.sql` — adds retry_attempt, max_retries, on_error columns to workflow_run_logs
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/engine.py` — added retry/timeout/error handling logic (~140 lines)
  - `packages/orbiter-web/src/orbiter_web/migrations/048_add_node_retry_fields.sql` — new migration
- **Learnings for future iterations:**
  - Node error config lives in `node.data` (JSON stored in workflow's `nodes_json`) — no DB migration needed for config fields
  - Use `asyncio.wait_for()` for per-node timeout; catches `TimeoutError` (not `asyncio.TimeoutError` — ruff UP041)
  - Exponential backoff: `delay_s = (retry_delay_ms / 1000) * 2^attempt`
  - Retry metadata flows through result dict via `_` prefixed keys (_retry_attempt, _max_retries, _on_error, _skipped, _fallback) — popped before DB storage
  - `on_error='skip'` sets `variables[nid] = None` so downstream nodes get null input
  - Both `execute_workflow` and `execute_workflow_debug` share the same retry wrapper — keep them in sync
---

## 2026-02-17 - US-174
- What was implemented: Agent memory persistence backend with three strategies
  - `MemoryService` class in `services/memory.py` with ConversationMemory, SlidingWindowMemory, and SummaryMemory strategies
  - `get_memory(agent_id, thread_id)` returns messages based on strategy
  - `save_turn(agent_id, thread_id, user_message, assistant_message)` persists turns
  - `clear_memory(agent_id, thread_id)` resets memory for a thread
  - Migration `049_create_agent_memory.sql` creates `agent_memory` and `agent_memory_summary` tables
  - Playground WebSocket integrated: reads `context_memory_type` from agent config, injects memory on conversation create/load, saves turns after each assistant response
  - Conversation delete route clears associated agent memory
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/services/memory.py` — new file (~200 lines)
  - `packages/orbiter-web/src/orbiter_web/migrations/049_create_agent_memory.sql` — new migration
  - `packages/orbiter-web/src/orbiter_web/routes/playground.py` — memory integration (import, memory_type extraction, history injection, turn persistence)
  - `packages/orbiter-web/src/orbiter_web/routes/conversations.py` — clear memory on conversation delete
- **Learnings for future iterations:**
  - `context_memory_type` field already exists on agents table (from migration 032) with default 'conversation'
  - Playground uses `SELECT * FROM agents` so all agent columns including context_memory_type are available in the WebSocket handler
  - Memory uses conversation_id as thread_id — each conversation is a separate memory thread
  - SummaryMemory needs an async summarize_fn callable for LLM summarization — kept as optional dependency
  - agent_memory_summary uses UNIQUE(agent_id, thread_id) with ON CONFLICT UPDATE for upsert pattern
  - SlidingWindow uses subquery with DESC LIMIT + outer ASC ORDER to get last N messages in chronological order
---

## 2026-02-17 - US-127
- What was implemented: Live sandbox view tab on the run detail page
- Files changed:
  - `packages/orbiter-web/src/pages/monitoring/runs/[id].astro` — added Sandbox View tab with file tree, terminal output, file preview, and artifact collection panels
- **Learnings for future iterations:**
  - Sandbox execution data is already stored in `steps_json` tool_calls — `code_interpreter` tool calls contain the code, stdout, stderr, generated_files, and execution_time_ms in their result field
  - No new backend endpoints or migrations needed — all sandbox data can be extracted from the run's existing steps_json
  - Tab switching pattern: use `data-tab-btn` and `data-tab-panel` attributes with matching IDs, toggle `hidden` class and indicator styles in JS
  - Generated files from sandbox include base64-encoded content (for files < 1MB) — use `atob()` to decode for text preview, data URIs for image preview
  - File download: create Blob from decoded base64, use `URL.createObjectURL()` + temporary anchor element click
  - Terminal output uses dark VS Code-inspired color scheme: `#1e1e1e` bg, `#d4d4d4` text, `#6a9955` green comments, `#569cd6` blue headers, `#f44747` red errors
  - Unused icon variables (chevronDown, cpuIcon, wrenchIcon, arrowRightIcon) were cleaned up from frontmatter — only used icons remain
---

## 2026-02-17 - US-175
- Implemented PUT /api/auth/password endpoint for password change
- Added PasswordChangeRequest model (current_password + new_password with min 8 chars)
- Added MessageResponse model for success responses
- Validates current password against bcrypt hash, returns 401 if wrong
- Updates password hash and invalidates all other sessions (keeps current)
- Files changed: packages/orbiter-web/src/orbiter_web/routes/auth.py
- **Learnings for future iterations:**
  - Auth helpers `_hash_password()` and `_verify_password()` already exist in auth.py — reuse them
  - Session cookie name is `SESSION_COOKIE = "orbiter_session"` — use `Cookie(None)` param to access it in endpoints
  - `get_current_user` dependency returns dict with id, email, created_at — no password_hash included (need separate query)
---

## 2026-02-17 - US-176
- What was implemented: Password reset flow with forgot-password and reset-password endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/050_create_password_resets.sql (new — password_resets table)
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (updated — added forgot-password, reset-password endpoints)
  - packages/orbiter-web/src/orbiter_web/middleware/csrf.py (updated — added CSRF exemptions for reset endpoints)
  - packages/orbiter-web/src/pages/reset-password.astro (new — reset password frontend page)
- **Learnings for future iterations:**
  - Unauthenticated POST endpoints (like forgot-password, reset-password) need CSRF exemption in `_EXEMPT_PATHS` in `middleware/csrf.py`
  - forgot-password should always return success message regardless of whether email exists (prevents user enumeration)
  - Reset tokens are stored as bcrypt hashes — iterate over unexpired/unused rows and checkpw each (no index-based lookup on hashed value)
  - Reset page uses BaseLayout (not PageLayout) since it's unauthenticated, same pattern as login page
  - Token passed via URL query param `?token=...` and read with `URLSearchParams` in inline script
---

## 2026-02-17 09:10 - US-177
- What was implemented: Session expiry frontend handling — global 401 interception, expired session toast on login page, WebSocket auth failure detection with connection banner
- Files changed:
  - packages/orbiter-web/src/utils/api.ts (new — apiFetch wrapper with 401 interception, AbortController-based request cancellation, expireSession helper)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — 401 interception in monkey-patched fetch, _pendingControllers for request cancellation, connection status banner for WS auth failures, WebSocket close code 4401/4403 handling)
  - packages/orbiter-web/src/pages/login.astro (updated — session expired toast shown when ?expired=true, auto-dismiss after 8s, URL cleanup via history.replaceState)
- **Learnings for future iterations:**
  - The monkey-patched `window.fetch` in PageLayout is the right place for global 401 interception — it catches all API calls including those from inline scripts
  - Skip 401 interception for `/api/auth/login` to avoid redirect loops when login itself returns 401
  - Track pending requests with AbortController array — abort all on session expiry to prevent cascading error toasts from in-flight requests
  - WebSocket close codes 4401/4403 are used for auth failures — detect in close event handler and trigger same expireSession flow
  - `window.__orbiterExpireSession` is the global entry point for session expiry from any context (fetch, WebSocket, etc.)
  - Use `history.replaceState` to clean up `?expired=true` query param after showing the toast (prevents re-showing on refresh)
  - Connection status banner is a fixed top banner with z-[90] — sits above content but below modals
---

## 2026-02-17 - US-128
- What was implemented: Artifact schema (migration 051) and REST API with 4 endpoints (list with filters, get metadata, download file, delete with file cleanup)
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/051_create_artifacts.sql (new — artifacts table with indexes)
  - packages/orbiter-web/src/orbiter_web/routes/artifacts.py (new — APIRouter with list/get/download/delete endpoints)
  - packages/orbiter-web/src/orbiter_web/config.py (updated — added artifact_dir setting via ORBITER_ARTIFACT_DIR env var)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered artifacts_router)
- **Learnings for future iterations:**
  - Use `FileResponse` from `fastapi.responses` for file download endpoints — set `media_type="application/octet-stream"` and `filename` for proper download behavior
  - Artifact dir uses `Path.mkdir(parents=True, exist_ok=True)` for lazy creation
  - When inserting new imports in app.py, ruff requires strict alphabetical sorting — use `ruff check --fix` to auto-sort
  - DELETE with file cleanup: remove from DB first (inside context manager), then delete file outside (best-effort) to avoid orphaned DB records
---

## 2026-02-17 - US-129
- What was implemented: Artifacts page UI at `/artifacts` with grid/list view toggle, file previews, filtering, download, and delete with confirmation
- Files changed:
  - packages/orbiter-web/src/pages/artifacts.astro (new — full artifacts library page)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — added "artifacts" nav item with file icon)
- **Learnings for future iterations:**
  - Artifacts API at `/api/artifacts` returns flat list (no pagination wrapper) — client-side pagination with array slicing
  - File type filtering is client-side since API `file_type` param matches exact strings, but UI needs category-based filtering (e.g., "image" matches png, jpg, etc.)
  - Agent names need separate `/api/agents` fetch to build a lookup map — API returns `agent_id` not `agent_name`
  - Grid/list view toggle: use two containers with `hidden` class toggling, re-render into the visible one
  - File preview pattern: images via `<img>`, PDFs via `<iframe>`, text/code via `fetch().then(r => r.text())` into `<pre><code>`
  - Bulk download without server-side ZIP: trigger multiple `<a download>` clicks programmatically
  - New sidebar icons must be added to both the `navSections` array AND the `icons` Record in PageLayout.astro
---

## 2026-02-17 - US-178
- Implemented background cleanup task for expired sessions, stale password reset tokens, and orphaned upload files
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/services/cleanup.py` (new) — cleanup loop with `_run_cleanup()`, `start_cleanup()`, `stop_cleanup()`
  - `packages/orbiter-web/src/orbiter_web/config.py` — added `cleanup_interval_hours` setting (ORBITER_CLEANUP_INTERVAL_HOURS env var, default 6)
  - `packages/orbiter-web/src/orbiter_web/app.py` — integrated cleanup start/stop into lifespan
- **Learnings for future iterations:**
  - Background tasks follow the scheduler.py pattern: module-level `_task` sentinel, `start_*`/`stop_*` async functions, cancellation with `contextlib.suppress(asyncio.CancelledError)`
  - Cleanup service checks documents table for referenced files before deleting uploads — prevents removing files that are still in use
  - ORBITER_CLEANUP_INTERVAL_HOURS env var configurable at `settings.cleanup_interval_hours`
---

## 2026-02-17 - US-130
- What was implemented: Artifact editing with inline code editor, markdown preview, JSON validation, version history, auto-save, regenerate, and diff view
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/052_create_artifact_versions.sql` (new) — artifact_versions table with id, artifact_id, version_number, content, file_size, created_at
  - `packages/orbiter-web/src/orbiter_web/routes/artifacts.py` — added 5 new endpoints: GET /content, PUT /content, GET /versions, GET /versions/:num, POST /regenerate; plus ArtifactUpdateContent, ArtifactVersionResponse, ArtifactRegenerateRequest models
  - `packages/orbiter-web/src/pages/artifacts/[id].astro` (new) — full artifact editor page with textarea, markdown preview, diff view, version history sidebar, auto-save 2s debounce, regenerate dialog
  - `packages/orbiter-web/src/pages/artifacts.astro` — added isTextArtifact() helper and edit links in grid/list views for text-based artifacts
- **Learnings for future iterations:**
  - Version tracking for artifacts: first edit saves original as v1, then new content as v2+; uses COALESCE(MAX(version_number), 0) + 1 pattern
  - `_is_text_artifact()` checks file extension against a frozenset of text/code extensions to determine editability
  - Auto-save uses 2s debounce; Ctrl+S/Cmd+S saves immediately
  - Regenerate endpoint uses `_resolve_provider` from agent_runtime.py — needs provider_type and model_name from agent row
  - Simple diff is line-by-line comparison — works well for text files; could be upgraded to Myers diff algorithm later
  - Markdown preview uses simple regex-based rendering — no external library needed for basic formatting
  - JSON validation: `JSON.parse()` in try/catch; red border on editor + warning banner on invalid
---

## 2026-02-17 - US-131
- Implemented evaluation framework backend with built-in evaluators
- Created migrations 053 (evaluations table) and 054 (eval_results table)
- Built 5 evaluators: exact_match, contains, regex_match, llm_as_judge, semantic_similarity
- Created full CRUD routes at /api/evaluations with pagination
- POST /api/evaluations/:id/run sends all test cases to agent, scores responses, persists results
- GET /api/evaluations/:id/results returns scored results history
- Registered evaluations_router in app.py
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/053_create_evaluations.sql (new)
  - packages/orbiter-web/src/orbiter_web/migrations/054_create_eval_results.sql (new)
  - packages/orbiter-web/src/orbiter_web/services/evaluators.py (new)
  - packages/orbiter-web/src/orbiter_web/routes/evaluations.py (new)
  - packages/orbiter-web/src/orbiter_web/app.py (modified)
- **Learnings for future iterations:**
  - Evaluators service uses async dispatch so sync and async evaluators (like llm_as_judge) can be called uniformly via `await run_evaluator()`
  - Use `_send_to_agent()` helper in evaluations.py for simple single-turn agent calls (builds messages + resolves provider inline)
  - The llm_as_judge evaluator falls back to semantic_similarity if no provider is available — keeps evals runnable even without API keys
  - Ruff RUF002 catches en-dash (–) in docstrings — use hyphen-minus (-) instead for ranges like "0.0-1.0"
---

## 2026-02-17 09:35 - US-179
- What was implemented: RBAC role column migration and auth updates
  - Created migration 055_add_role_column.sql: ALTER TABLE users ADD COLUMN role TEXT NOT NULL DEFAULT 'developer'
  - Updated UserResponse model to include role field
  - Updated get_current_user to SELECT u.role from sessions join
  - Updated login endpoint to include role in response
  - Updated CLI create-user with --role flag (choices: admin/developer/viewer, default: developer)
  - --admin flag backward compat: sets role to 'admin' automatically
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/055_add_role_column.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (modified)
  - packages/orbiter-web/src/orbiter_web/cli.py (modified)
- **Learnings for future iterations:**
  - 6 places query `u.id, u.email, u.created_at` from sessions join (auth.py, websocket.py, playground.py, crews.py, runs.py, workflow_runs.py) — US-180 route guards will need these updated too
  - Existing is_admin column (migration 024) still present; role column is the new canonical source of truth
  - UserResponse is the only Pydantic model for user data — adding fields here affects /api/auth/me and /api/auth/login responses
---

## 2026-02-17 - US-180
- What was implemented: RBAC role-based route guards via `require_role(min_role)` FastAPI dependency factory
- Changes:
  - `require_role()` in `routes/auth.py` — dependency factory with role hierarchy (viewer=0, developer=1, admin=2); returns 403 with "FORBIDDEN" detail if insufficient
  - `routes/provider_keys.py` — all 7 endpoints now require admin role
  - `routes/providers.py` — all 6 endpoints now require admin role
  - `routes/vector_stores.py` — all 3 endpoints now require admin role (system config)
  - `routes/sandbox.py` — PUT /config now requires admin role (system config); GET /config and POST /execute remain developer-accessible
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (added require_role + _ROLE_HIERARCHY)
  - packages/orbiter-web/src/orbiter_web/routes/provider_keys.py (swapped get_current_user → require_role("admin"))
  - packages/orbiter-web/src/orbiter_web/routes/providers.py (swapped get_current_user → require_role("admin"))
  - packages/orbiter-web/src/orbiter_web/routes/vector_stores.py (swapped get_current_user → require_role("admin"))
  - packages/orbiter-web/src/orbiter_web/routes/sandbox.py (PUT /config → require_role("admin"))
- **Learnings for future iterations:**
  - `require_role()` returns an inner async function that itself `Depends(get_current_user)` — it's a dependency factory, not middleware
  - The user dict from `get_current_user` already includes `role` from the sessions JOIN, so no extra DB query needed
  - No dedicated "user management" or "system settings" routes exist yet — guard those when they're created in future stories
  - `_ROLE_HIERARCHY` dict maps role strings to ints for comparison — easy to extend with new roles later
---

## 2026-02-17 - US-132
- What was implemented: Evaluation UI page at /evaluations with full create/view/run/delete functionality
- Files changed:
  - packages/orbiter-web/src/pages/evaluations.astro (new — full evaluation UI page)
  - packages/orbiter-web/src/layouts/PageLayout.astro (updated — added "evaluations" nav item with checklist icon)
- Features implemented:
  - List view: displays all evaluation suites with agent name, test case count, and creation time
  - Create dialog: name + agent selection (agents loaded from /api/agents)
  - Detail view: inline-editable test cases with input, expected output, and evaluator type dropdown
  - Evaluator types: exact_match, contains, regex_match, semantic_similarity, llm_as_judge
  - Run button: sends POST /api/evaluations/:id/run, shows spinner while running
  - Results table: input, expected, actual, evaluator, score %, pass/fail badges
  - Aggregate metrics: overall score, pass rate, test case count
  - History chart: SVG line chart with score (coral) and pass rate (green) over time
  - Delete with confirmation dialog
  - Test case auto-save with 500ms debounce
- **Learnings for future iterations:**
  - Evaluation backend stores test_cases_json as a JSON string in the response — parse with JSON.parse on the client
  - EVALUATOR_TYPES must match the keys in EVALUATORS dict from services/evaluators.py
  - Adding nav items: add to `navSections` array AND `icons` map in PageLayout.astro
  - History chart needs at least 2 result runs to display — hidden otherwise
  - Manual browser verification needed (no dev-browser skill available)
---

## 2026-02-17 - US-133
- Implemented agent benchmarking feature: create benchmarks linked to evaluation suites, run same test cases against 2+ agents, compare results
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/056_create_benchmarks.sql` — new tables: benchmarks, benchmark_runs, benchmark_results
  - `packages/orbiter-web/src/orbiter_web/routes/benchmarks.py` — full CRUD + run + leaderboard + CSV/JSON export endpoints
  - `packages/orbiter-web/src/orbiter_web/app.py` — registered benchmarks router
  - `packages/orbiter-web/src/pages/benchmarks.astro` — full UI with list/detail views, tabs (leaderboard, comparison, charts)
  - `packages/orbiter-web/src/layouts/PageLayout.astro` — added benchmarks nav item with trophy icon
- **Learnings for future iterations:**
  - Benchmarks build on top of existing evaluations — a benchmark references an evaluation_id for its test cases
  - The `_send_to_agent` helper from evaluations.py was duplicated into benchmarks.py with latency tracking (returns tuple of response + latency_ms)
  - SVG bar charts pattern: calculate bar dimensions from container width, use viewBox for responsiveness, render grid lines + value labels + axis labels
  - Tab UI pattern: use `tab-btn` class + `data-tab` attribute, `tab-content` class for panels, `switchTab()` toggles visibility and active styling
  - Export endpoint pattern: StreamingResponse with Content-Disposition header for file download; use `fmt` query param to switch between CSV and JSON
  - Leaderboard uses SQL aggregation (MAX, AVG, COUNT) grouped by agent_id across all completed runs
  - Score badge color coding: >= 80% green, >= 50% amber, < 50% coral
---

## 2026-02-17 - US-134
- What was implemented: Safety evaluation and red-teaming system
- Files changed:
  - `packages/orbiter-web/src/orbiter_web/migrations/057_create_safety_evaluations.sql` (new) — safety_runs table
  - `packages/orbiter-web/src/orbiter_web/services/safety.py` (new) — Safety categories, adversarial test cases, LLM judge, red-team generator, heuristic fallback
  - `packages/orbiter-web/src/orbiter_web/routes/evaluations.py` (modified) — Added `/safety/categories`, `/{id}/safety-run`, `/{id}/safety-results` endpoints
  - `packages/orbiter-web/src/pages/evaluations.astro` (modified) — Safety Test button, config dialog, category scores, flagged responses UI
- **Learnings for future iterations:**
  - Static routes like `/safety/categories` MUST be defined BEFORE parametric routes like `/{evaluation_id}` in FastAPI, otherwise "safety" gets matched as an evaluation_id
  - The existing `_send_to_agent()` helper in evaluations.py is reusable for safety testing — just send adversarial inputs through same path
  - Safety judging uses a structured "SCORE: / EXPLANATION:" format prompt that's easy to parse — avoids needing JSON parsing from the LLM
  - Heuristic fallback for safety scoring uses refusal/concern phrase detection when no LLM judge is available
  - Pre-built adversarial test cases are organized by category (prompt_injection, jailbreak, pii_leakage, harmful_content, bias_detection) with 5 tests each
  - Red-team mode generates novel adversarial inputs via LLM — falls back to preset cases if generation fails
  - Safety results stored separately from eval_results (safety_runs table) with category_scores_json for per-category breakdown
---

## 2026-02-17 - US-135
- What was implemented: Deployment backend and REST API — deploy agents/workflows as API endpoints
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/058_create_deployments.sql (new — deployments table with entity_type, api_key_hash, rate_limit, status, usage_count)
  - packages/orbiter-web/src/orbiter_web/routes/deployments.py (new — CRUD endpoints + runtime endpoint)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered deployments_router and deployed_router)
- Endpoints:
  - POST /api/deployments — creates deployment, generates `orb_` prefixed API key (shown once), stores SHA-256 hash
  - GET /api/deployments — lists all deployments with pagination
  - DELETE /api/deployments/:id — removes deployment
  - POST /api/deployed/:id/run — runtime endpoint, authenticates via Bearer token, supports `stream: true` for SSE
- **Learnings for future iterations:**
  - API key pattern: generate with `secrets.token_urlsafe(32)`, store SHA-256 hash (not encrypted), prefix with `orb_` for easy identification
  - CSRF middleware already skips requests without session cookies — external API calls using Bearer auth need no CSRF exemption
  - Workflow engine `execute_workflow()` signature: `run_id, workflow_id, user_id, nodes, edges, event_callback` — event_callback is async
  - SSE streaming for workflows needs asyncio.Queue bridge: task writes events to queue, generator yields from queue
  - For agent SSE, use `AgentService.stream_agent()` which yields `StreamChunk` objects
  - Two routers in one file: `router` (prefix `/api/deployments`) for CRUD, `deployed_router` (prefix `/api/deployed`) for runtime — both registered in app.py
---

## 2026-02-17 - US-181
- What was implemented: Workflow concurrency limits and run queue
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/059_create_run_queue.sql (new — run_queue table, workspace_settings table, max_concurrent column on workflows)
  - packages/orbiter-web/src/orbiter_web/services/run_queue.py (new — RunQueue service: can_start_run, enqueue_run, process_queue, cancel_queued_run, list_queued_runs)
  - packages/orbiter-web/src/orbiter_web/routes/run_queue.py (new — GET /api/runs/queue, DELETE /api/runs/queue/:id)
  - packages/orbiter-web/src/orbiter_web/routes/workspace_settings.py (new — GET/PUT /api/settings/workspace for concurrent_run_limit)
  - packages/orbiter-web/src/orbiter_web/routes/workflow_runs.py (updated — start_workflow_run checks concurrency limits, queues if at capacity)
  - packages/orbiter-web/src/orbiter_web/engine.py (updated — _update_run_status triggers process_queue on terminal states)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — registered run_queue_router and workspace_settings_router)
  - packages/orbiter-web/src/pages/settings.astro (updated — concurrent limit saved/loaded from DB API instead of localStorage only)
- **Learnings for future iterations:**
  - workspace_settings table is a simple key-value store for workspace-level configuration (concurrent_run_limit, etc.)
  - Queue processing: triggered from _update_run_status when run reaches terminal state (completed/failed/cancelled)
  - Per-workflow concurrency: optional max_concurrent column on workflows table (NULL = no per-workflow limit)
  - Queue entries store nodes_json/edges_json so they can be started without re-querying the workflow
  - Background task GC prevention: engine.py uses _queue_tasks set + add_done_callback pattern for process_queue tasks
  - run_queue status flow: queued → started (with run_id set) or queued → cancelled
---

## 2026-02-17 - US-182
- What was implemented: Storage cleanup and retention policies
  - Migration 060: seeds default retention settings (retention_artifacts_days=90, retention_runs_days=30, retention_logs_days=14) into workspace_settings table
  - GET/PUT /api/settings/retention endpoints for viewing/updating retention config
  - GET /api/settings/storage endpoint returns total_db_size, artifact_dir_size, upload_dir_size in bytes
  - Extended cleanup service with _run_retention_cleanup() that deletes old artifacts (+ files on disk), runs (with cascade delete of their artifacts), and logs based on retention settings
  - Cascade deletes: when deleting a run, first deletes its artifacts (including artifact_versions and files on disk), then the run itself
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/060_seed_retention_settings.sql (new)
  - packages/orbiter-web/src/orbiter_web/routes/retention.py (new)
  - packages/orbiter-web/src/orbiter_web/services/cleanup.py (modified)
  - packages/orbiter-web/src/orbiter_web/app.py (modified — added retention_router import and registration)
- **Learnings for future iterations:**
  - Retention settings stored as workspace_settings keys (retention_artifacts_days, retention_runs_days, retention_logs_days) — reuse _RETENTION_KEYS/DEFAULTS pattern
  - Artifacts FK on run_id is ON DELETE SET NULL (not CASCADE), so must manually delete artifacts before deleting runs
  - artifact_versions has ON DELETE CASCADE from artifacts, but explicit DELETE is safer for batch cleanup
  - Storage endpoint: include WAL and SHM files in DB size calculation for accurate SQLite size reporting
  - Ruff import sorting: retention comes after providers alphabetically — keep imports sorted
---

## 2026-02-17 - US-136
- What was implemented: Deploy as API UI — deployment management page at /deployments, Deploy as API buttons on agent edit and workflow detail pages, deployment detail modal with endpoint URL, curl usage example, and rate limit config
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/deployments.py (modified — added GET /{id}, PATCH /{id} endpoints, DeploymentUpdate model, entity name resolution in list/get)
  - packages/orbiter-web/src/layouts/PageLayout.astro (modified — added "deployments" nav entry with rocket icon)
  - packages/orbiter-web/src/pages/deployments.astro (new — deployment management page with table, status toggles, search/filter, detail modal, delete confirmation)
  - packages/orbiter-web/src/pages/agents/[id]/edit.astro (modified — added Deploy as API button + modal with form/success states)
  - packages/orbiter-web/src/pages/workflows/[id].astro (modified — added floating Deploy as API button + modal)
- **Learnings for future iterations:**
  - Deployment API keys use `orb_` prefix with `secrets.token_urlsafe(32)`, stored as SHA-256 hash; only returned on creation
  - Deploy modal pattern: form view + success view in same modal, toggled via classList; success view shows one-time API key
  - Workflow detail page is canvas-only — use absolute positioned floating buttons with z-20 to overlay the ReactFlow canvas
  - Entity name resolution: deployments table only stores entity_id, need to JOIN with agents/workflows to get names for display
---

## 2026-02-17 - US-183
- What was implemented: Audit log migration, service function, and REST API endpoint with filters
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/061_create_audit_log.sql (new — audit_log table with indexes)
  - packages/orbiter-web/src/orbiter_web/services/audit.py (new — audit_log() async service function)
  - packages/orbiter-web/src/orbiter_web/routes/audit_log.py (new — GET /api/audit-log with filters, admin only)
  - packages/orbiter-web/src/orbiter_web/app.py (updated — register audit_log_router)
  - packages/orbiter-web/src/orbiter_web/routes/auth.py (updated — audit login/logout)
  - packages/orbiter-web/src/orbiter_web/routes/agents.py (updated — audit create/delete agent)
  - packages/orbiter-web/src/orbiter_web/routes/workflows.py (updated — audit create/delete workflow)
  - packages/orbiter-web/src/orbiter_web/routes/provider_keys.py (updated — audit add/delete provider_key)
  - packages/orbiter-web/src/orbiter_web/routes/deployments.py (updated — audit create/delete deployment)
  - packages/orbiter-web/src/orbiter_web/services/cleanup.py (updated — added exemption comment for audit_log)
- **Learnings for future iterations:**
  - audit_log() service wraps inserts in try/except so audit failures never break business logic
  - audit_log table is intentionally exempt from retention cleanup — entries are never deleted
  - GET /api/audit-log uses cursor-based pagination via paginate() helper, with filters: user_id, action, entity_type, date_from, date_to
  - IP address captured via `request.client.host` in FastAPI — need to add `Request` param to route handlers
  - create_user and update_role actions will be logged when US-185 (team management) is implemented
---

## 2026-02-17 - US-184
- Implemented audit log UI page at /settings/audit-log (admin only)
- Added GET /api/audit-log/filters endpoint returning distinct users, actions, entity_types for filter dropdowns
- Created settings/ subdirectory under src/pages/ for settings subpages
- Filter bar with user dropdown, action dropdown, entity type dropdown, date range picker
- Table with timestamp, user email, action, entity type, entity ID, IP address columns
- Expandable rows showing full details JSON (parsed from details_json field)
- Cursor-based pagination with "Load more" button and entry count display
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/audit_log.py (added /filters endpoint)
  - packages/orbiter-web/src/pages/settings/audit-log.astro (new — full audit log UI)
- **Learnings for future iterations:**
  - Settings subpages go in src/pages/settings/ directory — first subpage created here
  - Filter endpoint pattern: /api/<resource>/filters returns distinct values for dropdowns (define BEFORE /{id} routes)
  - User email lookup: JOIN audit_log with users table to get email; fall back to user_id if no match
  - Expandable table rows: use pairs of <tr> elements — main row + hidden detail row toggled by click
  - Cursor-based pagination on frontend: pass next_cursor from response to subsequent fetch, append rows to tbody
---

## 2026-02-17 - US-185
- What was implemented: Team management backend — admin-only REST API for managing users
  - GET /api/settings/team — list all users with id, email, role, created_at
  - POST /api/settings/team/invite — create new user with email, password, role
  - PUT /api/settings/team/:userId — update user role
  - DELETE /api/settings/team/:userId — delete user and revoke all sessions
  - Guards: cannot delete yourself, cannot demote/delete the last admin
  - All endpoints require admin role via `require_role("admin")`
  - Audit logging on all write operations
- Files changed:
  - packages/orbiter-web/src/orbiter_web/routes/team.py (new — team management endpoints)
  - packages/orbiter-web/src/orbiter_web/app.py (register team_router)
- **Learnings for future iterations:**
  - No migration needed — team management reuses existing users/sessions tables
  - `_hash_password` from auth.py is importable for creating new users from admin routes
  - Use `sanitize_html()` on email input before DB storage
  - Admin guard pattern: every endpoint uses `Depends(require_role("admin"))` with `# noqa: B008`
  - Last-admin check: `SELECT COUNT(*) AS cnt FROM users WHERE role = 'admin'` before demotion or deletion
---

## 2026-02-17 - US-137
- What was implemented: Embeddable chat widget — full deploy-as-widget feature for agents
- Files changed:
  - packages/orbiter-web/src/orbiter_web/migrations/062_add_widget_config.sql (new — adds widget_config_json and cors_origins columns to deployments)
  - packages/orbiter-web/src/orbiter_web/routes/deployments.py (updated — widget config CRUD endpoints, embed code generation, CORS preflight handling for cross-origin widget requests)
  - packages/orbiter-web/public/widget.js (new — self-contained embeddable chat widget script)
  - packages/orbiter-web/src/pages/deployments/[id]/widget.astro (new — widget settings page with live preview, color picker, position, welcome message, avatar, CORS origins, embed code)
  - packages/orbiter-web/src/pages/deployments.astro (updated — added widget settings link in actions column)
- **Learnings for future iterations:**
  - Widget config stored as JSON TEXT in `widget_config_json` column; CORS origins as comma-separated TEXT in `cors_origins`
  - Per-deployment CORS: `_check_cors()` reads deployment's cors_origins from DB; `preflight_run()` handles OPTIONS; `run_deployed()` attaches CORS headers to responses
  - CSRF middleware already skips requests without session cookies, so deployed endpoints (Bearer token auth) work without explicit CSRF exemption
  - Embed code uses data attributes on `<script>` tag — widget.js reads them with `getAttribute()`
  - Widget preview in settings page is pure HTML injection into a container div — no iframe needed
  - `_escape_attr()` helper for safe HTML attribute escaping in embed code generation
---

## 2026-02-17 11:15 - US-186
- What was implemented: Team management UI in Settings page — Team tab (admin-only visibility), user table with email/role/joined/actions columns, Invite User modal, role change dropdown, Remove User confirmation dialog, success/error toast notifications
- Files changed:
  - packages/orbiter-web/src/pages/settings.astro (updated — added Team tab, panel-team section with user table, invite-user-modal, remove-user-modal, showToast helper, team management JavaScript)
- **Learnings for future iterations:**
  - Team tab visibility is controlled client-side: fetch `/api/auth/me`, check role === "admin", then unhide the tab — this avoids needing server-side rendering for role checks
  - Pattern for inline toast: create DOM element dynamically, append to body, auto-remove after 4s; use `id="settings-toast"` and remove existing before creating new to prevent stacking
  - Cannot change own role or remove yourself — enforced both in backend (400 error) and frontend (show badge instead of dropdown, hide remove button)
  - Role dropdown change fires PUT immediately (no save button needed) — follows the pricing table auto-save pattern
  - 204 responses from DELETE don't have body — must handle `.json()` error gracefully; use `res.ok` check before parsing
---
