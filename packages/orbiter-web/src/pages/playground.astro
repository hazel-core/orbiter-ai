---
import PageLayout from "../layouts/PageLayout.astro";

const breadcrumbs = [{ label: "Playground" }];

/* Icons */
const sendIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
const botIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';
const clearIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>';
const traceIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>';
---

<PageLayout
  title="Playground"
  description="Chat with your AI agents"
  activeSection="playground"
  breadcrumbs={breadcrumbs}
  class="!overflow-hidden flex flex-col"
>
  <div class="flex flex-col h-full">
    <!-- Top bar: agent selector -->
    <div class="flex items-center gap-3 px-4 py-3 border-b border-dark/[0.08] bg-paper flex-shrink-0">
      <label for="agent-select" class="text-sm font-medium text-dark whitespace-nowrap">Agent:</label>
      <select
        id="agent-select"
        class="flex-1 max-w-xs px-3 py-1.5 text-sm border border-dark/[0.08] rounded-lg bg-paper text-dark focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors"
      >
        <option value="">Select an agent...</option>
      </select>
      <div id="agent-info" class="text-xs text-muted hidden">
        <span id="agent-model" class="inline-flex items-center gap-1 px-2 py-0.5 bg-subtle rounded-full"></span>
      </div>
      <div class="ml-auto flex items-center gap-1">
        <button
          id="trace-toggle-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Toggle trace panel (Cmd+I)"
        >
          <span set:html={traceIcon} />
          <span class="hidden sm:inline">Trace</span>
        </button>
        <button
          id="clear-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Clear conversation"
        >
          <span set:html={clearIcon} />
          <span class="hidden sm:inline">Clear</span>
        </button>
      </div>
    </div>

    <!-- Main content: chat + trace panel side by side -->
    <div class="flex flex-1 min-h-0">
      <!-- Chat column -->
      <div class="flex flex-col flex-1 min-w-0">
        <!-- Messages area (relative for scroll-to-bottom button) -->
        <div class="relative flex-1">
          <div id="messages" class="absolute inset-0 overflow-y-auto px-4 py-6 space-y-4">
            <!-- Empty state -->
            <div id="empty-state" class="flex flex-col items-center justify-center h-full text-center">
              <div class="w-16 h-16 rounded-full bg-subtle flex items-center justify-center mb-4">
                <span class="text-muted" set:html={botIcon} />
              </div>
              <h3 class="text-lg font-medium text-dark mb-2">Chat Playground</h3>
              <p class="text-sm text-muted max-w-sm">Select an agent above and start chatting. Messages stream in real-time via WebSocket.</p>
            </div>
          </div>

          <!-- Scroll to bottom button -->
          <button
            id="scroll-bottom-btn"
            class="absolute bottom-4 left-1/2 -translate-x-1/2 hidden items-center gap-1.5 px-3 py-1.5 bg-dark text-paper text-xs rounded-full shadow-lg hover:opacity-90 transition-all z-10"
            title="Scroll to bottom"
          >
            <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
            New messages
          </button>
        </div>

        <!-- Input area -->
        <div class="flex-shrink-0 border-t border-dark/[0.08] bg-paper px-4 py-3">
          <div id="connection-status" class="hidden text-xs text-coral mb-2 px-1"></div>
          <div class="flex items-end gap-3 max-w-4xl mx-auto">
            <textarea
              id="message-input"
              rows="1"
              placeholder="Type a message... (Enter to send, Shift+Enter for newline)"
              disabled
              class="flex-1 px-4 py-2.5 text-sm border border-dark/[0.08] rounded-xl bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors resize-none max-h-40 disabled:opacity-50"
            ></textarea>
            <button
              id="send-btn"
              disabled
              class="flex-shrink-0 p-2.5 bg-coral text-white rounded-xl hover:bg-coral/90 transition-colors disabled:opacity-40 disabled:cursor-not-allowed"
              title="Send message"
            >
              <span set:html={sendIcon} />
            </button>
          </div>
        </div>
      </div>

      <!-- Trace panel (collapsible right panel) -->
      <div
        id="trace-panel"
        class="hidden flex-shrink-0 w-80 lg:w-96 border-l border-dark/[0.08] bg-paper flex flex-col transition-all duration-200"
      >
        <!-- Trace panel header -->
        <div class="flex items-center justify-between px-4 py-3 border-b border-dark/[0.08]">
          <h3 class="text-sm font-medium text-dark">Execution Trace</h3>
          <button
            id="trace-close-btn"
            class="p-1 rounded text-muted hover:text-dark hover:bg-subtle transition-colors"
            title="Close trace panel"
          >
            <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
        <!-- Trace entries list -->
        <div id="trace-entries" class="flex-1 overflow-y-auto px-3 py-3 space-y-2">
          <div id="trace-empty" class="flex flex-col items-center justify-center h-full text-center px-4">
            <div class="w-10 h-10 rounded-full bg-subtle flex items-center justify-center mb-3">
              <span class="text-muted" set:html={traceIcon} />
            </div>
            <p class="text-xs text-muted">Execution traces will appear here as the agent responds.</p>
            <p class="text-[10px] text-muted/60 mt-1">Toggle with <kbd class="px-1 py-0.5 bg-subtle rounded text-[10px]">Cmd+I</kbd></p>
          </div>
        </div>
      </div>
    </div>
  </div>
</PageLayout>

<script>
import { marked } from "marked";

// Configure marked for safe rendering
marked.setOptions({
  breaks: true,
  gfm: true,
});

const agentSelect = document.getElementById("agent-select") as HTMLSelectElement;
const agentInfo = document.getElementById("agent-info")!;
const agentModel = document.getElementById("agent-model")!;
const messagesEl = document.getElementById("messages")!;
const emptyState = document.getElementById("empty-state")!;
const messageInput = document.getElementById("message-input") as HTMLTextAreaElement;
const sendBtn = document.getElementById("send-btn") as HTMLButtonElement;
const clearBtn = document.getElementById("clear-btn")!;
const connectionStatus = document.getElementById("connection-status")!;
const scrollBottomBtn = document.getElementById("scroll-bottom-btn")!;
const tracePanel = document.getElementById("trace-panel")!;
const traceToggleBtn = document.getElementById("trace-toggle-btn")!;
const traceCloseBtn = document.getElementById("trace-close-btn")!;
const traceEntries = document.getElementById("trace-entries")!;
const traceEmpty = document.getElementById("trace-empty")!;

let ws: WebSocket | null = null;
let currentAgentId: string | null = null;
let currentConversationId: string | null = null;
let agents: Array<{ id: string; name: string; model_provider?: string; model_name?: string }> = [];
let isStreaming = false;
let userScrolledUp = false;
let tracePanelOpen = false;
let traceCounter = 0;

interface ToolCallTrace {
  name: string;
  arguments: string;
  result?: string;
  error?: string;
  duration_ms?: number;
}

interface TraceEntry {
  id: number;
  timestamp: number;
  usage: { prompt_tokens?: number; completion_tokens?: number } | null;
  contentPreview: string;
  model?: string;
  finish_reason?: string;
  latency_ms?: number;
  tool_calls: ToolCallTrace[];
  reasoning?: string;
  error?: string;
}

const traceData: TraceEntry[] = [];

/* Pending trace data accumulated between messages */
let pendingToolCalls: ToolCallTrace[] = [];
let pendingReasoning = "";

const CHEVRON_DOWN = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>';
const CHEVRON_RIGHT = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>';

const COPY_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
const CHECK_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';

/* ---- Trace panel ---- */
function toggleTracePanel() {
  tracePanelOpen = !tracePanelOpen;
  if (tracePanelOpen) {
    tracePanel.classList.remove("hidden");
    traceToggleBtn.classList.add("text-coral");
    traceToggleBtn.classList.remove("text-muted");
  } else {
    tracePanel.classList.add("hidden");
    traceToggleBtn.classList.remove("text-coral");
    traceToggleBtn.classList.add("text-muted");
  }
}

interface TraceFinishData {
  usage: { prompt_tokens?: number; completion_tokens?: number } | null;
  model?: string;
  finish_reason?: string;
  latency_ms?: number;
}

function addTraceEntry(data: TraceFinishData, contentPreview: string) {
  traceCounter++;
  const entry: TraceEntry = {
    id: traceCounter,
    timestamp: Date.now(),
    usage: data.usage,
    contentPreview: contentPreview.slice(0, 120) + (contentPreview.length > 120 ? "..." : ""),
    model: data.model,
    finish_reason: data.finish_reason,
    latency_ms: data.latency_ms,
    tool_calls: [...pendingToolCalls],
    reasoning: pendingReasoning || undefined,
  };
  traceData.push(entry);
  pendingToolCalls = [];
  pendingReasoning = "";
  traceEmpty.classList.add("hidden");
  renderTraceEntry(entry);
}

/* Finish reason badge colors */
const FINISH_REASON_STYLES: Record<string, string> = {
  stop: "bg-zen-green/10 text-zen-green",
  end_turn: "bg-zen-green/10 text-zen-green",
  STOP: "bg-zen-green/10 text-zen-green",
  tool_calls: "bg-zen-blue/10 text-zen-blue",
  tool_use: "bg-zen-blue/10 text-zen-blue",
  length: "bg-coral/10 text-coral",
  MAX_TOKENS: "bg-coral/10 text-coral",
  content_filter: "bg-coral/10 text-coral",
  SAFETY: "bg-coral/10 text-coral",
};

/* SVG icons for trace sections */
const TOOL_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>';
const MODEL_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 0 0-4 4v2H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2h-2V6a4 4 0 0 0-4-4z"/><circle cx="12" cy="15" r="2"/></svg>';
const THINKING_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>';
const ERROR_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';

function makeCollapsibleSection(icon: string, title: string, content: HTMLElement, defaultOpen?: boolean): HTMLElement {
  const section = document.createElement("div");
  section.className = "mb-2";

  const sectionHeader = document.createElement("button");
  sectionHeader.type = "button";
  sectionHeader.className = "w-full flex items-center gap-1.5 py-1 text-left hover:opacity-80 transition-opacity";

  const sectionChevron = document.createElement("span");
  sectionChevron.className = "flex-shrink-0 text-muted";
  sectionChevron.innerHTML = defaultOpen ? CHEVRON_DOWN : CHEVRON_RIGHT;

  const sectionIcon = document.createElement("span");
  sectionIcon.className = "flex-shrink-0 text-muted";
  sectionIcon.innerHTML = icon;

  const sectionTitle = document.createElement("span");
  sectionTitle.className = "text-[10px] font-medium text-muted uppercase tracking-wide";
  sectionTitle.textContent = title;

  sectionHeader.appendChild(sectionChevron);
  sectionHeader.appendChild(sectionIcon);
  sectionHeader.appendChild(sectionTitle);

  const sectionBody = document.createElement("div");
  sectionBody.className = defaultOpen ? "ml-5 mt-1" : "hidden ml-5 mt-1";
  sectionBody.appendChild(content);

  let sectionOpen = !!defaultOpen;
  sectionHeader.addEventListener("click", function() {
    sectionOpen = !sectionOpen;
    sectionBody.classList.toggle("hidden", !sectionOpen);
    sectionChevron.innerHTML = sectionOpen ? CHEVRON_DOWN : CHEVRON_RIGHT;
  });

  section.appendChild(sectionHeader);
  section.appendChild(sectionBody);
  return section;
}

function formatJson(jsonStr: string): string {
  try {
    return JSON.stringify(JSON.parse(jsonStr), null, 2);
  } catch {
    return jsonStr;
  }
}

function renderTraceEntry(entry: TraceEntry) {
  const el = document.createElement("div");
  el.className = "border border-dark/[0.06] rounded-lg overflow-hidden";

  const header = document.createElement("button");
  header.className = "w-full flex items-center gap-2 px-3 py-2 text-left hover:bg-subtle/50 transition-colors";
  header.type = "button";

  const chevron = document.createElement("span");
  chevron.className = "flex-shrink-0 text-muted transition-transform";
  chevron.innerHTML = CHEVRON_RIGHT;

  const labelWrap = document.createElement("span");
  labelWrap.className = "flex-1 flex items-center gap-1.5 min-w-0";

  const label = document.createElement("span");
  label.className = "text-xs font-medium text-dark truncate";
  label.textContent = "Response #" + entry.id;

  labelWrap.appendChild(label);

  /* Finish reason badge */
  if (entry.finish_reason) {
    const badge = document.createElement("span");
    const styles = FINISH_REASON_STYLES[entry.finish_reason] || "bg-subtle text-muted";
    badge.className = "flex-shrink-0 text-[9px] font-medium px-1.5 py-0.5 rounded-full " + styles;
    badge.textContent = entry.finish_reason;
    labelWrap.appendChild(badge);
  }

  const timeEl = document.createElement("span");
  timeEl.className = "text-[10px] text-muted/60 flex-shrink-0 tabular-nums";
  const d = new Date(entry.timestamp);
  let timeText = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  if (entry.latency_ms !== undefined) {
    timeText += " · " + entry.latency_ms + "ms";
  }
  timeEl.textContent = timeText;

  header.appendChild(chevron);
  header.appendChild(labelWrap);
  header.appendChild(timeEl);

  const body = document.createElement("div");
  body.className = "hidden px-3 pb-3 pt-1 border-t border-dark/[0.04] space-y-1";

  /* Model call section */
  if (entry.model || entry.usage) {
    const modelContent = document.createElement("div");
    modelContent.className = "space-y-1";

    if (entry.model) {
      const modelLine = document.createElement("div");
      modelLine.className = "text-[11px] text-dark";
      modelLine.innerHTML = '<span class="text-muted">Model:</span> <span class="font-medium">' + escapeHtml(entry.model) + '</span>';
      modelContent.appendChild(modelLine);
    }

    if (entry.usage) {
      const usageGrid = document.createElement("div");
      usageGrid.className = "grid grid-cols-3 gap-1";
      if (entry.usage.prompt_tokens) {
        const pt = document.createElement("div");
        pt.className = "text-[11px] text-dark";
        pt.innerHTML = '<span class="text-muted">In:</span> ' + entry.usage.prompt_tokens.toLocaleString();
        usageGrid.appendChild(pt);
      }
      if (entry.usage.completion_tokens) {
        const ct = document.createElement("div");
        ct.className = "text-[11px] text-dark";
        ct.innerHTML = '<span class="text-muted">Out:</span> ' + entry.usage.completion_tokens.toLocaleString();
        usageGrid.appendChild(ct);
      }
      const total = (entry.usage.prompt_tokens || 0) + (entry.usage.completion_tokens || 0);
      if (total > 0) {
        const tt = document.createElement("div");
        tt.className = "text-[11px] text-dark";
        tt.innerHTML = '<span class="text-muted">Total:</span> ' + total.toLocaleString();
        usageGrid.appendChild(tt);
      }
      modelContent.appendChild(usageGrid);
    }

    if (entry.latency_ms !== undefined) {
      const latencyLine = document.createElement("div");
      latencyLine.className = "text-[11px] text-dark";
      latencyLine.innerHTML = '<span class="text-muted">Latency:</span> ' + entry.latency_ms.toLocaleString() + 'ms';
      modelContent.appendChild(latencyLine);
    }

    body.appendChild(makeCollapsibleSection(MODEL_ICON, "Model Call", modelContent, true));
  }

  /* Tool calls section */
  if (entry.tool_calls.length > 0) {
    const toolsContent = document.createElement("div");
    toolsContent.className = "space-y-2";

    entry.tool_calls.forEach(function(tc) {
      const tcEl = document.createElement("div");
      tcEl.className = "border border-dark/[0.06] rounded p-2 space-y-1";

      const nameRow = document.createElement("div");
      nameRow.className = "flex items-center gap-1.5";
      const nameLabel = document.createElement("span");
      nameLabel.className = "text-[11px] font-medium text-zen-blue";
      nameLabel.textContent = tc.name;
      nameRow.appendChild(nameLabel);
      if (tc.duration_ms !== undefined) {
        const dur = document.createElement("span");
        dur.className = "text-[10px] text-muted/60 ml-auto tabular-nums";
        dur.textContent = tc.duration_ms + "ms";
        nameRow.appendChild(dur);
      }
      tcEl.appendChild(nameRow);

      /* Arguments — collapsible JSON */
      if (tc.arguments) {
        const argsLabel = document.createElement("div");
        argsLabel.className = "text-[10px] text-muted";
        argsLabel.textContent = "Arguments:";
        tcEl.appendChild(argsLabel);

        const argsBlock = document.createElement("pre");
        argsBlock.className = "text-[10px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        argsBlock.textContent = formatJson(tc.arguments);
        tcEl.appendChild(argsBlock);
      }

      /* Result */
      if (tc.result) {
        const resLabel = document.createElement("div");
        resLabel.className = "text-[10px] text-muted mt-1";
        resLabel.textContent = "Result:";
        tcEl.appendChild(resLabel);

        const resBlock = document.createElement("pre");
        resBlock.className = "text-[10px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        resBlock.textContent = formatJson(tc.result);
        tcEl.appendChild(resBlock);
      }

      /* Error */
      if (tc.error) {
        const errLabel = document.createElement("div");
        errLabel.className = "text-[10px] text-coral mt-1";
        errLabel.textContent = "Error:";
        tcEl.appendChild(errLabel);

        const errBlock = document.createElement("pre");
        errBlock.className = "text-[10px] text-coral/70 bg-coral/5 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        errBlock.textContent = tc.error;
        tcEl.appendChild(errBlock);
      }

      toolsContent.appendChild(tcEl);
    });

    body.appendChild(makeCollapsibleSection(TOOL_ICON, "Tool Calls (" + entry.tool_calls.length + ")", toolsContent));
  }

  /* Reasoning section */
  if (entry.reasoning) {
    const reasoningContent = document.createElement("div");
    const reasoningText = document.createElement("div");
    reasoningText.className = "text-[11px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 whitespace-pre-wrap break-words max-h-60 overflow-y-auto";
    reasoningText.textContent = entry.reasoning;
    reasoningContent.appendChild(reasoningText);
    body.appendChild(makeCollapsibleSection(THINKING_ICON, "Reasoning", reasoningContent));
  }

  /* Error display */
  if (entry.error) {
    const errorContent = document.createElement("div");
    const errorText = document.createElement("pre");
    errorText.className = "text-[11px] text-coral bg-coral/5 rounded px-2 py-1.5 whitespace-pre-wrap break-words max-h-60 overflow-y-auto font-mono";
    errorText.textContent = entry.error;
    errorContent.appendChild(errorText);
    body.appendChild(makeCollapsibleSection(ERROR_ICON, "Error", errorContent, true));
  }

  /* Content preview */
  const previewSection = document.createElement("div");
  const previewLabel = document.createElement("div");
  previewLabel.className = "text-[10px] font-medium text-muted uppercase tracking-wide mb-1";
  previewLabel.textContent = "Response Preview";
  previewSection.appendChild(previewLabel);
  const previewText = document.createElement("div");
  previewText.className = "text-[11px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 whitespace-pre-wrap break-words";
  previewText.textContent = entry.contentPreview || "(empty response)";
  previewSection.appendChild(previewText);
  body.appendChild(previewSection);

  /* Toggle expand/collapse */
  let expanded = false;
  header.addEventListener("click", function() {
    expanded = !expanded;
    if (expanded) {
      body.classList.remove("hidden");
      chevron.innerHTML = CHEVRON_DOWN;
    } else {
      body.classList.add("hidden");
      chevron.innerHTML = CHEVRON_RIGHT;
    }
  });

  el.appendChild(header);
  el.appendChild(body);
  traceEntries.appendChild(el);

  /* Auto-scroll trace panel to latest entry */
  traceEntries.scrollTop = traceEntries.scrollHeight;
}

function escapeHtml(str: string): string {
  const div = document.createElement("div");
  div.textContent = str;
  return div.innerHTML;
}

function clearTraceEntries() {
  traceData.length = 0;
  traceCounter = 0;
  pendingToolCalls = [];
  pendingReasoning = "";
  const children = Array.from(traceEntries.children);
  children.forEach(function(c) {
    if (c.id !== "trace-empty") traceEntries.removeChild(c);
  });
  traceEmpty.classList.remove("hidden");
}

traceToggleBtn.addEventListener("click", toggleTracePanel);
traceCloseBtn.addEventListener("click", toggleTracePanel);

/* ---- Load agents ---- */
async function loadAgents() {
  try {
    const res = await fetch("/api/agents", { credentials: "same-origin" });
    if (!res.ok) return;
    agents = await res.json();
    agentSelect.innerHTML = '<option value="">Select an agent...</option>';
    agents.forEach(function(a) {
      const opt = document.createElement("option");
      opt.value = a.id;
      opt.textContent = a.name + (a.model_provider ? " (" + a.model_provider + ")" : "");
      agentSelect.appendChild(opt);
    });
  } catch (e) {
    console.error("Failed to load agents:", e);
  }
}

/* ---- WebSocket management ---- */
function connectWebSocket(agentId: string, conversationId?: string) {
  if (ws) {
    ws.close();
    ws = null;
  }

  currentAgentId = agentId;
  currentConversationId = conversationId || null;
  const proto = location.protocol === "https:" ? "wss:" : "ws:";
  const url = proto + "//" + location.host + "/api/playground/" + agentId + "/chat";

  connectionStatus.classList.add("hidden");
  connectionStatus.textContent = "";

  ws = new WebSocket(url);

  ws.onopen = function() {
    messageInput.disabled = false;
    sendBtn.disabled = false;
    messageInput.focus();
    // Load existing conversation if specified
    if (conversationId && ws) {
      ws.send(JSON.stringify({ type: "load_conversation", conversation_id: conversationId }));
    }
  };

  ws.onclose = function(e) {
    if (e.code === 4001) {
      showStatus("Authentication required. Please log in.");
    } else if (e.code === 4004) {
      showStatus("Agent not found.");
    } else if (e.code !== 1000 && e.code !== 1001) {
      showStatus("Connection closed (code " + e.code + ")");
    }
    messageInput.disabled = true;
    sendBtn.disabled = true;
    isStreaming = false;
    ws = null;
  };

  ws.onerror = function() {
    showStatus("WebSocket connection error.");
  };

  ws.onmessage = function(event) {
    let data;
    try {
      data = JSON.parse(event.data);
    } catch (_e) {
      return;
    }

    if (data.type === "token") {
      appendToken(data.content);
    } else if (data.type === "done") {
      finishStream(data);
    } else if (data.type === "tool_call") {
      pendingToolCalls.push({
        name: data.name || "unknown",
        arguments: data.arguments || "",
        result: data.result,
        error: data.error,
        duration_ms: data.duration_ms,
      });
    } else if (data.type === "reasoning") {
      pendingReasoning += (pendingReasoning ? "\n" : "") + (data.content || "");
    } else if (data.type === "error") {
      appendError(data.message);
      isStreaming = false;
      messageInput.disabled = false;
      sendBtn.disabled = false;
    } else if (data.type === "conversation_created") {
      currentConversationId = data.conversation_id;
    } else if (data.type === "conversation_loaded") {
      currentConversationId = data.conversation_id;
      restoreMessages(data.messages);
    }
  };
}

function disconnectWebSocket() {
  if (ws) {
    ws.close();
    ws = null;
  }
  currentAgentId = null;
  messageInput.disabled = true;
  sendBtn.disabled = true;
}

function showStatus(msg: string) {
  connectionStatus.textContent = msg;
  connectionStatus.classList.remove("hidden");
}

/* ---- Copy button helper ---- */
function createCopyButton(getText: () => string): HTMLButtonElement {
  const btn = document.createElement("button");
  btn.className = "copy-msg-btn absolute top-2 right-2 p-1 rounded bg-subtle/80 text-muted hover:text-dark opacity-0 group-hover:opacity-100 transition-opacity";
  btn.title = "Copy message";
  btn.innerHTML = COPY_ICON;
  btn.addEventListener("click", function() {
    navigator.clipboard.writeText(getText()).then(function() {
      btn.innerHTML = CHECK_ICON;
      btn.classList.add("text-zen-green");
      setTimeout(function() {
        btn.innerHTML = COPY_ICON;
        btn.classList.remove("text-zen-green");
      }, 1500);
    });
  });
  return btn;
}

/* ---- Restore saved messages ---- */
function restoreMessages(messages: Array<{ role: string; content: string }>) {
  messages.forEach(function(m) {
    if (m.role === "user") {
      addUserMessage(m.content);
    } else if (m.role === "assistant") {
      addRestoredAgentMessage(m.content);
    }
    // Skip system messages — they're not displayed
  });
}

function addRestoredAgentMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
  bubble.innerHTML = renderMarkdown(text);

  const copyBtn = createCopyButton(() => text);
  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  wrapper.appendChild(copyBtn);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Message rendering ---- */
function hideEmptyState() {
  emptyState.classList.add("hidden");
}

function showEmptyState() {
  emptyState.classList.remove("hidden");
}

function renderMarkdown(text: string): string {
  return marked.parse(text) as string;
}

function addUserMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-end";

  const bubble = document.createElement("div");
  bubble.className = "max-w-[75%] sm:max-w-[60%] relative group";

  const inner = document.createElement("div");
  inner.className = "px-4 py-2.5 rounded-2xl rounded-br-sm bg-subtle text-dark text-sm whitespace-pre-wrap break-words";
  inner.textContent = text;

  const copyBtn = createCopyButton(() => text);
  bubble.appendChild(inner);
  bubble.appendChild(copyBtn);
  row.appendChild(bubble);
  messagesEl.appendChild(row);
  scrollToBottom();
}

let currentStreamBubble: HTMLElement | null = null;
let streamedContent = "";

function startAgentMessage() {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm whitespace-pre-wrap break-words min-w-0";
  bubble.textContent = "";

  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);

  currentStreamBubble = bubble;
  streamedContent = "";
  scrollToBottom();
}

function appendToken(token: string) {
  if (!currentStreamBubble) {
    startAgentMessage();
  }
  streamedContent += token;
  currentStreamBubble!.textContent = streamedContent;
  scrollToBottom();
}

function finishStream(data: { usage?: { prompt_tokens?: number; completion_tokens?: number } | null; model?: string; finish_reason?: string; latency_ms?: number }) {
  const usage = data.usage || null;
  if (currentStreamBubble) {
    // Render markdown now that streaming is complete
    const rawText = streamedContent;
    currentStreamBubble.textContent = "";
    currentStreamBubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
    currentStreamBubble.innerHTML = renderMarkdown(rawText);

    // Add copy button to the wrapper (which is the parent of bubble)
    const wrapper = currentStreamBubble.parentElement!;
    const copyBtn = createCopyButton(() => rawText);
    wrapper.appendChild(copyBtn);

    if (usage) {
      const meta = document.createElement("div");
      meta.className = "text-[10px] text-muted/60 mt-1.5 text-right";
      const parts: string[] = [];
      if (usage.prompt_tokens) parts.push(usage.prompt_tokens + " in");
      if (usage.completion_tokens) parts.push(usage.completion_tokens + " out");
      if (parts.length > 0) {
        meta.textContent = parts.join(" / ") + " tokens";
        wrapper.appendChild(meta);
      }
    }

    /* Add trace entry for this response */
    addTraceEntry({
      usage: usage,
      model: data.model,
      finish_reason: data.finish_reason,
      latency_ms: data.latency_ms,
    }, rawText);
  }
  currentStreamBubble = null;
  streamedContent = "";
  isStreaming = false;
  messageInput.disabled = false;
  sendBtn.disabled = false;
  messageInput.focus();
  scrollToBottom();
}

function appendError(msg: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-center";
  const pill = document.createElement("div");
  pill.className = "px-4 py-2 rounded-xl bg-coral/10 text-coral text-xs max-w-md text-center";
  pill.textContent = msg;
  row.appendChild(pill);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Scroll management ---- */
function isNearBottom(): boolean {
  const threshold = 80;
  return messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < threshold;
}

function scrollToBottom() {
  if (!userScrolledUp) {
    requestAnimationFrame(function() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }
}

function updateScrollButton() {
  if (isNearBottom()) {
    userScrolledUp = false;
    scrollBottomBtn.classList.add("hidden");
    scrollBottomBtn.classList.remove("flex");
  } else {
    userScrolledUp = true;
    scrollBottomBtn.classList.remove("hidden");
    scrollBottomBtn.classList.add("flex");
  }
}

messagesEl.addEventListener("scroll", updateScrollButton);

scrollBottomBtn.addEventListener("click", function() {
  userScrolledUp = false;
  messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: "smooth" });
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
});

function clearMessages() {
  /* Remove all children except the empty state */
  const children = Array.from(messagesEl.children);
  children.forEach(function(c) {
    if (c.id !== "empty-state") messagesEl.removeChild(c);
  });
  showEmptyState();
  currentStreamBubble = null;
  streamedContent = "";
  currentConversationId = null;
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  clearTraceEntries();
  /* Reconnect to reset conversation history on server (new conversation) */
  if (currentAgentId) {
    connectWebSocket(currentAgentId);
  }
}

/* ---- Send message ---- */
function sendMessage() {
  const text = messageInput.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN || isStreaming) return;

  addUserMessage(text);
  ws.send(JSON.stringify({ content: text }));
  messageInput.value = "";
  autoResize();
  isStreaming = true;
  messageInput.disabled = true;
  sendBtn.disabled = true;
  /* Reset scroll tracking so auto-scroll works for the new response */
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  startAgentMessage();
}

/* ---- Auto-resize textarea ---- */
function autoResize() {
  messageInput.style.height = "auto";
  messageInput.style.height = Math.min(messageInput.scrollHeight, 160) + "px";
}

/* ---- Event listeners ---- */
agentSelect.addEventListener("change", function() {
  const val = agentSelect.value;
  if (!val) {
    disconnectWebSocket();
    agentInfo.classList.add("hidden");
    return;
  }
  /* Show model info */
  const agent = agents.find(function(a) { return a.id === val; });
  if (agent && agent.model_provider) {
    agentModel.textContent = agent.model_provider + (agent.model_name ? ":" + agent.model_name : "");
    agentInfo.classList.remove("hidden");
  } else {
    agentInfo.classList.add("hidden");
  }
  clearMessages();
  connectWebSocket(val);
});

messageInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

/* Cmd+I / Ctrl+I to toggle trace panel */
document.addEventListener("keydown", function(e) {
  if ((e.metaKey || e.ctrlKey) && e.key === "i") {
    e.preventDefault();
    toggleTracePanel();
  }
});

messageInput.addEventListener("input", autoResize);

sendBtn.addEventListener("click", sendMessage);

clearBtn.addEventListener("click", clearMessages);

/* ---- Init ---- */
loadAgents();
</script>
