---
import PageLayout from "../layouts/PageLayout.astro";

const breadcrumbs = [{ label: "Playground" }];

/* Icons */
const sendIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
const botIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';
const clearIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>';
const traceIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>';
const compareIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="8" height="18" rx="1"/><rect x="14" y="3" width="8" height="18" rx="1"/></svg>';
const thumbUpIcon = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/></svg>';
const thumbDownIcon = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"/></svg>';
const downloadIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';
const micIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>';
const speakerOffIcon = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>';
---

<PageLayout
  title="Playground"
  description="Chat with your AI agents"
  activeSection="playground"
  breadcrumbs={breadcrumbs}
  class="!overflow-hidden flex flex-col"
>
  <div class="flex flex-col h-full">
    <!-- Top bar: agent selector -->
    <div class="flex items-center gap-3 px-4 py-3 border-b border-dark/[0.08] bg-paper flex-shrink-0">
      <label for="agent-select" class="text-sm font-medium text-dark whitespace-nowrap">Agent:</label>
      <select
        id="agent-select"
        class="flex-1 max-w-xs px-3 py-1.5 text-sm border border-dark/[0.08] rounded-lg bg-paper text-dark focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors"
      >
        <option value="">Select an agent...</option>
      </select>
      <div id="agent-info" class="text-xs text-muted hidden">
        <span id="agent-model" class="inline-flex items-center gap-1 px-2 py-0.5 bg-subtle rounded-full"></span>
      </div>
      <!-- Agent status badge -->
      <div id="agent-status-badge" class="hidden">
        <span id="agent-status-text" class="inline-flex items-center gap-1.5 px-2.5 py-1 text-xs font-medium rounded-full"></span>
      </div>
      <div class="ml-auto flex items-center gap-1">
        <button
          id="thread-toggle-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Toggle thread sidebar"
        >
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
          <span class="hidden sm:inline">Threads</span>
        </button>
        <button
          id="compare-toggle-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Toggle compare mode"
        >
          <span set:html={compareIcon} />
          <span class="hidden sm:inline">Compare</span>
        </button>
        <button
          id="trace-toggle-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Toggle trace panel (Cmd+I)"
        >
          <span set:html={traceIcon} />
          <span class="hidden sm:inline">Trace</span>
        </button>
        <button
          id="tts-toggle-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Toggle text-to-speech for responses"
        >
          <span id="tts-icon" set:html={speakerOffIcon} />
          <span class="hidden sm:inline">TTS</span>
        </button>
        <button
          id="clear-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Clear conversation"
        >
          <span set:html={clearIcon} />
          <span class="hidden sm:inline">Clear</span>
        </button>
      </div>
    </div>

    <!-- Compare mode: model picker bar (hidden by default) -->
    <div id="compare-bar" class="hidden border-b border-dark/[0.08] bg-subtle/30 px-4 py-2 flex-shrink-0">
      <div class="flex items-center gap-2 flex-wrap">
        <span class="text-xs font-medium text-dark whitespace-nowrap">Models:</span>
        <div id="compare-model-slots" class="flex items-center gap-2 flex-wrap flex-1">
          <select id="compare-add-model" class="px-2 py-1 text-xs border border-dark/[0.08] rounded-lg bg-paper text-dark focus:outline-none focus:ring-2 focus:ring-coral/20">
            <option value="">+ Add model...</option>
          </select>
        </div>
        <button
          id="compare-export-btn"
          class="inline-flex items-center gap-1 px-2 py-1 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Export comparison as JSON"
        >
          <span set:html={downloadIcon} />
          <span class="hidden sm:inline">Export</span>
        </button>
      </div>
    </div>

    <!-- Compare mode: side-by-side columns (hidden by default) -->
    <div id="compare-container" class="hidden flex-1 flex flex-col min-h-0">
      <div id="compare-columns" class="flex flex-1 min-h-0 divide-x divide-dark/[0.08] overflow-x-auto">
        <!-- Columns are added dynamically -->
      </div>
      <!-- Compare input area -->
      <div class="flex-shrink-0 border-t border-dark/[0.08] bg-paper px-4 py-3">
        <div id="compare-connection-status" class="hidden text-xs text-coral mb-2 px-1"></div>
        <div class="flex items-end gap-3 max-w-4xl mx-auto">
          <textarea
            id="compare-message-input"
            rows="1"
            placeholder="Type a message to send to all models... (Enter to send)"
            disabled
            class="flex-1 px-4 py-2.5 text-sm border border-dark/[0.08] rounded-xl bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors resize-none max-h-40 disabled:opacity-50"
          ></textarea>
          <button
            id="compare-send-btn"
            disabled
            class="flex-shrink-0 p-2.5 bg-coral text-white rounded-xl hover:bg-coral/90 transition-colors disabled:opacity-40 disabled:cursor-not-allowed"
            title="Send to all models"
          >
            <span set:html={sendIcon} />
          </button>
        </div>
      </div>
    </div>

    <!-- Main content: thread sidebar + chat + trace panel -->
    <div id="normal-chat-container" class="flex flex-1 min-h-0">
      <!-- Thread sidebar (left) -->
      <div
        id="thread-sidebar"
        class="hidden flex-shrink-0 w-72 border-r border-dark/[0.08] bg-paper flex flex-col"
      >
        <!-- Sidebar header -->
        <div class="flex items-center justify-between px-3 py-2.5 border-b border-dark/[0.08]">
          <h3 class="text-sm font-medium text-dark">Threads</h3>
          <button
            id="thread-new-btn"
            class="p-1.5 rounded-lg text-coral hover:bg-coral/10 transition-colors"
            title="New thread"
          >
            <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          </button>
        </div>
        <!-- Search input -->
        <div class="px-3 py-2 border-b border-dark/[0.08]">
          <input
            id="thread-search"
            type="text"
            placeholder="Search threads..."
            class="w-full px-3 py-1.5 text-xs border border-dark/[0.08] rounded-lg bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors"
          />
        </div>
        <!-- Thread list -->
        <div id="thread-list" class="flex-1 overflow-y-auto">
          <div id="thread-empty" class="flex flex-col items-center justify-center h-full text-center px-4">
            <p class="text-xs text-muted">No threads yet. Select an agent and start chatting.</p>
          </div>
        </div>
      </div>

      <!-- Chat column -->
      <div class="flex flex-col flex-1 min-w-0">
        <!-- Thread metadata bar (hidden by default) -->
        <div id="thread-meta-bar" class="hidden px-4 py-2 border-b border-dark/[0.08] bg-subtle/30 flex-shrink-0">
          <div class="flex items-center gap-4 text-xs">
            <span class="text-muted">Agent: <span id="thread-meta-agent" class="text-dark font-medium"></span></span>
            <span class="text-muted">Tokens: <span id="thread-meta-tokens" class="text-dark font-medium tabular-nums">0</span></span>
            <span class="text-muted">Cost: <span id="thread-meta-cost" class="text-dark font-medium tabular-nums">$0.00</span></span>
            <span class="text-muted">Messages: <span id="thread-meta-count" class="text-dark font-medium tabular-nums">0</span></span>
          </div>
        </div>

        <!-- Messages area (relative for scroll-to-bottom button) -->
        <div class="relative flex-1">
          <div id="messages" class="absolute inset-0 overflow-y-auto px-4 py-6 space-y-4">
            <!-- Empty state -->
            <div id="empty-state" class="flex flex-col items-center justify-center h-full text-center">
              <div class="w-16 h-16 rounded-full bg-subtle flex items-center justify-center mb-4">
                <span class="text-muted" set:html={botIcon} />
              </div>
              <h3 class="text-lg font-medium text-dark mb-2">Chat Playground</h3>
              <p class="text-sm text-muted max-w-sm">Select an agent above and start chatting. Messages stream in real-time via WebSocket.</p>
            </div>
          </div>

          <!-- Scroll to bottom button -->
          <button
            id="scroll-bottom-btn"
            class="absolute bottom-4 left-1/2 -translate-x-1/2 hidden items-center gap-1.5 px-3 py-1.5 bg-dark text-paper text-xs rounded-full shadow-lg hover:opacity-90 transition-all z-10"
            title="Scroll to bottom"
          >
            <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
            New messages
          </button>
        </div>

        <!-- Takeover controls bar (shown when paused) -->
        <div id="takeover-bar" class="hidden flex-shrink-0 border-t border-coral/20 bg-coral/5 px-4 py-2.5">
          <div class="flex items-center gap-3 max-w-4xl mx-auto">
            <span class="text-xs font-medium text-coral whitespace-nowrap">Human Control</span>
            <textarea
              id="inject-input"
              rows="1"
              placeholder="Inject a message to the agent..."
              class="flex-1 px-3 py-2 text-sm border border-coral/20 rounded-xl bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors resize-none max-h-24"
            ></textarea>
            <button
              id="inject-btn"
              class="flex-shrink-0 px-3 py-2 text-xs font-medium bg-coral text-white rounded-lg hover:bg-coral/90 transition-colors"
              title="Send message and resume agent"
            >Inject &amp; Resume</button>
            <button
              id="resume-btn"
              class="flex-shrink-0 px-3 py-2 text-xs font-medium bg-zen-green text-white rounded-lg hover:bg-zen-green/90 transition-colors"
              title="Resume agent execution"
            >Resume</button>
            <button
              id="stop-btn"
              class="flex-shrink-0 px-3 py-2 text-xs font-medium bg-dark text-paper rounded-lg hover:bg-dark/80 transition-colors"
              title="Stop execution and save partial results"
            >Stop</button>
          </div>
        </div>

        <!-- Input area -->
        <div class="flex-shrink-0 border-t border-dark/[0.08] bg-paper px-4 py-3">
          <div id="connection-status" class="hidden text-xs text-coral mb-2 px-1"></div>
          <div class="flex items-end gap-3 max-w-4xl mx-auto">
            <textarea
              id="message-input"
              rows="1"
              placeholder="Type a message... (Enter to send, Shift+Enter for newline)"
              disabled
              class="flex-1 px-4 py-2.5 text-sm border border-dark/[0.08] rounded-xl bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors resize-none max-h-40 disabled:opacity-50"
            ></textarea>
            <button
              id="takeover-btn"
              class="hidden flex-shrink-0 px-3 py-2.5 text-xs font-medium border-2 border-coral text-coral rounded-xl hover:bg-coral hover:text-white transition-colors"
              title="Take over agent execution"
            >Take Over</button>
            <button
              id="mic-btn"
              disabled
              class="flex-shrink-0 p-2.5 text-muted hover:text-dark rounded-xl border border-dark/[0.08] hover:bg-subtle transition-colors disabled:opacity-40 disabled:cursor-not-allowed relative"
              title="Voice input (click to start/stop recording)"
            >
              <span id="mic-icon" set:html={micIcon} />
              <span id="mic-recording-dot" class="hidden absolute -top-1 -right-1 w-3 h-3 rounded-full bg-coral animate-pulse-dot"></span>
            </button>
            <button
              id="send-btn"
              disabled
              class="flex-shrink-0 p-2.5 bg-coral text-white rounded-xl hover:bg-coral/90 transition-colors disabled:opacity-40 disabled:cursor-not-allowed"
              title="Send message"
            >
              <span set:html={sendIcon} />
            </button>
          </div>
        </div>
      </div>

      <!-- Trace panel (collapsible right panel) -->
      <div
        id="trace-panel"
        class="hidden flex-shrink-0 w-80 lg:w-96 border-l border-dark/[0.08] bg-paper flex flex-col transition-all duration-200"
      >
        <!-- Trace panel header with tabs -->
        <div class="flex items-center justify-between px-4 py-2 border-b border-dark/[0.08]">
          <div class="flex items-center gap-1">
            <button
              id="trace-tab-btn"
              class="px-2.5 py-1 text-xs font-medium rounded-md transition-colors text-dark bg-subtle"
              data-tab="trace"
            >Trace</button>
            <button
              id="context-tab-btn"
              class="px-2.5 py-1 text-xs font-medium rounded-md transition-colors text-muted hover:text-dark"
              data-tab="context"
            >Context</button>
          </div>
          <button
            id="trace-close-btn"
            class="p-1 rounded text-muted hover:text-dark hover:bg-subtle transition-colors"
            title="Close trace panel"
          >
            <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
        <!-- Trace tab content -->
        <div id="trace-tab-content" class="flex flex-col flex-1 min-h-0">
          <!-- Cumulative usage summary -->
          <div id="trace-summary" class="hidden px-4 py-2 border-b border-dark/[0.08] bg-subtle/30">
            <div class="grid grid-cols-2 gap-x-4 gap-y-1">
              <div class="text-[10px] text-muted">Total Tokens</div>
              <div id="trace-total-tokens" class="text-[10px] text-dark font-medium text-right tabular-nums">0</div>
              <div class="text-[10px] text-muted">Input / Output</div>
              <div id="trace-io-tokens" class="text-[10px] text-dark text-right tabular-nums">0 / 0</div>
              <div class="text-[10px] text-muted">Est. Cost</div>
              <div id="trace-total-cost" class="text-[10px] text-dark font-medium text-right tabular-nums">$0.0000</div>
            </div>
          </div>
          <!-- Trace entries list -->
          <div id="trace-entries" class="flex-1 overflow-y-auto px-3 py-3 space-y-2">
            <div id="trace-empty" class="flex flex-col items-center justify-center h-full text-center px-4">
              <div class="w-10 h-10 rounded-full bg-subtle flex items-center justify-center mb-3">
                <span class="text-muted" set:html={traceIcon} />
              </div>
              <p class="text-xs text-muted">Execution traces will appear here as the agent responds.</p>
              <p class="text-[10px] text-muted/60 mt-1">Toggle with <kbd class="px-1 py-0.5 bg-subtle rounded text-[10px]">Cmd+I</kbd></p>
            </div>
          </div>
        </div>
        <!-- Context tab content -->
        <div id="context-tab-content" class="hidden flex flex-col flex-1 min-h-0">
          <!-- Step navigator -->
          <div id="context-step-nav" class="flex items-center gap-2 px-4 py-2 border-b border-dark/[0.08] bg-subtle/30">
            <button id="context-step-prev" class="p-0.5 rounded text-muted hover:text-dark disabled:opacity-30 transition-colors" disabled>
              <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
            </button>
            <span id="context-step-label" class="text-[10px] text-muted flex-1 text-center tabular-nums">Step 0 / 0</span>
            <button id="context-step-next" class="p-0.5 rounded text-muted hover:text-dark disabled:opacity-30 transition-colors" disabled>
              <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
            </button>
          </div>
          <!-- Context tree view -->
          <div id="context-tree" class="flex-1 overflow-y-auto px-3 py-3">
            <div id="context-empty" class="flex flex-col items-center justify-center h-full text-center px-4">
              <div class="w-10 h-10 rounded-full bg-subtle flex items-center justify-center mb-3">
                <svg class="h-5 w-5 text-muted" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v10"/><path d="M5.6 5.6l4.25 4.25m4.3 4.3L18.4 18.4"/><path d="M1 12h6m6 0h10"/><path d="M5.6 18.4l4.25-4.25m4.3-4.3L18.4 5.6"/></svg>
              </div>
              <p class="text-xs text-muted">Context state will appear here as the agent runs.</p>
              <p class="text-[10px] text-muted/60 mt-1">Shows hierarchical state, tokens & changes per step</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Delete thread confirmation dialog -->
  <dialog
    id="thread-delete-dialog"
    class="rounded-xl border border-dark/[0.08] shadow-xl p-0 backdrop:bg-dark/40 max-w-sm w-full"
  >
    <div class="p-6">
      <h3 class="text-base font-medium text-dark mb-2">Delete thread?</h3>
      <p class="text-sm text-muted mb-6">This will permanently delete this thread and all its messages. This action cannot be undone.</p>
      <div class="flex justify-end gap-3">
        <button
          id="thread-delete-cancel"
          class="px-4 py-2 text-sm text-muted hover:text-dark border border-dark/[0.08] rounded-lg hover:bg-subtle transition-colors"
        >Cancel</button>
        <button
          id="thread-delete-confirm"
          class="px-4 py-2 text-sm text-white bg-coral hover:bg-coral/90 rounded-lg transition-colors"
        >Delete</button>
      </div>
    </div>
  </dialog>
</PageLayout>

<script>
import { marked } from "marked";

// Configure marked for safe rendering
marked.setOptions({
  breaks: true,
  gfm: true,
});

const agentSelect = document.getElementById("agent-select") as HTMLSelectElement;
const agentInfo = document.getElementById("agent-info")!;
const agentModel = document.getElementById("agent-model")!;
const messagesEl = document.getElementById("messages")!;
const emptyState = document.getElementById("empty-state")!;
const messageInput = document.getElementById("message-input") as HTMLTextAreaElement;
const sendBtn = document.getElementById("send-btn") as HTMLButtonElement;
const clearBtn = document.getElementById("clear-btn")!;
const connectionStatus = document.getElementById("connection-status")!;
const scrollBottomBtn = document.getElementById("scroll-bottom-btn")!;
const tracePanel = document.getElementById("trace-panel")!;
const traceToggleBtn = document.getElementById("trace-toggle-btn")!;
const traceCloseBtn = document.getElementById("trace-close-btn")!;
const traceEntries = document.getElementById("trace-entries")!;
const traceEmpty = document.getElementById("trace-empty")!;

/* Tab & context inspector elements */
const traceTabBtn = document.getElementById("trace-tab-btn")!;
const contextTabBtn = document.getElementById("context-tab-btn")!;
const traceTabContent = document.getElementById("trace-tab-content")!;
const contextTabContent = document.getElementById("context-tab-content")!;
const contextTree = document.getElementById("context-tree")!;
const contextEmpty = document.getElementById("context-empty")!;
const contextStepLabel = document.getElementById("context-step-label")!;
const contextStepPrev = document.getElementById("context-step-prev") as HTMLButtonElement;
const contextStepNext = document.getElementById("context-step-next") as HTMLButtonElement;

let ws: WebSocket | null = null;
let currentAgentId: string | null = null;
let currentConversationId: string | null = null;
let agents: Array<{ id: string; name: string; model_provider?: string; model_name?: string }> = [];
let isStreaming = false;
let userScrolledUp = false;
let tracePanelOpen = false;
let traceCounter = 0;

/* Takeover elements & state */
const agentStatusBadge = document.getElementById("agent-status-badge")!;
const agentStatusText = document.getElementById("agent-status-text")!;
const takeoverBtn = document.getElementById("takeover-btn") as HTMLButtonElement;
const takeoverBar = document.getElementById("takeover-bar")!;
const injectInput = document.getElementById("inject-input") as HTMLTextAreaElement;
const injectBtn = document.getElementById("inject-btn") as HTMLButtonElement;
const resumeBtn = document.getElementById("resume-btn") as HTMLButtonElement;
const stopBtn = document.getElementById("stop-btn") as HTMLButtonElement;
let isPaused = false;

/* Voice input & TTS state */
const micBtn = document.getElementById("mic-btn") as HTMLButtonElement;
const micRecordingDot = document.getElementById("mic-recording-dot")!;
const ttsToggleBtn = document.getElementById("tts-toggle-btn")!;
const ttsIconEl = document.getElementById("tts-icon")!;
let isRecording = false;
let autoSendOnVoice = true;
let ttsEnabled = false;

const SpeechRecognitionAPI = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
let speechRecognition: any = null;
const hasSpeechSynthesis = "speechSynthesis" in window;

const SPEAKER_ON_SVG = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';
const SPEAKER_OFF_SVG = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>';

/* Pricing & cumulative usage */
interface PricingEntry {
  model_name: string;
  provider_type: string;
  pricing_input: number | null;
  pricing_output: number | null;
}
let pricingData: PricingEntry[] = [];
let cumulativePromptTokens = 0;
let cumulativeCompletionTokens = 0;
let cumulativeCost = 0;

const traceSummary = document.getElementById("trace-summary")!;
const traceTotalTokens = document.getElementById("trace-total-tokens")!;
const traceIoTokens = document.getElementById("trace-io-tokens")!;
const traceTotalCost = document.getElementById("trace-total-cost")!;

function formatCost(cost: number): string {
  if (cost < 0.01) return "$" + cost.toFixed(4);
  return "$" + cost.toFixed(2);
}

function calcCost(model: string | undefined, promptTokens: number, completionTokens: number): number {
  if (!model) return 0;
  const pricing = pricingData.find(function(p) { return p.model_name === model; });
  if (!pricing) return 0;
  const inCost = pricing.pricing_input ? (promptTokens / 1000) * pricing.pricing_input : 0;
  const outCost = pricing.pricing_output ? (completionTokens / 1000) * pricing.pricing_output : 0;
  return inCost + outCost;
}

function updateCumulativeSummary() {
  const total = cumulativePromptTokens + cumulativeCompletionTokens;
  traceTotalTokens.textContent = total.toLocaleString();
  traceIoTokens.textContent = cumulativePromptTokens.toLocaleString() + " / " + cumulativeCompletionTokens.toLocaleString();
  traceTotalCost.textContent = formatCost(cumulativeCost);
  if (total > 0) {
    traceSummary.classList.remove("hidden");
  }
}

function resetCumulativeSummary() {
  cumulativePromptTokens = 0;
  cumulativeCompletionTokens = 0;
  cumulativeCost = 0;
  traceSummary.classList.add("hidden");
  traceTotalTokens.textContent = "0";
  traceIoTokens.textContent = "0 / 0";
  traceTotalCost.textContent = "$0.0000";
}

async function loadPricing() {
  try {
    const res = await fetch("/api/costs/pricing", { credentials: "same-origin" });
    if (res.ok) pricingData = await res.json();
  } catch (_e) {
    /* Pricing is non-critical — degrade gracefully */
  }
}

interface ToolCallTrace {
  name: string;
  arguments: string;
  result?: string;
  error?: string;
  duration_ms?: number;
}

interface TraceEntry {
  id: number;
  timestamp: number;
  usage: { prompt_tokens?: number; completion_tokens?: number } | null;
  contentPreview: string;
  model?: string;
  finish_reason?: string;
  latency_ms?: number;
  tool_calls: ToolCallTrace[];
  reasoning?: string;
  error?: string;
  cost?: number;
}

const traceData: TraceEntry[] = [];

/* Pending trace data accumulated between messages */
let pendingToolCalls: ToolCallTrace[] = [];
let pendingReasoning = "";

const CHEVRON_DOWN = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>';
const CHEVRON_RIGHT = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>';

const COPY_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
const CHECK_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';

/* ---- Trace panel ---- */
function toggleTracePanel() {
  tracePanelOpen = !tracePanelOpen;
  if (tracePanelOpen) {
    tracePanel.classList.remove("hidden");
    traceToggleBtn.classList.add("text-coral");
    traceToggleBtn.classList.remove("text-muted");
  } else {
    tracePanel.classList.add("hidden");
    traceToggleBtn.classList.remove("text-coral");
    traceToggleBtn.classList.add("text-muted");
  }
}

interface TraceFinishData {
  usage: { prompt_tokens?: number; completion_tokens?: number } | null;
  model?: string;
  finish_reason?: string;
  latency_ms?: number;
}

function addTraceEntry(data: TraceFinishData, contentPreview: string) {
  traceCounter++;
  const promptTok = data.usage?.prompt_tokens || 0;
  const completionTok = data.usage?.completion_tokens || 0;
  const cost = calcCost(data.model, promptTok, completionTok);

  const entry: TraceEntry = {
    id: traceCounter,
    timestamp: Date.now(),
    usage: data.usage,
    contentPreview: contentPreview.slice(0, 120) + (contentPreview.length > 120 ? "..." : ""),
    model: data.model,
    finish_reason: data.finish_reason,
    latency_ms: data.latency_ms,
    tool_calls: [...pendingToolCalls],
    reasoning: pendingReasoning || undefined,
    cost: cost,
  };
  traceData.push(entry);
  pendingToolCalls = [];
  pendingReasoning = "";

  /* Update cumulative totals */
  cumulativePromptTokens += promptTok;
  cumulativeCompletionTokens += completionTok;
  cumulativeCost += cost;
  updateCumulativeSummary();

  traceEmpty.classList.add("hidden");
  renderTraceEntry(entry);

  /* Build a context state snapshot from accumulated trace data */
  buildContextSnapshotFromTrace(entry);
}

/* Finish reason badge colors */
const FINISH_REASON_STYLES: Record<string, string> = {
  stop: "bg-zen-green/10 text-zen-green",
  end_turn: "bg-zen-green/10 text-zen-green",
  STOP: "bg-zen-green/10 text-zen-green",
  tool_calls: "bg-zen-blue/10 text-zen-blue",
  tool_use: "bg-zen-blue/10 text-zen-blue",
  length: "bg-coral/10 text-coral",
  MAX_TOKENS: "bg-coral/10 text-coral",
  content_filter: "bg-coral/10 text-coral",
  SAFETY: "bg-coral/10 text-coral",
};

/* SVG icons for trace sections */
const TOOL_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>';
const MODEL_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a4 4 0 0 0-4 4v2H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2h-2V6a4 4 0 0 0-4-4z"/><circle cx="12" cy="15" r="2"/></svg>';
const THINKING_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>';
const ERROR_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>';

function makeCollapsibleSection(icon: string, title: string, content: HTMLElement, defaultOpen?: boolean): HTMLElement {
  const section = document.createElement("div");
  section.className = "mb-2";

  const sectionHeader = document.createElement("button");
  sectionHeader.type = "button";
  sectionHeader.className = "w-full flex items-center gap-1.5 py-1 text-left hover:opacity-80 transition-opacity";

  const sectionChevron = document.createElement("span");
  sectionChevron.className = "flex-shrink-0 text-muted";
  sectionChevron.innerHTML = defaultOpen ? CHEVRON_DOWN : CHEVRON_RIGHT;

  const sectionIcon = document.createElement("span");
  sectionIcon.className = "flex-shrink-0 text-muted";
  sectionIcon.innerHTML = icon;

  const sectionTitle = document.createElement("span");
  sectionTitle.className = "text-[10px] font-medium text-muted uppercase tracking-wide";
  sectionTitle.textContent = title;

  sectionHeader.appendChild(sectionChevron);
  sectionHeader.appendChild(sectionIcon);
  sectionHeader.appendChild(sectionTitle);

  const sectionBody = document.createElement("div");
  sectionBody.className = defaultOpen ? "ml-5 mt-1" : "hidden ml-5 mt-1";
  sectionBody.appendChild(content);

  let sectionOpen = !!defaultOpen;
  sectionHeader.addEventListener("click", function() {
    sectionOpen = !sectionOpen;
    sectionBody.classList.toggle("hidden", !sectionOpen);
    sectionChevron.innerHTML = sectionOpen ? CHEVRON_DOWN : CHEVRON_RIGHT;
  });

  section.appendChild(sectionHeader);
  section.appendChild(sectionBody);
  return section;
}

function formatJson(jsonStr: string): string {
  try {
    return JSON.stringify(JSON.parse(jsonStr), null, 2);
  } catch {
    return jsonStr;
  }
}

function renderTraceEntry(entry: TraceEntry) {
  const el = document.createElement("div");
  el.className = "border border-dark/[0.06] rounded-lg overflow-hidden";

  const header = document.createElement("button");
  header.className = "w-full flex items-center gap-2 px-3 py-2 text-left hover:bg-subtle/50 transition-colors";
  header.type = "button";

  const chevron = document.createElement("span");
  chevron.className = "flex-shrink-0 text-muted transition-transform";
  chevron.innerHTML = CHEVRON_RIGHT;

  const labelWrap = document.createElement("span");
  labelWrap.className = "flex-1 flex items-center gap-1.5 min-w-0";

  const label = document.createElement("span");
  label.className = "text-xs font-medium text-dark truncate";
  label.textContent = "Response #" + entry.id;

  labelWrap.appendChild(label);

  /* Finish reason badge */
  if (entry.finish_reason) {
    const badge = document.createElement("span");
    const styles = FINISH_REASON_STYLES[entry.finish_reason] || "bg-subtle text-muted";
    badge.className = "flex-shrink-0 text-[9px] font-medium px-1.5 py-0.5 rounded-full " + styles;
    badge.textContent = entry.finish_reason;
    labelWrap.appendChild(badge);
  }

  /* Cost badge in header */
  if (entry.cost !== undefined && entry.cost > 0) {
    const costBadge = document.createElement("span");
    costBadge.className = "flex-shrink-0 text-[9px] font-medium px-1.5 py-0.5 rounded-full bg-subtle text-dark tabular-nums";
    costBadge.textContent = formatCost(entry.cost);
    labelWrap.appendChild(costBadge);
  }

  const timeEl = document.createElement("span");
  timeEl.className = "text-[10px] text-muted/60 flex-shrink-0 tabular-nums";
  const d = new Date(entry.timestamp);
  let timeText = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  if (entry.latency_ms !== undefined) {
    timeText += " · " + entry.latency_ms + "ms";
  }
  timeEl.textContent = timeText;

  header.appendChild(chevron);
  header.appendChild(labelWrap);
  header.appendChild(timeEl);

  const body = document.createElement("div");
  body.className = "hidden px-3 pb-3 pt-1 border-t border-dark/[0.04] space-y-1";

  /* Model call section */
  if (entry.model || entry.usage) {
    const modelContent = document.createElement("div");
    modelContent.className = "space-y-1";

    if (entry.model) {
      const modelLine = document.createElement("div");
      modelLine.className = "text-[11px] text-dark";
      modelLine.innerHTML = '<span class="text-muted">Model:</span> <span class="font-medium">' + escapeHtml(entry.model) + '</span>';
      modelContent.appendChild(modelLine);
    }

    if (entry.usage) {
      const usageGrid = document.createElement("div");
      usageGrid.className = "grid grid-cols-3 gap-1";
      if (entry.usage.prompt_tokens) {
        const pt = document.createElement("div");
        pt.className = "text-[11px] text-dark";
        pt.innerHTML = '<span class="text-muted">In:</span> ' + entry.usage.prompt_tokens.toLocaleString();
        usageGrid.appendChild(pt);
      }
      if (entry.usage.completion_tokens) {
        const ct = document.createElement("div");
        ct.className = "text-[11px] text-dark";
        ct.innerHTML = '<span class="text-muted">Out:</span> ' + entry.usage.completion_tokens.toLocaleString();
        usageGrid.appendChild(ct);
      }
      const total = (entry.usage.prompt_tokens || 0) + (entry.usage.completion_tokens || 0);
      if (total > 0) {
        const tt = document.createElement("div");
        tt.className = "text-[11px] text-dark";
        tt.innerHTML = '<span class="text-muted">Total:</span> ' + total.toLocaleString();
        usageGrid.appendChild(tt);
      }
      modelContent.appendChild(usageGrid);
    }

    if (entry.latency_ms !== undefined) {
      const latencyLine = document.createElement("div");
      latencyLine.className = "text-[11px] text-dark";
      latencyLine.innerHTML = '<span class="text-muted">Latency:</span> ' + entry.latency_ms.toLocaleString() + 'ms';
      modelContent.appendChild(latencyLine);
    }

    if (entry.cost !== undefined && entry.cost > 0) {
      const costLine = document.createElement("div");
      costLine.className = "text-[11px] text-dark";
      costLine.innerHTML = '<span class="text-muted">Est. Cost:</span> <span class="font-medium">' + formatCost(entry.cost) + '</span>';
      modelContent.appendChild(costLine);
    }

    body.appendChild(makeCollapsibleSection(MODEL_ICON, "Model Call", modelContent, true));
  }

  /* Tool calls section */
  if (entry.tool_calls.length > 0) {
    const toolsContent = document.createElement("div");
    toolsContent.className = "space-y-2";

    entry.tool_calls.forEach(function(tc) {
      const tcEl = document.createElement("div");
      tcEl.className = "border border-dark/[0.06] rounded p-2 space-y-1";

      const nameRow = document.createElement("div");
      nameRow.className = "flex items-center gap-1.5";
      const nameLabel = document.createElement("span");
      nameLabel.className = "text-[11px] font-medium text-zen-blue";
      nameLabel.textContent = tc.name;
      nameRow.appendChild(nameLabel);
      if (tc.duration_ms !== undefined) {
        const dur = document.createElement("span");
        dur.className = "text-[10px] text-muted/60 ml-auto tabular-nums";
        dur.textContent = tc.duration_ms + "ms";
        nameRow.appendChild(dur);
      }
      tcEl.appendChild(nameRow);

      /* Arguments — collapsible JSON */
      if (tc.arguments) {
        const argsLabel = document.createElement("div");
        argsLabel.className = "text-[10px] text-muted";
        argsLabel.textContent = "Arguments:";
        tcEl.appendChild(argsLabel);

        const argsBlock = document.createElement("pre");
        argsBlock.className = "text-[10px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        argsBlock.textContent = formatJson(tc.arguments);
        tcEl.appendChild(argsBlock);
      }

      /* Result */
      if (tc.result) {
        const resLabel = document.createElement("div");
        resLabel.className = "text-[10px] text-muted mt-1";
        resLabel.textContent = "Result:";
        tcEl.appendChild(resLabel);

        const resBlock = document.createElement("pre");
        resBlock.className = "text-[10px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        resBlock.textContent = formatJson(tc.result);
        tcEl.appendChild(resBlock);
      }

      /* Error */
      if (tc.error) {
        const errLabel = document.createElement("div");
        errLabel.className = "text-[10px] text-coral mt-1";
        errLabel.textContent = "Error:";
        tcEl.appendChild(errLabel);

        const errBlock = document.createElement("pre");
        errBlock.className = "text-[10px] text-coral/70 bg-coral/5 rounded px-2 py-1.5 overflow-x-auto max-h-40 whitespace-pre font-mono";
        errBlock.textContent = tc.error;
        tcEl.appendChild(errBlock);
      }

      toolsContent.appendChild(tcEl);
    });

    body.appendChild(makeCollapsibleSection(TOOL_ICON, "Tool Calls (" + entry.tool_calls.length + ")", toolsContent));
  }

  /* Reasoning section */
  if (entry.reasoning) {
    const reasoningContent = document.createElement("div");
    const reasoningText = document.createElement("div");
    reasoningText.className = "text-[11px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 whitespace-pre-wrap break-words max-h-60 overflow-y-auto";
    reasoningText.textContent = entry.reasoning;
    reasoningContent.appendChild(reasoningText);
    body.appendChild(makeCollapsibleSection(THINKING_ICON, "Reasoning", reasoningContent));
  }

  /* Error display */
  if (entry.error) {
    const errorContent = document.createElement("div");
    const errorText = document.createElement("pre");
    errorText.className = "text-[11px] text-coral bg-coral/5 rounded px-2 py-1.5 whitespace-pre-wrap break-words max-h-60 overflow-y-auto font-mono";
    errorText.textContent = entry.error;
    errorContent.appendChild(errorText);
    body.appendChild(makeCollapsibleSection(ERROR_ICON, "Error", errorContent, true));
  }

  /* Content preview */
  const previewSection = document.createElement("div");
  const previewLabel = document.createElement("div");
  previewLabel.className = "text-[10px] font-medium text-muted uppercase tracking-wide mb-1";
  previewLabel.textContent = "Response Preview";
  previewSection.appendChild(previewLabel);
  const previewText = document.createElement("div");
  previewText.className = "text-[11px] text-dark/70 bg-subtle/50 rounded px-2 py-1.5 whitespace-pre-wrap break-words";
  previewText.textContent = entry.contentPreview || "(empty response)";
  previewSection.appendChild(previewText);
  body.appendChild(previewSection);

  /* Toggle expand/collapse */
  let expanded = false;
  header.addEventListener("click", function() {
    expanded = !expanded;
    if (expanded) {
      body.classList.remove("hidden");
      chevron.innerHTML = CHEVRON_DOWN;
    } else {
      body.classList.add("hidden");
      chevron.innerHTML = CHEVRON_RIGHT;
    }
  });

  el.appendChild(header);
  el.appendChild(body);
  traceEntries.appendChild(el);

  /* Auto-scroll trace panel to latest entry */
  traceEntries.scrollTop = traceEntries.scrollHeight;
}

function escapeHtml(str: string): string {
  const div = document.createElement("div");
  div.textContent = str;
  return div.innerHTML;
}

function clearTraceEntries() {
  traceData.length = 0;
  traceCounter = 0;
  pendingToolCalls = [];
  pendingReasoning = "";
  resetCumulativeSummary();
  const children = Array.from(traceEntries.children);
  children.forEach(function(c) {
    if (c.id !== "trace-empty") traceEntries.removeChild(c);
  });
  traceEmpty.classList.remove("hidden");
  clearContextSnapshots();
}

traceToggleBtn.addEventListener("click", toggleTracePanel);
traceCloseBtn.addEventListener("click", toggleTracePanel);

/* ---- Tab switching ---- */
let activeTab: "trace" | "context" = "trace";

function switchTab(tab: "trace" | "context") {
  activeTab = tab;
  if (tab === "trace") {
    traceTabBtn.classList.add("text-dark", "bg-subtle");
    traceTabBtn.classList.remove("text-muted");
    contextTabBtn.classList.remove("text-dark", "bg-subtle");
    contextTabBtn.classList.add("text-muted");
    traceTabContent.classList.remove("hidden");
    contextTabContent.classList.add("hidden");
  } else {
    contextTabBtn.classList.add("text-dark", "bg-subtle");
    contextTabBtn.classList.remove("text-muted");
    traceTabBtn.classList.remove("text-dark", "bg-subtle");
    traceTabBtn.classList.add("text-muted");
    contextTabContent.classList.remove("hidden");
    traceTabContent.classList.add("hidden");
  }
}

traceTabBtn.addEventListener("click", function() { switchTab("trace"); });
contextTabBtn.addEventListener("click", function() { switchTab("context"); });

/* ---- Context State Inspector ---- */

interface ContextStateEntry {
  value: unknown;
  type: string;
  status?: "new" | "modified" | "removed" | "unchanged";
  previous_value?: unknown;
}

interface ContextStateNode {
  task_id: string;
  parent_task_id: string | null;
  local_entries: Record<string, ContextStateEntry>;
  token_usage: { prompt_tokens: number; completion_tokens: number; total_tokens: number };
  token_delta: { prompt_delta: number; output_delta: number; total_delta: number } | null;
  fork_event: { timestamp: string; parent_task_id: string } | null;
  merge_event: { timestamp: string; net_tokens: number } | null;
  children: ContextStateNode[];
}

interface ContextSnapshot {
  step: number;
  tree: ContextStateNode;
}

const contextSnapshots: ContextSnapshot[] = [];
let currentContextStep = 0;

const FORK_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><circle cx="18" cy="6" r="3"/><path d="M18 9v1a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V9"/><line x1="12" y1="12" x2="12" y2="15"/></svg>';
const MERGE_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="18" r="3"/><path d="M6 15v-1a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v1"/><line x1="12" y1="9" x2="12" y2="12"/></svg>';
const STATE_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="3" y1="9" x2="21" y2="9"/></svg>';

function buildContextSnapshotFromTrace(entry: TraceEntry) {
  /* Synthesize a context state snapshot from the trace entry.
     In production, the agent runtime sends real context_state events.
     Here we build a representative tree from the trace data so the
     inspector is exercisable during normal playground usage. */
  const promptTok = entry.usage?.prompt_tokens || 0;
  const completionTok = entry.usage?.completion_tokens || 0;
  const totalTok = promptTok + completionTok;

  const rootEntries: Record<string, ContextStateEntry> = {};

  // Add current model info
  if (entry.model) {
    rootEntries["model"] = { value: entry.model, type: "string" };
  }
  rootEntries["step"] = { value: entry.id, type: "number" };
  rootEntries["finish_reason"] = { value: entry.finish_reason || "stop", type: "string" };

  // Build tool call children
  const toolChildren: ContextStateNode[] = entry.tool_calls.map(function(tc, idx) {
    const toolEntries: Record<string, ContextStateEntry> = {
      "function": { value: tc.name, type: "string" },
    };
    if (tc.arguments) {
      toolEntries["arguments"] = { value: tc.arguments, type: "object" };
    }
    if (tc.result) {
      toolEntries["result"] = { value: tc.result.slice(0, 200), type: "string" };
    }
    if (tc.error) {
      toolEntries["error"] = { value: tc.error, type: "string" };
    }
    return {
      task_id: "tool_call_" + entry.id + "_" + idx,
      parent_task_id: "step_" + entry.id,
      local_entries: toolEntries,
      token_usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 },
      token_delta: null,
      fork_event: { timestamp: new Date(entry.timestamp).toISOString(), parent_task_id: "step_" + entry.id },
      merge_event: null,
      children: [],
    };
  });

  const stepNode: ContextStateNode = {
    task_id: "step_" + entry.id,
    parent_task_id: "root",
    local_entries: rootEntries,
    token_usage: { prompt_tokens: promptTok, completion_tokens: completionTok, total_tokens: totalTok },
    token_delta: null,
    fork_event: null,
    merge_event: null,
    children: toolChildren,
  };

  // Accumulate into the root tree
  const prevSnapshot = contextSnapshots.length > 0 ? contextSnapshots[contextSnapshots.length - 1] : null;
  const prevChildren = prevSnapshot ? [...prevSnapshot.tree.children] : [];

  // Compute running totals
  let runningPrompt = promptTok;
  let runningCompletion = completionTok;
  prevChildren.forEach(function(c) {
    runningPrompt += c.token_usage.prompt_tokens;
    runningCompletion += c.token_usage.completion_tokens;
  });

  const rootTree: ContextStateNode = {
    task_id: "root",
    parent_task_id: null,
    local_entries: {
      "total_steps": { value: entry.id, type: "number" },
      "cumulative_tokens": { value: runningPrompt + runningCompletion, type: "number" },
      "cumulative_cost": { value: cumulativeCost, type: "number" },
    },
    token_usage: { prompt_tokens: runningPrompt, completion_tokens: runningCompletion, total_tokens: runningPrompt + runningCompletion },
    token_delta: null,
    fork_event: null,
    merge_event: null,
    children: [...prevChildren, stepNode],
  };

  addContextSnapshot(rootTree);
}

function addContextSnapshot(tree: ContextStateNode) {
  const prevTree = contextSnapshots.length > 0 ? contextSnapshots[contextSnapshots.length - 1].tree : null;
  // Compute change status by diffing against previous snapshot
  if (prevTree) {
    diffContextTrees(tree, prevTree);
  }
  const step = contextSnapshots.length + 1;
  contextSnapshots.push({ step, tree });
  currentContextStep = contextSnapshots.length - 1;
  updateContextStepNav();
  renderContextTree();
  contextEmpty.classList.add("hidden");
}

function diffContextTrees(current: ContextStateNode, previous: ContextStateNode | null) {
  if (!previous) {
    // All entries are new
    for (const key of Object.keys(current.local_entries)) {
      current.local_entries[key].status = "new";
    }
  } else {
    const prevEntries = previous.local_entries;
    const curEntries = current.local_entries;

    for (const key of Object.keys(curEntries)) {
      if (!(key in prevEntries)) {
        curEntries[key].status = "new";
      } else if (JSON.stringify(curEntries[key].value) !== JSON.stringify(prevEntries[key].value)) {
        curEntries[key].status = "modified";
        curEntries[key].previous_value = prevEntries[key].value;
      } else {
        curEntries[key].status = "unchanged";
      }
    }
    // Detect removed keys — add them as removed entries
    for (const key of Object.keys(prevEntries)) {
      if (!(key in curEntries)) {
        curEntries[key] = {
          value: prevEntries[key].value,
          type: prevEntries[key].type,
          status: "removed",
        };
      }
    }
  }

  // Diff children by matching task_id
  for (const child of current.children) {
    const prevChild = previous?.children.find(function(c) { return c.task_id === child.task_id; }) || null;
    diffContextTrees(child, prevChild);
  }
}

function updateContextStepNav() {
  const total = contextSnapshots.length;
  const current = currentContextStep + 1;
  contextStepLabel.textContent = total > 0 ? "Step " + current + " / " + total : "Step 0 / 0";
  contextStepPrev.disabled = currentContextStep <= 0;
  contextStepNext.disabled = currentContextStep >= total - 1;
}

contextStepPrev.addEventListener("click", function() {
  if (currentContextStep > 0) {
    currentContextStep--;
    updateContextStepNav();
    renderContextTree();
  }
});

contextStepNext.addEventListener("click", function() {
  if (currentContextStep < contextSnapshots.length - 1) {
    currentContextStep++;
    updateContextStepNav();
    renderContextTree();
  }
});

function renderContextTree() {
  if (contextSnapshots.length === 0) return;
  const snapshot = contextSnapshots[currentContextStep];
  // Clear existing tree (keep empty placeholder)
  const children = Array.from(contextTree.children);
  children.forEach(function(c) {
    if (c.id !== "context-empty") contextTree.removeChild(c);
  });
  const treeEl = renderContextNode(snapshot.tree, 0);
  contextTree.appendChild(treeEl);
}

function renderContextNode(node: ContextStateNode, depth: number): HTMLElement {
  const container = document.createElement("div");
  if (depth > 0) {
    container.style.marginLeft = (depth * 16) + "px";
    container.style.borderLeft = "2px solid var(--zen-subtle, #e8e6d9)";
    container.style.paddingLeft = "8px";
  }

  // Node header
  const header = document.createElement("button");
  header.type = "button";
  header.className = "w-full flex items-center gap-1.5 px-2 py-1.5 text-left rounded-md hover:bg-subtle/50 transition-colors group";

  const chevron = document.createElement("span");
  chevron.className = "flex-shrink-0 text-muted transition-transform";
  chevron.innerHTML = CHEVRON_DOWN;

  const taskLabel = document.createElement("span");
  taskLabel.className = "text-xs font-medium text-dark truncate";
  taskLabel.textContent = node.task_id;

  const tokenBadge = document.createElement("span");
  tokenBadge.className = "ml-auto flex-shrink-0 text-[9px] px-1.5 py-0.5 rounded-full bg-subtle text-muted tabular-nums";
  tokenBadge.textContent = node.token_usage.total_tokens.toLocaleString() + " tok";

  header.appendChild(chevron);

  // Fork/merge event badges
  if (node.fork_event) {
    const forkBadge = document.createElement("span");
    forkBadge.className = "flex-shrink-0 text-zen-blue";
    forkBadge.innerHTML = FORK_ICON;
    forkBadge.title = "Forked from " + node.fork_event.parent_task_id;
    header.appendChild(forkBadge);
  }
  if (node.merge_event) {
    const mergeBadge = document.createElement("span");
    mergeBadge.className = "flex-shrink-0 text-zen-green";
    mergeBadge.innerHTML = MERGE_ICON;
    mergeBadge.title = "Merged (" + (node.merge_event.net_tokens >= 0 ? "+" : "") + node.merge_event.net_tokens + " tokens)";
    header.appendChild(mergeBadge);
  }

  header.appendChild(taskLabel);
  header.appendChild(tokenBadge);

  container.appendChild(header);

  // Body: key-value entries + token details
  const body = document.createElement("div");
  body.className = "ml-5 mt-1 mb-2 space-y-0.5";

  // Token usage detail
  if (node.token_usage.total_tokens > 0) {
    const tokenRow = document.createElement("div");
    tokenRow.className = "flex items-center gap-2 text-[10px] text-muted px-1 py-0.5";
    let tokenText = "In: " + node.token_usage.prompt_tokens.toLocaleString() + " · Out: " + node.token_usage.completion_tokens.toLocaleString();
    if (node.token_delta) {
      const delta = node.token_delta.total_delta;
      const sign = delta >= 0 ? "+" : "";
      tokenText += " · Delta: " + sign + delta.toLocaleString();
    }
    tokenRow.textContent = tokenText;
    body.appendChild(tokenRow);
  }

  // Merge event info
  if (node.merge_event) {
    const mergeRow = document.createElement("div");
    mergeRow.className = "flex items-center gap-1 text-[10px] px-1 py-0.5 rounded bg-zen-green/10 text-zen-green";
    mergeRow.innerHTML = '<span class="flex-shrink-0">' + MERGE_ICON + '</span>';
    const mergeText = document.createElement("span");
    const netSign = node.merge_event.net_tokens >= 0 ? "+" : "";
    mergeText.textContent = "Merged · " + netSign + node.merge_event.net_tokens.toLocaleString() + " net tokens";
    mergeRow.appendChild(mergeText);
    body.appendChild(mergeRow);
  }

  // Key-value entries
  const entryKeys = Object.keys(node.local_entries);
  if (entryKeys.length > 0) {
    const tableEl = document.createElement("div");
    tableEl.className = "border border-dark/[0.06] rounded-md overflow-hidden mt-1";

    const tableHeader = document.createElement("div");
    tableHeader.className = "grid grid-cols-[1fr_1fr_auto] gap-1 px-2 py-1 bg-subtle/50 text-[9px] text-muted font-medium uppercase tracking-wide";
    tableHeader.innerHTML = "<span>Key</span><span>Value</span><span>Type</span>";
    tableEl.appendChild(tableHeader);

    entryKeys.forEach(function(key) {
      const entry = node.local_entries[key];
      const row = document.createElement("div");
      row.className = "grid grid-cols-[1fr_1fr_auto] gap-1 px-2 py-1 border-t border-dark/[0.04] text-[11px] items-start";

      // Status-based styling
      if (entry.status === "new") {
        row.classList.add("bg-zen-green/5");
      } else if (entry.status === "modified") {
        row.classList.add("bg-yellow-500/5");
      } else if (entry.status === "removed") {
        row.classList.add("bg-coral/5", "line-through", "opacity-60");
      }

      const keyEl = document.createElement("span");
      keyEl.className = "font-medium text-dark truncate";
      keyEl.textContent = key;
      keyEl.title = key;

      // Status indicator dot
      if (entry.status === "new") {
        const dot = document.createElement("span");
        dot.className = "inline-block w-1.5 h-1.5 rounded-full bg-zen-green ml-1 align-middle";
        dot.title = "New";
        keyEl.appendChild(dot);
      } else if (entry.status === "modified") {
        const dot = document.createElement("span");
        dot.className = "inline-block w-1.5 h-1.5 rounded-full bg-yellow-500 ml-1 align-middle";
        dot.title = "Modified";
        keyEl.appendChild(dot);
      } else if (entry.status === "removed") {
        const dot = document.createElement("span");
        dot.className = "inline-block w-1.5 h-1.5 rounded-full bg-coral ml-1 align-middle";
        dot.title = "Removed";
        keyEl.appendChild(dot);
      }

      const valueEl = document.createElement("span");
      valueEl.className = "text-dark/70 truncate font-mono text-[10px]";
      const valStr = typeof entry.value === "object" ? JSON.stringify(entry.value) : String(entry.value);
      valueEl.textContent = valStr;
      valueEl.title = valStr;

      // Show previous value on hover for modified entries
      if (entry.status === "modified" && entry.previous_value !== undefined) {
        const prevStr = typeof entry.previous_value === "object" ? JSON.stringify(entry.previous_value) : String(entry.previous_value);
        valueEl.title = "Current: " + valStr + "\nPrevious: " + prevStr;
      }

      const typeEl = document.createElement("span");
      typeEl.className = "text-[9px] px-1 py-0.5 rounded bg-subtle text-muted whitespace-nowrap";
      typeEl.textContent = entry.type;

      row.appendChild(keyEl);
      row.appendChild(valueEl);
      row.appendChild(typeEl);
      tableEl.appendChild(row);
    });

    body.appendChild(tableEl);
  } else if (!node.merge_event && node.token_usage.total_tokens === 0) {
    const emptyRow = document.createElement("div");
    emptyRow.className = "text-[10px] text-muted/60 px-1 py-0.5 italic";
    emptyRow.textContent = "No local state entries";
    body.appendChild(emptyRow);
  }

  container.appendChild(body);

  // Toggle expand/collapse
  let nodeExpanded = true;
  header.addEventListener("click", function() {
    nodeExpanded = !nodeExpanded;
    body.classList.toggle("hidden", !nodeExpanded);
    chevron.innerHTML = nodeExpanded ? CHEVRON_DOWN : CHEVRON_RIGHT;
  });

  // Render children recursively
  if (node.children.length > 0) {
    node.children.forEach(function(child) {
      container.appendChild(renderContextNode(child, depth + 1));
    });
  }

  return container;
}

function clearContextSnapshots() {
  contextSnapshots.length = 0;
  currentContextStep = 0;
  updateContextStepNav();
  const children = Array.from(contextTree.children);
  children.forEach(function(c) {
    if (c.id !== "context-empty") contextTree.removeChild(c);
  });
  contextEmpty.classList.remove("hidden");
}

/* ---- Load agents ---- */
async function loadAgents() {
  try {
    const res = await fetch("/api/agents", { credentials: "same-origin" });
    if (!res.ok) return;
    const body = await res.json();
    agents = body.data ?? body;
    agentSelect.innerHTML = '<option value="">Select an agent...</option>';
    agents.forEach(function(a) {
      const opt = document.createElement("option");
      opt.value = a.id;
      opt.textContent = a.name + (a.model_provider ? " (" + a.model_provider + ")" : "");
      agentSelect.appendChild(opt);
    });
  } catch (e) {
    console.error("Failed to load agents:", e);
  }
}

/* ---- Agent status badge ---- */
type AgentStatus = "idle" | "running" | "paused";

function setAgentStatus(status: AgentStatus) {
  if (status === "idle") {
    agentStatusBadge.classList.add("hidden");
    takeoverBtn.classList.add("hidden");
    takeoverBar.classList.add("hidden");
    isPaused = false;
    return;
  }
  agentStatusBadge.classList.remove("hidden");
  agentStatusText.className = "inline-flex items-center gap-1.5 px-2.5 py-1 text-xs font-medium rounded-full";
  if (status === "running") {
    agentStatusText.textContent = "Running";
    agentStatusText.classList.add("bg-zen-green/10", "text-zen-green");
    takeoverBtn.classList.remove("hidden");
    takeoverBar.classList.add("hidden");
    isPaused = false;
  } else if (status === "paused") {
    agentStatusText.textContent = "Paused (Human Control)";
    agentStatusText.classList.add("bg-coral/10", "text-coral");
    takeoverBtn.classList.add("hidden");
    takeoverBar.classList.remove("hidden");
    isPaused = true;
    injectInput.focus();
  }
}

/* ---- Takeover trace logging ---- */
const TAKEOVER_ICON = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="8.5" cy="7" r="4"/><line x1="20" y1="8" x2="20" y2="14"/><line x1="23" y1="11" x2="17" y2="11"/></svg>';

function addTakeoverTraceEntry(action: string, detail?: string) {
  traceCounter++;
  traceEmpty.classList.add("hidden");
  const el = document.createElement("div");
  el.className = "border border-coral/20 rounded-lg overflow-hidden bg-coral/5";

  const header = document.createElement("div");
  header.className = "flex items-center gap-2 px-3 py-2 text-left";

  const iconSpan = document.createElement("span");
  iconSpan.className = "flex-shrink-0 text-coral";
  iconSpan.innerHTML = TAKEOVER_ICON;

  const label = document.createElement("span");
  label.className = "text-xs font-medium text-coral";
  const actionLabels: Record<string, string> = {
    paused: "Takeover: Agent paused",
    resumed: "Takeover: Agent resumed",
    stopped: "Takeover: Execution stopped",
    injected: "Takeover: Message injected",
  };
  label.textContent = actionLabels[action] || ("Takeover: " + action);

  const timeEl = document.createElement("span");
  timeEl.className = "text-[10px] text-muted/60 flex-shrink-0 tabular-nums ml-auto";
  timeEl.textContent = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });

  header.appendChild(iconSpan);
  header.appendChild(label);
  header.appendChild(timeEl);
  el.appendChild(header);

  if (detail) {
    const body = document.createElement("div");
    body.className = "px-3 pb-2 text-[11px] text-dark/70";
    body.textContent = detail;
    el.appendChild(body);
  }

  traceEntries.appendChild(el);
  traceEntries.scrollTop = traceEntries.scrollHeight;
}

/* ---- Takeover action handlers ---- */
takeoverBtn.addEventListener("click", function() {
  if (ws && ws.readyState === WebSocket.OPEN && isStreaming) {
    ws.send(JSON.stringify({ type: "takeover" }));
  }
});

injectBtn.addEventListener("click", function() {
  const text = injectInput.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
  addUserMessage(text);
  ws.send(JSON.stringify({ type: "inject", content: text }));
  injectInput.value = "";
  setAgentStatus("running");
  isStreaming = true;
  messageInput.disabled = true;
  sendBtn.disabled = true;
  startAgentMessage();
});

resumeBtn.addEventListener("click", function() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "resume" }));
    setAgentStatus("running");
    isStreaming = true;
    messageInput.disabled = true;
    sendBtn.disabled = true;
    startAgentMessage();
  }
});

stopBtn.addEventListener("click", function() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "stop" }));
    setAgentStatus("idle");
    isStreaming = false;
    messageInput.disabled = false;
    sendBtn.disabled = false;
  }
});

injectInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    injectBtn.click();
  }
});

/* ---- WebSocket management ---- */
function connectWebSocket(agentId: string, conversationId?: string) {
  if (ws) {
    ws.close();
    ws = null;
  }

  currentAgentId = agentId;
  currentConversationId = conversationId || null;
  const proto = location.protocol === "https:" ? "wss:" : "ws:";
  const url = proto + "//" + location.host + "/api/playground/" + agentId + "/chat";

  connectionStatus.classList.add("hidden");
  connectionStatus.textContent = "";

  ws = new WebSocket(url);

  ws.onopen = function() {
    messageInput.disabled = false;
    sendBtn.disabled = false;
    micBtn.disabled = false;
    messageInput.focus();
    // Load existing conversation if specified
    if (conversationId && ws) {
      ws.send(JSON.stringify({ type: "load_conversation", conversation_id: conversationId }));
    }
  };

  ws.onclose = function(e) {
    if (e.code === 4001) {
      showStatus("Authentication required. Please log in.");
    } else if (e.code === 4004) {
      showStatus("Agent not found.");
    } else if (e.code !== 1000 && e.code !== 1001) {
      showStatus("Connection closed (code " + e.code + ")");
    }
    messageInput.disabled = true;
    sendBtn.disabled = true;
    micBtn.disabled = true;
    isStreaming = false;
    setAgentStatus("idle");
    ws = null;
    if (isRecording && speechRecognition) {
      speechRecognition.stop();
    }
  };

  ws.onerror = function() {
    showStatus("WebSocket connection error.");
  };

  ws.onmessage = function(event) {
    let data;
    try {
      data = JSON.parse(event.data);
    } catch (_e) {
      return;
    }

    if (data.type === "token") {
      appendToken(data.content);
    } else if (data.type === "done") {
      finishStream(data);
    } else if (data.type === "tool_call") {
      pendingToolCalls.push({
        name: data.name || "unknown",
        arguments: data.arguments || "",
        result: data.result,
        error: data.error,
        duration_ms: data.duration_ms,
      });
    } else if (data.type === "reasoning") {
      pendingReasoning += (pendingReasoning ? "\n" : "") + (data.content || "");
    } else if (data.type === "error") {
      appendError(data.message);
      isStreaming = false;
      messageInput.disabled = false;
      sendBtn.disabled = false;
    } else if (data.type === "conversation_created") {
      currentConversationId = data.conversation_id;
    } else if (data.type === "conversation_loaded") {
      currentConversationId = data.conversation_id;
      restoreMessages(data.messages);
    } else if (data.type === "context_state") {
      /* Context state snapshot from agent runtime */
      if (data.tree) {
        addContextSnapshot(data.tree);
      }
    } else if (data.type === "takeover_ack") {
      /* Agent paused — show takeover controls */
      setAgentStatus("paused");
      /* Finish the current streaming bubble with partial content */
      if (currentStreamBubble && streamedContent) {
        currentStreamBubble.textContent = "";
        currentStreamBubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-coral/20 text-dark text-sm break-words chat-prose min-w-0";
        currentStreamBubble.innerHTML = renderMarkdown(streamedContent) + '<div class="text-[10px] text-coral mt-1 italic">Paused by human takeover</div>';
      }
      currentStreamBubble = null;
      streamedContent = "";
    } else if (data.type === "takeover_stopped") {
      /* Execution stopped — finalize partial content */
      setAgentStatus("idle");
      isStreaming = false;
      messageInput.disabled = false;
      sendBtn.disabled = false;
      addTakeoverTraceEntry("stopped");
    } else if (data.type === "takeover_event") {
      addTakeoverTraceEntry(data.action || "unknown", data.content);
    }
  };
}

function disconnectWebSocket() {
  if (ws) {
    ws.close();
    ws = null;
  }
  currentAgentId = null;
  messageInput.disabled = true;
  sendBtn.disabled = true;
  micBtn.disabled = true;
}

function showStatus(msg: string) {
  connectionStatus.textContent = msg;
  connectionStatus.classList.remove("hidden");
}

/* ---- Copy button helper ---- */
function createCopyButton(getText: () => string): HTMLButtonElement {
  const btn = document.createElement("button");
  btn.className = "copy-msg-btn absolute top-2 right-2 p-1 rounded bg-subtle/80 text-muted hover:text-dark opacity-0 group-hover:opacity-100 transition-opacity";
  btn.title = "Copy message";
  btn.innerHTML = COPY_ICON;
  btn.addEventListener("click", function() {
    navigator.clipboard.writeText(getText()).then(function() {
      btn.innerHTML = CHECK_ICON;
      btn.classList.add("text-zen-green");
      setTimeout(function() {
        btn.innerHTML = COPY_ICON;
        btn.classList.remove("text-zen-green");
      }, 1500);
    });
  });
  return btn;
}

/* ---- Restore saved messages ---- */
function restoreMessages(messages: Array<{ role: string; content: string }>) {
  messages.forEach(function(m) {
    if (m.role === "user") {
      addUserMessage(m.content);
    } else if (m.role === "assistant") {
      addRestoredAgentMessage(m.content);
    }
    // Skip system messages — they're not displayed
  });
}

function addRestoredAgentMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
  bubble.innerHTML = renderMarkdown(text);

  const copyBtn = createCopyButton(() => text);
  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  wrapper.appendChild(copyBtn);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Message rendering ---- */
function hideEmptyState() {
  emptyState.classList.add("hidden");
}

function showEmptyState() {
  emptyState.classList.remove("hidden");
}

function renderMarkdown(text: string): string {
  return marked.parse(text) as string;
}

function addUserMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-end";

  const bubble = document.createElement("div");
  bubble.className = "max-w-[75%] sm:max-w-[60%] relative group";

  const inner = document.createElement("div");
  inner.className = "px-4 py-2.5 rounded-2xl rounded-br-sm bg-subtle text-dark text-sm whitespace-pre-wrap break-words";
  inner.textContent = text;

  const copyBtn = createCopyButton(() => text);
  bubble.appendChild(inner);
  bubble.appendChild(copyBtn);
  row.appendChild(bubble);
  messagesEl.appendChild(row);
  scrollToBottom();
}

let currentStreamBubble: HTMLElement | null = null;
let streamedContent = "";

function startAgentMessage() {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm whitespace-pre-wrap break-words min-w-0";
  bubble.textContent = "";

  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);

  currentStreamBubble = bubble;
  streamedContent = "";
  scrollToBottom();
}

function appendToken(token: string) {
  if (!currentStreamBubble) {
    startAgentMessage();
  }
  streamedContent += token;
  currentStreamBubble!.textContent = streamedContent;
  scrollToBottom();
}

function speakText(text: string) {
  if (!ttsEnabled || !hasSpeechSynthesis) return;
  /* Strip markdown formatting for cleaner speech */
  const plain = text
    .replace(/```[\s\S]*?```/g, " code block ")
    .replace(/`([^`]+)`/g, "$1")
    .replace(/\*\*([^*]+)\*\*/g, "$1")
    .replace(/\*([^*]+)\*/g, "$1")
    .replace(/#{1,6}\s+/g, "")
    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, "image: $1")
    .replace(/[-*_]{3,}/g, "")
    .replace(/\n+/g, ". ")
    .trim();
  if (!plain) return;
  window.speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(plain);
  utterance.rate = 1;
  utterance.pitch = 1;
  window.speechSynthesis.speak(utterance);
}

function finishStream(data: { usage?: { prompt_tokens?: number; completion_tokens?: number } | null; model?: string; finish_reason?: string; latency_ms?: number }) {
  const usage = data.usage || null;
  if (currentStreamBubble) {
    // Render markdown now that streaming is complete
    const rawText = streamedContent;
    currentStreamBubble.textContent = "";
    currentStreamBubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
    currentStreamBubble.innerHTML = renderMarkdown(rawText);

    // Add copy button to the wrapper (which is the parent of bubble)
    const wrapper = currentStreamBubble.parentElement!;
    const copyBtn = createCopyButton(() => rawText);
    wrapper.appendChild(copyBtn);

    if (usage) {
      const meta = document.createElement("div");
      meta.className = "text-[10px] text-muted/60 mt-1.5 text-right";
      const parts: string[] = [];
      if (usage.prompt_tokens) parts.push(usage.prompt_tokens.toLocaleString() + " in");
      if (usage.completion_tokens) parts.push(usage.completion_tokens.toLocaleString() + " out");
      if (parts.length > 0) {
        let metaText = parts.join(" / ") + " tokens";
        const msgCost = calcCost(data.model, usage.prompt_tokens || 0, usage.completion_tokens || 0);
        if (msgCost > 0) {
          metaText += " · " + formatCost(msgCost);
        }
        meta.textContent = metaText;
        wrapper.appendChild(meta);
      }
    }

    /* Add trace entry for this response */
    addTraceEntry({
      usage: usage,
      model: data.model,
      finish_reason: data.finish_reason,
      latency_ms: data.latency_ms,
    }, rawText);

    /* Speak response if TTS is enabled */
    speakText(rawText);
  }
  currentStreamBubble = null;
  streamedContent = "";
  isStreaming = false;
  messageInput.disabled = false;
  sendBtn.disabled = false;
  setAgentStatus("idle");
  messageInput.focus();
  scrollToBottom();
}

function appendError(msg: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-center";
  const pill = document.createElement("div");
  pill.className = "px-4 py-2 rounded-xl bg-coral/10 text-coral text-xs max-w-md text-center";
  pill.textContent = msg;
  row.appendChild(pill);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Scroll management ---- */
function isNearBottom(): boolean {
  const threshold = 80;
  return messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < threshold;
}

function scrollToBottom() {
  if (!userScrolledUp) {
    requestAnimationFrame(function() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }
}

function updateScrollButton() {
  if (isNearBottom()) {
    userScrolledUp = false;
    scrollBottomBtn.classList.add("hidden");
    scrollBottomBtn.classList.remove("flex");
  } else {
    userScrolledUp = true;
    scrollBottomBtn.classList.remove("hidden");
    scrollBottomBtn.classList.add("flex");
  }
}

messagesEl.addEventListener("scroll", updateScrollButton);

scrollBottomBtn.addEventListener("click", function() {
  userScrolledUp = false;
  messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: "smooth" });
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
});

function clearMessages() {
  /* Remove all children except the empty state */
  const children = Array.from(messagesEl.children);
  children.forEach(function(c) {
    if (c.id !== "empty-state") messagesEl.removeChild(c);
  });
  showEmptyState();
  currentStreamBubble = null;
  streamedContent = "";
  currentConversationId = null;
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  setAgentStatus("idle");
  clearTraceEntries();
  /* Reconnect to reset conversation history on server (new conversation) */
  if (currentAgentId) {
    connectWebSocket(currentAgentId);
  }
}

/* ---- Send message ---- */
function sendMessage() {
  const text = messageInput.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN || isStreaming) return;

  addUserMessage(text);
  ws.send(JSON.stringify({ content: text }));
  messageInput.value = "";
  autoResize();
  isStreaming = true;
  messageInput.disabled = true;
  sendBtn.disabled = true;
  setAgentStatus("running");
  /* Reset scroll tracking so auto-scroll works for the new response */
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  startAgentMessage();
}

/* ---- Auto-resize textarea ---- */
function autoResize() {
  messageInput.style.height = "auto";
  messageInput.style.height = Math.min(messageInput.scrollHeight, 160) + "px";
}

/* ---- Event listeners ---- */
agentSelect.addEventListener("change", function() {
  const val = agentSelect.value;
  if (!val) {
    disconnectWebSocket();
    agentInfo.classList.add("hidden");
    return;
  }
  /* Show model info */
  const agent = agents.find(function(a) { return a.id === val; });
  if (agent && agent.model_provider) {
    agentModel.textContent = agent.model_provider + (agent.model_name ? ":" + agent.model_name : "");
    agentInfo.classList.remove("hidden");
  } else {
    agentInfo.classList.add("hidden");
  }
  clearMessages();
  connectWebSocket(val);
  /* Load threads for this agent if sidebar is open */
  if (threadSidebarOpen) {
    currentThreadId = null;
    threadMetaBar.classList.add("hidden");
    loadThreads(val);
  }
});

messageInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

/* Cmd+I / Ctrl+I to toggle trace panel */
document.addEventListener("keydown", function(e) {
  if ((e.metaKey || e.ctrlKey) && e.key === "i") {
    e.preventDefault();
    toggleTracePanel();
  }
});

messageInput.addEventListener("input", autoResize);

sendBtn.addEventListener("click", sendMessage);

clearBtn.addEventListener("click", clearMessages);

/* ---- Compare mode ---- */
const compareToggleBtn = document.getElementById("compare-toggle-btn")!;
const compareBar = document.getElementById("compare-bar")!;
const compareContainer = document.getElementById("compare-container")!;
const normalChatContainer = document.getElementById("normal-chat-container")!;
const compareColumns = document.getElementById("compare-columns")!;
const compareAddModel = document.getElementById("compare-add-model") as HTMLSelectElement;
const compareModelSlots = document.getElementById("compare-model-slots")!;
const compareMessageInput = document.getElementById("compare-message-input") as HTMLTextAreaElement;
const compareSendBtn = document.getElementById("compare-send-btn") as HTMLButtonElement;
const compareConnectionStatus = document.getElementById("compare-connection-status")!;
const compareExportBtn = document.getElementById("compare-export-btn")!;

let compareMode = false;
let compareWs: WebSocket | null = null;
let compareStreaming = false;

const compareIconSvg = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="8" height="18" rx="1"/><rect x="14" y="3" width="8" height="18" rx="1"/></svg>';
const thumbUpSvg = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"/></svg>';
const thumbDownSvg = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"/></svg>';

interface CompareModel {
  provider_type: string;
  model_name: string;
  display_name: string;
}

interface CompareResult {
  model: CompareModel;
  content: string;
  usage: { prompt_tokens?: number; completion_tokens?: number } | null;
  latency_ms?: number;
  finish_reason?: string;
  cost?: number;
  rating?: "up" | "down";
  error?: string;
}

let selectedModels: CompareModel[] = [];
let availableModels: Array<{ provider_type: string; model_name: string; provider_name?: string }> = [];
let compareHistory: Array<{ prompt: string; results: CompareResult[] }> = [];

/* Column streaming state */
let compareStreamBubbles: (HTMLElement | null)[] = [];
let compareStreamedContent: string[] = [];

async function loadModelsForCompare() {
  try {
    const res = await fetch("/api/models", { credentials: "same-origin" });
    if (!res.ok) return;
    const data = await res.json();
    availableModels = data.map(function(m: any) {
      return {
        provider_type: m.provider_type || "",
        model_name: m.model_name || "",
        provider_name: m.provider_name || m.provider_type || "",
      };
    });
    rebuildModelDropdown();
  } catch (_e) { /* non-critical */ }
}

function rebuildModelDropdown() {
  compareAddModel.innerHTML = '<option value="">+ Add model...</option>';
  availableModels.forEach(function(m, i) {
    /* Skip already-selected models */
    if (selectedModels.some(function(s) { return s.provider_type === m.provider_type && s.model_name === m.model_name; })) return;
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = (m.provider_name || m.provider_type) + ": " + m.model_name;
    compareAddModel.appendChild(opt);
  });
  /* Disable adding if already at 4 */
  if (selectedModels.length >= 4) {
    compareAddModel.disabled = true;
    compareAddModel.innerHTML = '<option value="">Max 4 models</option>';
  } else {
    compareAddModel.disabled = false;
  }
}

function addCompareModel(m: CompareModel) {
  if (selectedModels.length >= 4) return;
  if (selectedModels.some(function(s) { return s.provider_type === m.provider_type && s.model_name === m.model_name; })) return;
  selectedModels.push(m);
  renderModelChips();
  rebuildModelDropdown();
  renderCompareColumns();
  updateCompareInputState();
}

function removeCompareModel(idx: number) {
  selectedModels.splice(idx, 1);
  renderModelChips();
  rebuildModelDropdown();
  renderCompareColumns();
  updateCompareInputState();
}

function renderModelChips() {
  /* Remove existing chips (keep the <select>) */
  const existing = compareModelSlots.querySelectorAll("[data-model-chip]");
  existing.forEach(function(el) { el.remove(); });

  selectedModels.forEach(function(m, i) {
    const chip = document.createElement("span");
    chip.setAttribute("data-model-chip", "");
    chip.className = "inline-flex items-center gap-1 px-2 py-0.5 bg-paper border border-dark/[0.08] rounded-full text-xs text-dark";

    const label = document.createElement("span");
    label.textContent = m.display_name;
    chip.appendChild(label);

    const removeBtn = document.createElement("button");
    removeBtn.className = "text-muted hover:text-coral transition-colors ml-0.5";
    removeBtn.innerHTML = '<svg class="h-3 w-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
    removeBtn.addEventListener("click", function() { removeCompareModel(i); });
    chip.appendChild(removeBtn);

    /* Insert before the <select> */
    compareModelSlots.insertBefore(chip, compareAddModel);
  });
}

function renderCompareColumns() {
  compareColumns.innerHTML = "";
  compareStreamBubbles = [];
  compareStreamedContent = [];

  if (selectedModels.length === 0) {
    const empty = document.createElement("div");
    empty.className = "flex-1 flex items-center justify-center text-center p-8";
    empty.innerHTML = '<div><div class="w-12 h-12 rounded-full bg-subtle flex items-center justify-center mb-3 mx-auto"><span class="text-muted">' + compareIconSvg + '</span></div><p class="text-sm text-muted">Select 2–4 models above to compare side-by-side</p></div>';
    compareColumns.appendChild(empty);
    return;
  }

  selectedModels.forEach(function(m, i) {
    const col = document.createElement("div");
    col.className = "flex-1 min-w-[220px] flex flex-col min-h-0";
    col.setAttribute("data-compare-col", String(i));

    /* Column header */
    const header = document.createElement("div");
    header.className = "flex items-center gap-2 px-3 py-2 bg-subtle/30 border-b border-dark/[0.08] flex-shrink-0";
    const modelLabel = document.createElement("span");
    modelLabel.className = "text-xs font-medium text-dark truncate flex-1";
    modelLabel.textContent = m.display_name;
    header.appendChild(modelLabel);

    /* Metrics area (initially hidden) */
    const metrics = document.createElement("div");
    metrics.className = "hidden text-[10px] text-muted tabular-nums";
    metrics.setAttribute("data-metrics", String(i));
    header.appendChild(metrics);

    col.appendChild(header);

    /* Response area */
    const responseArea = document.createElement("div");
    responseArea.className = "flex-1 overflow-y-auto px-3 py-3";
    responseArea.setAttribute("data-response-area", String(i));

    const emptyMsg = document.createElement("div");
    emptyMsg.className = "flex items-center justify-center h-full";
    emptyMsg.setAttribute("data-col-empty", String(i));
    emptyMsg.innerHTML = '<p class="text-xs text-muted">Waiting for prompt...</p>';
    responseArea.appendChild(emptyMsg);

    col.appendChild(responseArea);

    /* Footer: rating + metrics summary */
    const footer = document.createElement("div");
    footer.className = "hidden flex-shrink-0 border-t border-dark/[0.08] px-3 py-2";
    footer.setAttribute("data-col-footer", String(i));

    const footerInner = document.createElement("div");
    footerInner.className = "flex items-center justify-between gap-2";

    /* Metrics summary */
    const metricsSummary = document.createElement("div");
    metricsSummary.className = "text-[10px] text-muted space-y-0.5";
    metricsSummary.setAttribute("data-footer-metrics", String(i));
    footerInner.appendChild(metricsSummary);

    /* Rating buttons */
    const ratingWrap = document.createElement("div");
    ratingWrap.className = "flex items-center gap-1";
    ratingWrap.setAttribute("data-rating", String(i));

    const upBtn = document.createElement("button");
    upBtn.className = "p-1 rounded text-muted hover:text-zen-green hover:bg-zen-green/10 transition-colors";
    upBtn.title = "Thumbs up";
    upBtn.innerHTML = thumbUpSvg;
    upBtn.setAttribute("data-rating-up", String(i));

    const downBtn = document.createElement("button");
    downBtn.className = "p-1 rounded text-muted hover:text-coral hover:bg-coral/10 transition-colors";
    downBtn.title = "Thumbs down";
    downBtn.innerHTML = thumbDownSvg;
    downBtn.setAttribute("data-rating-down", String(i));

    ratingWrap.appendChild(upBtn);
    ratingWrap.appendChild(downBtn);
    footerInner.appendChild(ratingWrap);

    footer.appendChild(footerInner);
    col.appendChild(footer);

    compareColumns.appendChild(col);
    compareStreamBubbles.push(null);
    compareStreamedContent.push("");
  });

  /* Bind rating buttons */
  selectedModels.forEach(function(_m, i) {
    const upBtn = compareColumns.querySelector('[data-rating-up="' + i + '"]');
    const downBtn = compareColumns.querySelector('[data-rating-down="' + i + '"]');
    if (upBtn) upBtn.addEventListener("click", function() { rateCompareResponse(i, "up"); });
    if (downBtn) downBtn.addEventListener("click", function() { rateCompareResponse(i, "down"); });
  });
}

function rateCompareResponse(modelIndex: number, rating: "up" | "down") {
  /* Update the latest compare round */
  if (compareHistory.length === 0) return;
  const latest = compareHistory[compareHistory.length - 1];
  if (modelIndex < latest.results.length) {
    latest.results[modelIndex].rating = rating;
  }
  /* Visual feedback */
  const upBtn = compareColumns.querySelector('[data-rating-up="' + modelIndex + '"]') as HTMLElement | null;
  const downBtn = compareColumns.querySelector('[data-rating-down="' + modelIndex + '"]') as HTMLElement | null;
  if (upBtn && downBtn) {
    if (rating === "up") {
      upBtn.className = "p-1 rounded text-zen-green bg-zen-green/10 transition-colors";
      downBtn.className = "p-1 rounded text-muted hover:text-coral hover:bg-coral/10 transition-colors";
    } else {
      downBtn.className = "p-1 rounded text-coral bg-coral/10 transition-colors";
      upBtn.className = "p-1 rounded text-muted hover:text-zen-green hover:bg-zen-green/10 transition-colors";
    }
  }
}

function updateCompareInputState() {
  const enabled = selectedModels.length >= 2 && !compareStreaming;
  compareMessageInput.disabled = !enabled;
  compareSendBtn.disabled = !enabled;
}

function toggleCompareMode() {
  compareMode = !compareMode;
  if (compareMode) {
    compareToggleBtn.classList.add("text-coral");
    compareToggleBtn.classList.remove("text-muted");
    compareBar.classList.remove("hidden");
    compareContainer.classList.remove("hidden");
    compareContainer.classList.add("flex");
    normalChatContainer.classList.add("hidden");
    /* Hide trace toggle in compare mode */
    traceToggleBtn.classList.add("hidden");
    /* Disconnect normal WS */
    disconnectWebSocket();
    loadModelsForCompare();
    renderCompareColumns();
    updateCompareInputState();
  } else {
    compareToggleBtn.classList.remove("text-coral");
    compareToggleBtn.classList.add("text-muted");
    compareBar.classList.add("hidden");
    compareContainer.classList.add("hidden");
    compareContainer.classList.remove("flex");
    normalChatContainer.classList.remove("hidden");
    traceToggleBtn.classList.remove("hidden");
    /* Disconnect compare WS */
    if (compareWs) { compareWs.close(); compareWs = null; }
    /* Reconnect normal if agent selected */
    const val = agentSelect.value;
    if (val) connectWebSocket(val);
  }
}

compareToggleBtn.addEventListener("click", toggleCompareMode);

compareAddModel.addEventListener("change", function() {
  const val = compareAddModel.value;
  if (!val) return;
  const idx = parseInt(val, 10);
  const m = availableModels[idx];
  if (m) {
    addCompareModel({
      provider_type: m.provider_type,
      model_name: m.model_name,
      display_name: (m.provider_name || m.provider_type) + ": " + m.model_name,
    });
  }
  compareAddModel.value = "";
});

function sendCompareMessage() {
  const text = compareMessageInput.value.trim();
  if (!text || selectedModels.length < 2 || compareStreaming) return;

  compareStreaming = true;
  updateCompareInputState();

  /* Prepare results array for this round */
  const results: CompareResult[] = selectedModels.map(function(m) {
    return { model: m, content: "", usage: null, rating: undefined };
  });
  compareHistory.push({ prompt: text, results: results });

  /* Clear old response areas and show streaming state */
  selectedModels.forEach(function(_m, i) {
    const area = compareColumns.querySelector('[data-response-area="' + i + '"]') as HTMLElement;
    if (!area) return;
    const emptyEl = area.querySelector('[data-col-empty="' + i + '"]');
    if (emptyEl) emptyEl.remove();

    /* Add user message */
    const userRow = document.createElement("div");
    userRow.className = "flex justify-end mb-3";
    const userBubble = document.createElement("div");
    userBubble.className = "px-3 py-2 rounded-xl rounded-br-sm bg-subtle text-dark text-xs whitespace-pre-wrap break-words max-w-[90%]";
    userBubble.textContent = text;
    userRow.appendChild(userBubble);
    area.appendChild(userRow);

    /* Start agent response bubble */
    const agentRow = document.createElement("div");
    agentRow.className = "flex justify-start mb-3";
    const agentBubble = document.createElement("div");
    agentBubble.className = "px-3 py-2 rounded-xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-xs whitespace-pre-wrap break-words min-w-0 max-w-[90%]";
    agentBubble.textContent = "";
    agentRow.appendChild(agentBubble);
    area.appendChild(agentRow);

    compareStreamBubbles[i] = agentBubble;
    compareStreamedContent[i] = "";

    /* Scroll area to bottom */
    area.scrollTop = area.scrollHeight;
  });

  /* Open compare WebSocket */
  const proto = location.protocol === "https:" ? "wss:" : "ws:";
  const url = proto + "//" + location.host + "/api/playground/compare/chat";

  if (compareWs) { compareWs.close(); compareWs = null; }
  compareWs = new WebSocket(url);

  let doneCount = 0;
  const expectedDone = selectedModels.length;

  compareWs.onopen = function() {
    compareWs!.send(JSON.stringify({
      content: text,
      models: selectedModels.map(function(m) {
        return { provider_type: m.provider_type, model_name: m.model_name };
      }),
    }));
  };

  compareWs.onmessage = function(event) {
    let data;
    try { data = JSON.parse(event.data); } catch (_e) { return; }
    const mi = data.model_index;
    if (mi === undefined || mi < 0 || mi >= selectedModels.length) return;

    if (data.type === "token") {
      compareStreamedContent[mi] += data.content;
      if (compareStreamBubbles[mi]) {
        compareStreamBubbles[mi]!.textContent = compareStreamedContent[mi];
        const area = compareColumns.querySelector('[data-response-area="' + mi + '"]');
        if (area) area.scrollTop = area.scrollHeight;
      }
    } else if (data.type === "done") {
      doneCount++;
      const rawText = compareStreamedContent[mi];
      results[mi].content = rawText;
      results[mi].usage = data.usage || null;
      results[mi].latency_ms = data.latency_ms;
      results[mi].finish_reason = data.finish_reason;

      /* Calculate cost */
      const promptTok = data.usage?.prompt_tokens || 0;
      const completionTok = data.usage?.completion_tokens || 0;
      results[mi].cost = calcCost(data.model || selectedModels[mi].model_name, promptTok, completionTok);

      /* Render markdown for finished response */
      if (compareStreamBubbles[mi]) {
        compareStreamBubbles[mi]!.className = "px-3 py-2 rounded-xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-xs break-words chat-prose min-w-0 max-w-[90%]";
        compareStreamBubbles[mi]!.innerHTML = renderMarkdown(rawText);
      }

      /* Show footer with metrics */
      const footer = compareColumns.querySelector('[data-col-footer="' + mi + '"]') as HTMLElement;
      if (footer) {
        footer.classList.remove("hidden");
        const metricsEl = footer.querySelector('[data-footer-metrics="' + mi + '"]');
        if (metricsEl) {
          let html = "";
          if (data.latency_ms !== undefined) html += '<div><span class="text-muted">Latency:</span> ' + data.latency_ms.toLocaleString() + 'ms</div>';
          const total = promptTok + completionTok;
          if (total > 0) html += '<div><span class="text-muted">Tokens:</span> ' + promptTok.toLocaleString() + ' in / ' + completionTok.toLocaleString() + ' out</div>';
          if (results[mi].cost && results[mi].cost! > 0) html += '<div><span class="text-muted">Cost:</span> ' + formatCost(results[mi].cost!) + '</div>';
          metricsEl.innerHTML = html;
        }
      }

      /* Check if all models are done */
      if (doneCount >= expectedDone) {
        compareStreaming = false;
        updateCompareInputState();
        compareMessageInput.value = "";
        compareMessageInput.focus();
      }
    } else if (data.type === "error") {
      results[mi].error = data.message;
      if (compareStreamBubbles[mi]) {
        compareStreamBubbles[mi]!.className = "px-3 py-2 rounded-xl rounded-bl-sm bg-coral/5 border border-coral/20 text-coral text-xs break-words min-w-0 max-w-[90%]";
        compareStreamBubbles[mi]!.textContent = "Error: " + data.message;
      }
      doneCount++;
      if (doneCount >= expectedDone) {
        compareStreaming = false;
        updateCompareInputState();
      }
    }
  };

  compareWs.onclose = function() {
    if (compareStreaming) {
      compareStreaming = false;
      updateCompareInputState();
    }
  };

  compareWs.onerror = function() {
    compareConnectionStatus.textContent = "WebSocket connection error.";
    compareConnectionStatus.classList.remove("hidden");
    compareStreaming = false;
    updateCompareInputState();
  };

  compareMessageInput.value = "";
}

compareSendBtn.addEventListener("click", sendCompareMessage);
compareMessageInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendCompareMessage();
  }
});
compareMessageInput.addEventListener("input", function() {
  compareMessageInput.style.height = "auto";
  compareMessageInput.style.height = Math.min(compareMessageInput.scrollHeight, 160) + "px";
});

/* Export comparison as JSON */
function exportCompareResults() {
  if (compareHistory.length === 0) return;
  const exportData = {
    timestamp: new Date().toISOString(),
    rounds: compareHistory.map(function(round) {
      return {
        prompt: round.prompt,
        responses: round.results.map(function(r) {
          return {
            model: r.model.display_name,
            provider_type: r.model.provider_type,
            model_name: r.model.model_name,
            content: r.content,
            usage: r.usage,
            latency_ms: r.latency_ms,
            finish_reason: r.finish_reason,
            cost: r.cost,
            rating: r.rating || null,
            error: r.error || null,
          };
        }),
      };
    }),
  };
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "comparison-" + new Date().toISOString().slice(0, 19).replace(/:/g, "-") + ".json";
  a.click();
  URL.revokeObjectURL(url);
}

compareExportBtn.addEventListener("click", exportCompareResults);

/* ---- Voice input setup ---- */
if (SpeechRecognitionAPI) {
  speechRecognition = new SpeechRecognitionAPI();
  speechRecognition.continuous = false;
  speechRecognition.interimResults = true;
  speechRecognition.lang = navigator.language || "en-US";

  speechRecognition.onresult = function(event: any) {
    let transcript = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      transcript += event.results[i][0].transcript;
    }
    messageInput.value = transcript;
    autoResize();
  };

  speechRecognition.onend = function() {
    isRecording = false;
    micRecordingDot.classList.add("hidden");
    micBtn.classList.remove("text-coral", "border-coral");
    micBtn.classList.add("text-muted");
    if (autoSendOnVoice && messageInput.value.trim()) {
      sendMessage();
    }
  };

  speechRecognition.onerror = function(event: any) {
    isRecording = false;
    micRecordingDot.classList.add("hidden");
    micBtn.classList.remove("text-coral", "border-coral");
    micBtn.classList.add("text-muted");
    if (event.error !== "aborted" && event.error !== "no-speech") {
      appendError("Voice input error: " + event.error);
    }
  };
} else {
  micBtn.title = "Voice input is not supported in this browser";
}

micBtn.addEventListener("click", function() {
  if (!speechRecognition) {
    appendError("Voice input is not supported in this browser. Please use Chrome or Edge.");
    return;
  }
  if (isRecording) {
    speechRecognition.stop();
    return;
  }
  isRecording = true;
  micRecordingDot.classList.remove("hidden");
  micBtn.classList.add("text-coral", "border-coral");
  micBtn.classList.remove("text-muted");
  messageInput.value = "";
  autoResize();
  speechRecognition.start();
});

/* ---- TTS toggle ---- */
ttsToggleBtn.addEventListener("click", function() {
  if (!hasSpeechSynthesis) {
    appendError("Text-to-speech is not supported in this browser. Please use Chrome, Edge, or Safari.");
    return;
  }
  ttsEnabled = !ttsEnabled;
  if (ttsEnabled) {
    ttsToggleBtn.classList.add("text-coral");
    ttsToggleBtn.classList.remove("text-muted");
    ttsIconEl.innerHTML = SPEAKER_ON_SVG;
  } else {
    ttsToggleBtn.classList.remove("text-coral");
    ttsToggleBtn.classList.add("text-muted");
    ttsIconEl.innerHTML = SPEAKER_OFF_SVG;
    window.speechSynthesis.cancel();
  }
});

/* ---- Thread sidebar ---- */
const threadSidebar = document.getElementById("thread-sidebar")!;
const threadToggleBtn = document.getElementById("thread-toggle-btn")!;
const threadNewBtn = document.getElementById("thread-new-btn")!;
const threadSearch = document.getElementById("thread-search") as HTMLInputElement;
const threadList = document.getElementById("thread-list")!;
const threadEmptyEl = document.getElementById("thread-empty")!;
const threadMetaBar = document.getElementById("thread-meta-bar")!;
const threadMetaAgent = document.getElementById("thread-meta-agent")!;
const threadMetaTokens = document.getElementById("thread-meta-tokens")!;
const threadMetaCost = document.getElementById("thread-meta-cost")!;
const threadMetaCount = document.getElementById("thread-meta-count")!;
const threadDeleteDialog = document.getElementById("thread-delete-dialog") as HTMLDialogElement;
const threadDeleteCancel = document.getElementById("thread-delete-cancel")!;
const threadDeleteConfirm = document.getElementById("thread-delete-confirm")!;

let threadSidebarOpen = false;
let currentThreadId: string | null = null;
let threadDeleteTarget: string | null = null;
let threadSearchDebounce: ReturnType<typeof setTimeout> | null = null;

interface ThreadItem {
  id: string;
  agent_id: string;
  first_message_preview: string;
  message_count: number;
  total_tokens: number;
  total_cost: number;
  created_at: string;
  updated_at: string;
}

let threads: ThreadItem[] = [];

function toggleThreadSidebar() {
  threadSidebarOpen = !threadSidebarOpen;
  if (threadSidebarOpen) {
    threadSidebar.classList.remove("hidden");
    threadToggleBtn.classList.add("text-coral");
    threadToggleBtn.classList.remove("text-muted");
    if (currentAgentId) loadThreads(currentAgentId);
  } else {
    threadSidebar.classList.add("hidden");
    threadToggleBtn.classList.remove("text-coral");
    threadToggleBtn.classList.add("text-muted");
  }
}

threadToggleBtn.addEventListener("click", toggleThreadSidebar);

function formatRelativeTime(dateStr: string): string {
  const date = new Date(dateStr + "Z"); /* UTC from server */
  const now = Date.now();
  const diff = now - date.getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return "Just now";
  if (mins < 60) return mins + "m ago";
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return hrs + "h ago";
  const days = Math.floor(hrs / 24);
  if (days < 7) return days + "d ago";
  return date.toLocaleDateString([], { month: "short", day: "numeric" });
}

async function loadThreads(agentId: string) {
  try {
    const res = await fetch("/api/threads?agent_id=" + encodeURIComponent(agentId), { credentials: "same-origin" });
    if (!res.ok) return;
    threads = await res.json();
    renderThreadList();
  } catch (_e) { /* non-critical */ }
}

async function searchThreads(query: string) {
  try {
    const res = await fetch("/api/threads/search?q=" + encodeURIComponent(query), { credentials: "same-origin" });
    if (!res.ok) return;
    threads = await res.json();
    renderThreadList();
  } catch (_e) { /* non-critical */ }
}

function renderThreadList() {
  /* Remove all children except empty state */
  const children = Array.from(threadList.children);
  children.forEach(function(c) {
    if (c.id !== "thread-empty") threadList.removeChild(c);
  });

  if (threads.length === 0) {
    threadEmptyEl.classList.remove("hidden");
    return;
  }
  threadEmptyEl.classList.add("hidden");

  threads.forEach(function(t) {
    const item = document.createElement("button");
    item.type = "button";
    item.className = "w-full text-left px-3 py-2.5 border-b border-dark/[0.04] hover:bg-subtle/50 transition-colors group relative"
      + (t.id === currentThreadId ? " bg-subtle/60" : "");
    item.dataset.threadId = t.id;

    const preview = document.createElement("div");
    preview.className = "text-xs text-dark truncate pr-6";
    preview.textContent = t.first_message_preview || "New thread";

    const meta = document.createElement("div");
    meta.className = "flex items-center gap-2 mt-1";

    const time = document.createElement("span");
    time.className = "text-[10px] text-muted tabular-nums";
    time.textContent = formatRelativeTime(t.updated_at);

    const count = document.createElement("span");
    count.className = "text-[10px] text-muted tabular-nums";
    count.textContent = t.message_count + " msg" + (t.message_count !== 1 ? "s" : "");

    meta.appendChild(time);
    meta.appendChild(count);

    /* Delete button (appears on hover) */
    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "absolute top-2 right-2 p-1 rounded text-muted/40 hover:text-coral opacity-0 group-hover:opacity-100 transition-opacity";
    delBtn.title = "Delete thread";
    delBtn.innerHTML = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>';
    delBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      threadDeleteTarget = t.id;
      threadDeleteDialog.showModal();
    });

    item.appendChild(preview);
    item.appendChild(meta);
    item.appendChild(delBtn);

    item.addEventListener("click", function() { switchToThread(t); });
    threadList.appendChild(item);
  });
}

async function switchToThread(t: ThreadItem) {
  currentThreadId = t.id;
  renderThreadList(); /* highlight active */

  /* Show metadata bar */
  const agent = agents.find(function(a) { return a.id === t.agent_id; });
  threadMetaAgent.textContent = agent ? agent.name : t.agent_id;
  threadMetaTokens.textContent = t.total_tokens.toLocaleString();
  threadMetaCost.textContent = formatCost(t.total_cost);
  threadMetaCount.textContent = String(t.message_count);
  threadMetaBar.classList.remove("hidden");

  /* Clear current messages */
  const msgChildren = Array.from(messagesEl.children);
  msgChildren.forEach(function(c) {
    if (c.id !== "empty-state") messagesEl.removeChild(c);
  });

  /* Load thread messages */
  try {
    const res = await fetch("/api/threads/" + t.id + "/messages", { credentials: "same-origin" });
    if (!res.ok) return;
    const messages = await res.json();
    if (messages.length === 0) {
      showEmptyState();
    } else {
      hideEmptyState();
      messages.forEach(function(m: { role: string; content: string }) {
        if (m.role === "user") {
          addUserMessage(m.content);
        } else if (m.role === "assistant") {
          addRestoredAgentMessage(m.content);
        }
      });
    }
  } catch (_e) { /* non-critical */ }

  /* Set agent selector to match thread's agent */
  if (t.agent_id !== agentSelect.value) {
    agentSelect.value = t.agent_id;
    const agent2 = agents.find(function(a) { return a.id === t.agent_id; });
    if (agent2 && agent2.model_provider) {
      agentModel.textContent = agent2.model_provider + (agent2.model_name ? ":" + agent2.model_name : "");
      agentInfo.classList.remove("hidden");
    }
  }

  /* Connect WS for this agent (new conversation for interactive use) */
  if (currentAgentId !== t.agent_id) {
    connectWebSocket(t.agent_id);
  }
}

async function createThread() {
  if (!currentAgentId) return;
  try {
    const res = await fetch("/api/threads", {
      method: "POST",
      credentials: "same-origin",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ agent_id: currentAgentId }),
    });
    if (!res.ok) return;
    const thread = await res.json();
    currentThreadId = thread.id;
    /* Clear chat for fresh thread */
    clearMessages();
    /* Reload thread list */
    loadThreads(currentAgentId);
  } catch (_e) { /* non-critical */ }
}

async function deleteThread(threadId: string) {
  try {
    const res = await fetch("/api/threads/" + threadId, {
      method: "DELETE",
      credentials: "same-origin",
    });
    if (!res.ok) return;
    /* If we deleted the active thread, clear chat */
    if (threadId === currentThreadId) {
      currentThreadId = null;
      threadMetaBar.classList.add("hidden");
      clearMessages();
    }
    /* Reload thread list */
    if (currentAgentId) loadThreads(currentAgentId);
  } catch (_e) { /* non-critical */ }
}

threadNewBtn.addEventListener("click", createThread);

threadDeleteCancel.addEventListener("click", function() {
  threadDeleteTarget = null;
  threadDeleteDialog.close();
});

threadDeleteConfirm.addEventListener("click", function() {
  if (threadDeleteTarget) {
    deleteThread(threadDeleteTarget);
    threadDeleteTarget = null;
  }
  threadDeleteDialog.close();
});

/* Close dialog on click outside */
threadDeleteDialog.addEventListener("click", function(e) {
  if (e.target === threadDeleteDialog) {
    threadDeleteTarget = null;
    threadDeleteDialog.close();
  }
});

/* Search input with debounce */
threadSearch.addEventListener("input", function() {
  if (threadSearchDebounce) clearTimeout(threadSearchDebounce);
  const q = threadSearch.value.trim();
  threadSearchDebounce = setTimeout(function() {
    if (q.length > 0) {
      searchThreads(q);
    } else if (currentAgentId) {
      loadThreads(currentAgentId);
    }
  }, 300);
});

/* ---- Init ---- */
loadAgents();
loadPricing();
</script>
