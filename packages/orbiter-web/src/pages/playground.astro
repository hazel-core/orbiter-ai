---
import PageLayout from "../layouts/PageLayout.astro";

const breadcrumbs = [{ label: "Playground" }];

/* Icons */
const sendIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
const botIcon = '<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';
const clearIcon = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>';
---

<PageLayout
  title="Playground"
  description="Chat with your AI agents"
  activeSection="playground"
  breadcrumbs={breadcrumbs}
  class="!overflow-hidden flex flex-col"
>
  <div class="flex flex-col h-full">
    <!-- Top bar: agent selector -->
    <div class="flex items-center gap-3 px-4 py-3 border-b border-dark/[0.08] bg-paper flex-shrink-0">
      <label for="agent-select" class="text-sm font-medium text-dark whitespace-nowrap">Agent:</label>
      <select
        id="agent-select"
        class="flex-1 max-w-xs px-3 py-1.5 text-sm border border-dark/[0.08] rounded-lg bg-paper text-dark focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors"
      >
        <option value="">Select an agent...</option>
      </select>
      <div id="agent-info" class="text-xs text-muted hidden">
        <span id="agent-model" class="inline-flex items-center gap-1 px-2 py-0.5 bg-subtle rounded-full"></span>
      </div>
      <div class="ml-auto">
        <button
          id="clear-btn"
          class="inline-flex items-center gap-1.5 px-3 py-1.5 text-xs text-muted hover:text-dark transition-colors rounded-lg hover:bg-subtle"
          title="Clear conversation"
        >
          <span set:html={clearIcon} />
          <span class="hidden sm:inline">Clear</span>
        </button>
      </div>
    </div>

    <!-- Messages area (relative for scroll-to-bottom button) -->
    <div class="relative flex-1">
      <div id="messages" class="absolute inset-0 overflow-y-auto px-4 py-6 space-y-4">
        <!-- Empty state -->
        <div id="empty-state" class="flex flex-col items-center justify-center h-full text-center">
          <div class="w-16 h-16 rounded-full bg-subtle flex items-center justify-center mb-4">
            <span class="text-muted" set:html={botIcon} />
          </div>
          <h3 class="text-lg font-medium text-dark mb-2">Chat Playground</h3>
          <p class="text-sm text-muted max-w-sm">Select an agent above and start chatting. Messages stream in real-time via WebSocket.</p>
        </div>
      </div>

      <!-- Scroll to bottom button -->
      <button
        id="scroll-bottom-btn"
        class="absolute bottom-4 left-1/2 -translate-x-1/2 hidden items-center gap-1.5 px-3 py-1.5 bg-dark text-paper text-xs rounded-full shadow-lg hover:opacity-90 transition-all z-10"
        title="Scroll to bottom"
      >
        <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
        New messages
      </button>
    </div>

    <!-- Input area -->
    <div class="flex-shrink-0 border-t border-dark/[0.08] bg-paper px-4 py-3">
      <div id="connection-status" class="hidden text-xs text-coral mb-2 px-1"></div>
      <div class="flex items-end gap-3 max-w-4xl mx-auto">
        <textarea
          id="message-input"
          rows="1"
          placeholder="Type a message... (Enter to send, Shift+Enter for newline)"
          disabled
          class="flex-1 px-4 py-2.5 text-sm border border-dark/[0.08] rounded-xl bg-paper text-dark placeholder:text-muted/60 focus:outline-none focus:ring-2 focus:ring-coral/20 focus:border-coral transition-colors resize-none max-h-40 disabled:opacity-50"
        ></textarea>
        <button
          id="send-btn"
          disabled
          class="flex-shrink-0 p-2.5 bg-coral text-white rounded-xl hover:bg-coral/90 transition-colors disabled:opacity-40 disabled:cursor-not-allowed"
          title="Send message"
        >
          <span set:html={sendIcon} />
        </button>
      </div>
    </div>
  </div>
</PageLayout>

<script>
import { marked } from "marked";

// Configure marked for safe rendering
marked.setOptions({
  breaks: true,
  gfm: true,
});

const agentSelect = document.getElementById("agent-select") as HTMLSelectElement;
const agentInfo = document.getElementById("agent-info")!;
const agentModel = document.getElementById("agent-model")!;
const messagesEl = document.getElementById("messages")!;
const emptyState = document.getElementById("empty-state")!;
const messageInput = document.getElementById("message-input") as HTMLTextAreaElement;
const sendBtn = document.getElementById("send-btn") as HTMLButtonElement;
const clearBtn = document.getElementById("clear-btn")!;
const connectionStatus = document.getElementById("connection-status")!;
const scrollBottomBtn = document.getElementById("scroll-bottom-btn")!;

let ws: WebSocket | null = null;
let currentAgentId: string | null = null;
let currentConversationId: string | null = null;
let agents: Array<{ id: string; name: string; model_provider?: string; model_name?: string }> = [];
let isStreaming = false;
let userScrolledUp = false;

const COPY_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
const CHECK_ICON = '<svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';

/* ---- Load agents ---- */
async function loadAgents() {
  try {
    const res = await fetch("/api/agents", { credentials: "same-origin" });
    if (!res.ok) return;
    agents = await res.json();
    agentSelect.innerHTML = '<option value="">Select an agent...</option>';
    agents.forEach(function(a) {
      const opt = document.createElement("option");
      opt.value = a.id;
      opt.textContent = a.name + (a.model_provider ? " (" + a.model_provider + ")" : "");
      agentSelect.appendChild(opt);
    });
  } catch (e) {
    console.error("Failed to load agents:", e);
  }
}

/* ---- WebSocket management ---- */
function connectWebSocket(agentId: string, conversationId?: string) {
  if (ws) {
    ws.close();
    ws = null;
  }

  currentAgentId = agentId;
  currentConversationId = conversationId || null;
  const proto = location.protocol === "https:" ? "wss:" : "ws:";
  const url = proto + "//" + location.host + "/api/playground/" + agentId + "/chat";

  connectionStatus.classList.add("hidden");
  connectionStatus.textContent = "";

  ws = new WebSocket(url);

  ws.onopen = function() {
    messageInput.disabled = false;
    sendBtn.disabled = false;
    messageInput.focus();
    // Load existing conversation if specified
    if (conversationId && ws) {
      ws.send(JSON.stringify({ type: "load_conversation", conversation_id: conversationId }));
    }
  };

  ws.onclose = function(e) {
    if (e.code === 4001) {
      showStatus("Authentication required. Please log in.");
    } else if (e.code === 4004) {
      showStatus("Agent not found.");
    } else if (e.code !== 1000 && e.code !== 1001) {
      showStatus("Connection closed (code " + e.code + ")");
    }
    messageInput.disabled = true;
    sendBtn.disabled = true;
    isStreaming = false;
    ws = null;
  };

  ws.onerror = function() {
    showStatus("WebSocket connection error.");
  };

  ws.onmessage = function(event) {
    let data;
    try {
      data = JSON.parse(event.data);
    } catch (_e) {
      return;
    }

    if (data.type === "token") {
      appendToken(data.content);
    } else if (data.type === "done") {
      finishStream(data.usage);
    } else if (data.type === "error") {
      appendError(data.message);
      isStreaming = false;
      messageInput.disabled = false;
      sendBtn.disabled = false;
    } else if (data.type === "conversation_created") {
      currentConversationId = data.conversation_id;
    } else if (data.type === "conversation_loaded") {
      currentConversationId = data.conversation_id;
      restoreMessages(data.messages);
    }
  };
}

function disconnectWebSocket() {
  if (ws) {
    ws.close();
    ws = null;
  }
  currentAgentId = null;
  messageInput.disabled = true;
  sendBtn.disabled = true;
}

function showStatus(msg: string) {
  connectionStatus.textContent = msg;
  connectionStatus.classList.remove("hidden");
}

/* ---- Copy button helper ---- */
function createCopyButton(getText: () => string): HTMLButtonElement {
  const btn = document.createElement("button");
  btn.className = "copy-msg-btn absolute top-2 right-2 p-1 rounded bg-subtle/80 text-muted hover:text-dark opacity-0 group-hover:opacity-100 transition-opacity";
  btn.title = "Copy message";
  btn.innerHTML = COPY_ICON;
  btn.addEventListener("click", function() {
    navigator.clipboard.writeText(getText()).then(function() {
      btn.innerHTML = CHECK_ICON;
      btn.classList.add("text-zen-green");
      setTimeout(function() {
        btn.innerHTML = COPY_ICON;
        btn.classList.remove("text-zen-green");
      }, 1500);
    });
  });
  return btn;
}

/* ---- Restore saved messages ---- */
function restoreMessages(messages: Array<{ role: string; content: string }>) {
  messages.forEach(function(m) {
    if (m.role === "user") {
      addUserMessage(m.content);
    } else if (m.role === "assistant") {
      addRestoredAgentMessage(m.content);
    }
    // Skip system messages â€” they're not displayed
  });
}

function addRestoredAgentMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
  bubble.innerHTML = renderMarkdown(text);

  const copyBtn = createCopyButton(() => text);
  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  wrapper.appendChild(copyBtn);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Message rendering ---- */
function hideEmptyState() {
  emptyState.classList.add("hidden");
}

function showEmptyState() {
  emptyState.classList.remove("hidden");
}

function renderMarkdown(text: string): string {
  return marked.parse(text) as string;
}

function addUserMessage(text: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-end";

  const bubble = document.createElement("div");
  bubble.className = "max-w-[75%] sm:max-w-[60%] relative group";

  const inner = document.createElement("div");
  inner.className = "px-4 py-2.5 rounded-2xl rounded-br-sm bg-subtle text-dark text-sm whitespace-pre-wrap break-words";
  inner.textContent = text;

  const copyBtn = createCopyButton(() => text);
  bubble.appendChild(inner);
  bubble.appendChild(copyBtn);
  row.appendChild(bubble);
  messagesEl.appendChild(row);
  scrollToBottom();
}

let currentStreamBubble: HTMLElement | null = null;
let streamedContent = "";

function startAgentMessage() {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-start";

  const wrapper = document.createElement("div");
  wrapper.className = "max-w-[75%] sm:max-w-[60%] flex gap-2 relative group";

  const avatar = document.createElement("div");
  avatar.className = "flex-shrink-0 w-7 h-7 rounded-full bg-coral/10 text-coral flex items-center justify-center mt-1";
  avatar.innerHTML = '<svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/><line x1="8" y1="16" x2="8" y2="16"/><line x1="16" y1="16" x2="16" y2="16"/></svg>';

  const bubble = document.createElement("div");
  bubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm whitespace-pre-wrap break-words min-w-0";
  bubble.textContent = "";

  wrapper.appendChild(avatar);
  wrapper.appendChild(bubble);
  row.appendChild(wrapper);
  messagesEl.appendChild(row);

  currentStreamBubble = bubble;
  streamedContent = "";
  scrollToBottom();
}

function appendToken(token: string) {
  if (!currentStreamBubble) {
    startAgentMessage();
  }
  streamedContent += token;
  currentStreamBubble!.textContent = streamedContent;
  scrollToBottom();
}

function finishStream(usage: { prompt_tokens?: number; completion_tokens?: number } | null) {
  if (currentStreamBubble) {
    // Render markdown now that streaming is complete
    const rawText = streamedContent;
    currentStreamBubble.textContent = "";
    currentStreamBubble.className = "px-4 py-2.5 rounded-2xl rounded-bl-sm bg-paper border border-dark/[0.06] text-dark text-sm break-words chat-prose min-w-0";
    currentStreamBubble.innerHTML = renderMarkdown(rawText);

    // Add copy button to the wrapper (which is the parent of bubble)
    const wrapper = currentStreamBubble.parentElement!;
    const copyBtn = createCopyButton(() => rawText);
    wrapper.appendChild(copyBtn);

    if (usage) {
      const meta = document.createElement("div");
      meta.className = "text-[10px] text-muted/60 mt-1.5 text-right";
      const parts: string[] = [];
      if (usage.prompt_tokens) parts.push(usage.prompt_tokens + " in");
      if (usage.completion_tokens) parts.push(usage.completion_tokens + " out");
      if (parts.length > 0) {
        meta.textContent = parts.join(" / ") + " tokens";
        wrapper.appendChild(meta);
      }
    }
  }
  currentStreamBubble = null;
  streamedContent = "";
  isStreaming = false;
  messageInput.disabled = false;
  sendBtn.disabled = false;
  messageInput.focus();
  scrollToBottom();
}

function appendError(msg: string) {
  hideEmptyState();
  const row = document.createElement("div");
  row.className = "flex justify-center";
  const pill = document.createElement("div");
  pill.className = "px-4 py-2 rounded-xl bg-coral/10 text-coral text-xs max-w-md text-center";
  pill.textContent = msg;
  row.appendChild(pill);
  messagesEl.appendChild(row);
  scrollToBottom();
}

/* ---- Scroll management ---- */
function isNearBottom(): boolean {
  const threshold = 80;
  return messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < threshold;
}

function scrollToBottom() {
  if (!userScrolledUp) {
    requestAnimationFrame(function() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }
}

function updateScrollButton() {
  if (isNearBottom()) {
    userScrolledUp = false;
    scrollBottomBtn.classList.add("hidden");
    scrollBottomBtn.classList.remove("flex");
  } else {
    userScrolledUp = true;
    scrollBottomBtn.classList.remove("hidden");
    scrollBottomBtn.classList.add("flex");
  }
}

messagesEl.addEventListener("scroll", updateScrollButton);

scrollBottomBtn.addEventListener("click", function() {
  userScrolledUp = false;
  messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: "smooth" });
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
});

function clearMessages() {
  /* Remove all children except the empty state */
  const children = Array.from(messagesEl.children);
  children.forEach(function(c) {
    if (c.id !== "empty-state") messagesEl.removeChild(c);
  });
  showEmptyState();
  currentStreamBubble = null;
  streamedContent = "";
  currentConversationId = null;
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  /* Reconnect to reset conversation history on server (new conversation) */
  if (currentAgentId) {
    connectWebSocket(currentAgentId);
  }
}

/* ---- Send message ---- */
function sendMessage() {
  const text = messageInput.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN || isStreaming) return;

  addUserMessage(text);
  ws.send(JSON.stringify({ content: text }));
  messageInput.value = "";
  autoResize();
  isStreaming = true;
  messageInput.disabled = true;
  sendBtn.disabled = true;
  /* Reset scroll tracking so auto-scroll works for the new response */
  userScrolledUp = false;
  scrollBottomBtn.classList.add("hidden");
  scrollBottomBtn.classList.remove("flex");
  startAgentMessage();
}

/* ---- Auto-resize textarea ---- */
function autoResize() {
  messageInput.style.height = "auto";
  messageInput.style.height = Math.min(messageInput.scrollHeight, 160) + "px";
}

/* ---- Event listeners ---- */
agentSelect.addEventListener("change", function() {
  const val = agentSelect.value;
  if (!val) {
    disconnectWebSocket();
    agentInfo.classList.add("hidden");
    return;
  }
  /* Show model info */
  const agent = agents.find(function(a) { return a.id === val; });
  if (agent && agent.model_provider) {
    agentModel.textContent = agent.model_provider + (agent.model_name ? ":" + agent.model_name : "");
    agentInfo.classList.remove("hidden");
  } else {
    agentInfo.classList.add("hidden");
  }
  clearMessages();
  connectWebSocket(val);
});

messageInput.addEventListener("keydown", function(e) {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

messageInput.addEventListener("input", autoResize);

sendBtn.addEventListener("click", sendMessage);

clearBtn.addEventListener("click", clearMessages);

/* ---- Init ---- */
loadAgents();
</script>
